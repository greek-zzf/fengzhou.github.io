<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT 6.824 分布式系统 - Introduction</title>
    <link href="/2022/12/20/6.824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-Introduction/"/>
    <url>/2022/12/20/6.824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式系统基础架构"><a href="#分布式系统基础架构" class="headerlink" title="分布式系统基础架构"></a>分布式系统基础架构</h2><ul><li>存储</li><li>计算</li><li>通信（关于通信的详细内容可观看 6.829 计算机网络）</li></ul>]]></content>
    
    
    <categories>
      
      <category>6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式，6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="/2022/12/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/12/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>这是一个简单的 Hexo 博客搭建教程，无需自己购买服务器，也能搭建属于自己的博客。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>Gitee 账号或者 GitHub 账号。Gitee 账号和 GitHub 账号都很容易申请，考虑到博客的访问速度，更推荐使用 Gitee。然后新建一个公开的空仓库，仓库的命名需要和你的账号名保持一致。在 Gitee 中访问个人的主页，浏览器上的地址会变成 <code>gitee.com/xxx</code>，这个 <code>xxx</code>  就是你的账号名。同理，进入 GitHub 的个人主页，地址栏 <code>github.com/xxx</code>。</p></li><li><p>Git。电脑需要安装 Git，使用 <code>git --version</code> 确保 Git 是安装成功的。</p></li><li><p>Node 环境。Node 环境安装也很简单，百度关键词 <code>nodejs</code> 进入官网下载，安装了过程无脑下一步即可。安装完成后，控制台使用 <code>node -v</code>命令，打印出 node 的版本信息即为成功。例如我的电脑打印的 node 版本信息 <code>v19.1.0</code>。</p></li><li><p>安装 Hexo。Node 环境准备好之后，使用命令 <code>npm install -g hexo-cli</code> 安装 Hexo，等待控制台输出完成即可，使用 <code>hexo -v</code> 验证是否安装成功。Hexo 官方文档有详细的安装方法，可以<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85">参考</a>。</p></li><li><p>至此，所有准备工作已完成。</p></li></ol><h2 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h2><p> 首先，使用 hexo 命令创建一个文件夹，文件夹的名称和路径自己指定。为了规避一些潜在的问题，名称和路径最好是英文的。此处创建一个 <code>blog</code> 文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init blog<br></code></pre></td></tr></table></figure><p>等待一会，然后进入到 blog 文件夹。需要注意的是， 文件夹有个 <code>.gitignore</code> 文件，需要将 <code>public/</code> 这行删除，后续步骤会使用到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">.DS_Store<br>Thumbs.db<br>db.json<br>*.log<br>node_modules/<br>public/  # 删除这行<br>.deploy*/<br>_multiconfig.yml<br></code></pre></td></tr></table></figure><p>安装所需依赖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install <br></code></pre></td></tr></table></figure><p>将 md 文件生成 html 文件，此时 blog 目录下自动生成 <code>public</code> 文件夹，用于保存 html 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo generate<br></code></pre></td></tr></table></figure><p>之后，使用命令在本地访问我们搭建的博客，看看效果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo server<br></code></pre></td></tr></table></figure><p>此时在浏览器上访问 <code>http://localhost:4000</code> 即可看到搭建的 hexo 博客了。停止访问只需要 <code>Ctrl + C</code>。</p><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>博客能本地访问，无法满足大多数人的需求，搭建博客的目的就是为了能够随时随地访问。</p><p>需要使用 git 命令提交，推送到远程仓库。要注意的是，只需要将 html 文件推送到远程仓库，因此推送 <code>public</code> 下的文件即可。</p><p>进入到 <code>blog/public</code> 文件夹，使用 Git 进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br></code></pre></td></tr></table></figure><p>关联远程仓库地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote add origin &lt;远程仓库地址&gt;<br></code></pre></td></tr></table></figure><p>使用 git 命令提交，推送到远程仓库。需要注意的是，只需要将生成好的 html 文件推送到远程仓库，因此推送 <code>public</code> 下的所有文件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git"># 添加 public 下的所有文件<br>git add .<br><br># 提交<br>git commit -m &#x27;init blog&#x27;<br><br># 推送到远程仓库<br>git push origin master<br></code></pre></td></tr></table></figure><p>推送成功后，远程仓库的目录结构应与下图类似</p><p><img src="/../picture/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/directory-tree.png"></p><h2 id="使用-pages-服务"><a href="#使用-pages-服务" class="headerlink" title="使用 pages 服务"></a>使用 pages 服务</h2><p>Gitee 和 GitHub 都提供了 <code>pages</code> 服务，<code>pages</code> 服务简单来说，就是让你的 html 文件能被其他人访问，这样就达到了博客共享的目的。</p><p><img src="/../picture/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/flowsheet.png" alt="ceui"></p><p>这个一整套流程就是：编写博客（markdown），使用 <code>hexo generate</code> 将 md 文件编译成 html 文件，使用 git 命令将文件推送到远程仓库，配置好 pages 服务即可。当然，pages 只需配置一次即可。</p><p>由于 Gitee 使用 pages 要实名认证，这里使用 <code>Github pages</code> 服务演示，原理都是一样的。</p><p>进入到刚建的仓库，按照如下步骤配置 <code>pages</code>服务。</p><p><img src="/../picture/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-pages-step.png" alt="github-pages-step"></p><p>这里告诉了 Github 要从哪个分支，哪个目录部署 pages 服务。如果你使用的是 Gitee Pages，原理也是一样的。pages 服务会去找 <code>index.html</code> 作为站点的入口文件。</p><p>等待片刻，就可以使用 <code>https://你的github账号名.github.io</code> 来访问你的博客了。</p><h2 id="添加自己的博客"><a href="#添加自己的博客" class="headerlink" title="添加自己的博客"></a>添加自己的博客</h2><p>以上部署好之后，可以开始编写自己的博客了。只需要将编写好的 markdown 文件放入 <code>blog/source/_posts</code> 即可。由于 hexo 默认的资源路径是 <code>source</code>，因此图片也应该放在该文件夹下。</p><p>博客添加完成后，需要重新编译生成 html 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo generate<br></code></pre></td></tr></table></figure><p>编译完成后，走上面的提交操作，把 html 文件推送到远程仓库。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>hexo 提供了大量的第三方主题，可以使用主题来美化博客。这里使用 <code>fluid</code> 主题举例，主题的官方文档点击<a href="https://hexo.fluid-dev.com/docs/start/">这里</a>。</p><p>使用主题很简单，只需要按照它官方文档的要求来即可。</p><p>例如 <code>fluid</code> 的官方文档说明如下</p><p><img src="/../picture/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/fluid-theme.png" alt="fluid"></p><p>将主题解压到 <code>blog/themes</code> 后，重命名为 <code>fluid</code>，然后修改 <code>blog/_config.yml</code> 文件，把 <code>theme</code> 字段替换为 <code>fluid</code>，语言也可以设置成中文。</p><p>主题设置好之后，重新编译，提交，推送到远程仓库即可。</p><p>若遇到主题样式不生效，可以先执行 <code>hexo clean</code> ，之后再执行 <code>hexo generate</code> 重新编译即可。</p><p>若一切妥当，你的主题应该与我的<a href="https://greek-zzf.github.io/">博客</a>基本一致。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p><code>blog</code> 文件夹下的文件，并没有一一细说其作用，日常只需要关心 <code>public</code> <code>source</code> <code>_config.yml</code> 几个文件即可。</p><p><code>_config.yml</code> 是整个博客的配置文件，有关的参数可以参考官方文档，有详细的说明。</p><p>同样主题的细节配置，比如字体样式，大小，首页图片等等，都是以主题的官方文档为准。</p><p>最后，期待你能根据我的教程，搭建满意的博客。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 服务化的几种方式</title>
    <link href="/2022/12/13/Linux%20%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/12/13/Linux%20%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>使用 nohub 命令，例如运行一个 java 项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohub java -jar xxx.jar<br></code></pre></td></tr></table></figure><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p><code>tmux</code> 全程 <code>terminal multiplexer</code> 意思是终端多路复用器。它可以启动一个新的终端进程，可以通过一些命令在当前终端和新终端之间来回切换。</p><p>因此，可以在新的终端进程中运行程序，然后使用命令切回到现有的终端即可。</p><p>tmux 一些常用的命令：</p><p>创建一个新的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux<br></code></pre></td></tr></table></figure><p>回到当前终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用 control + b，再使用 d 即可<br></code></pre></td></tr></table></figure><p>回到新的进程中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux attach<br></code></pre></td></tr></table></figure><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p><code>nohub</code> 和 <code>tmux</code> 的方法，都无法应对程序崩溃的情况，程序崩溃后需要人为重启。将程序执行改为系统服务，即可解决该问题。</p><p>此处使用 Unbuntu 的创建服务的方式举例：</p><p>创建一个配置文件 <code>my-program.service</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description= a service for java # 服务的描述<br>After=netwprk.target<br>StartLimitIntervalSec=0<br>[Service]<br>Type=simple<br>Restart=always # 自动重启<br>RestartSec=1<br>User=root<br>ExecStart=java -jar my-program.jar # 服务启动命令<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>创建完成后，启动服务即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start my-program<br></code></pre></td></tr></table></figure><p>服务配置详细信息，可以参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">这里</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>使用 docker 启动程序，在启动参数上加 <code>-d</code> 参数即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d my-program-image<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 9 语言特性</title>
    <link href="/2022/11/22/java9%20history/"/>
    <url>/2022/11/22/java9%20history/</url>
    
    <content type="html"><![CDATA[<h2 id="接口中允许添加私有方法"><a href="#接口中允许添加私有方法" class="headerlink" title="接口中允许添加私有方法"></a>接口中允许添加私有方法</h2><p>java 8 中添加了 <code>default</code> 方法，但这些方法之间却无法优雅的复用代码。例如：<code>methodA</code> 和 <code>methodB</code> 都需要调用 <code>biFunction</code> 方法，于是只能将 <code>biFunction</code> 方法声明成 <code>default</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Java8Interface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biFunction</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明一个新的 <code>default</code> 方法当然可行，但却不符合接口的原则。将不必要的方法，暴露出去会给调用者带来困扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Java9Interface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biFunction</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>允许私有方法后，只需把原来的 <code>default</code> 改成 <code>private</code> 即可。</p><h2 id="try-with-resource-优化"><a href="#try-with-resource-优化" class="headerlink" title="try-with-resource 优化"></a>try-with-resource 优化</h2><p>Java 7 之前关闭资源需要写如下代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> br.readLine();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 7 之后引入了 <code>try-with-resource</code> ，简化了 <code>finally</code> 块的代码，现在只需这样: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...)) &#123;<br>    <span class="hljs-keyword">return</span> br.readLine();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是需要使用的资源一多，代码就会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...)) &#123;<br>    <span class="hljs-keyword">return</span> br1.readLine() + br2.readLine() + br3.readLine();<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-keyword">try</span> (br1; br2; br3) &#123;<br>    <span class="hljs-keyword">return</span> br1.readLine() + br2.readLine() + br3.readLine();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：变量声明在 <code>try</code> 外面，很容易误导用户在 <code>try</code> 语句结束后，仍调用资源，这会导致运行时产生错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-keyword">try</span> (br1) &#123;<br>    System.out.println(br1.readLine());<br>&#125;<br>br1.readLine(); <span class="hljs-comment">// 此时资源已关闭，调用会报错</span><br></code></pre></td></tr></table></figure><h2 id="不再是有效标识符"><a href="#不再是有效标识符" class="headerlink" title="_ 不再是有效标识符"></a><code>_</code> 不再是有效标识符</h2><p>Java 9 之前可以将 <code>_</code> 下划线设置为变量，虽然编译器会警告，但运行不会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">_</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>System.out.println(_);<br></code></pre></td></tr></table></figure><p>Java 9 之后，代码会编译失败，会得到如下提示: </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">java: 从发行版 9 开始, &#x27;_&#x27; 为关键字, 不能用作标识符<br></code></pre></td></tr></table></figure><h2 id="菱形符号"><a href="#菱形符号" class="headerlink" title="菱形符号"></a>菱形符号</h2><p>Java 7 引入了菱形符号 <code>&lt;&gt;</code>，让编译推断构造器参数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 7 之前</span><br>List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br><span class="hljs-comment">// java 7 之后</span><br>List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>自动参数类型推断，简化了代码。但是匿名内部类的参数推断，却不支持。</p><p>这段代码在 Java 7 中，编译器会报错。Java 9 支持匿名内部类的类型推断，代码能正确执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(T content)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(content) &#123;<br>      <span class="hljs-comment">// 实现方法</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java Feature</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java9</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Bisect 快速上手</title>
    <link href="/2022/11/09/Git%20Bisect%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2022/11/09/Git%20Bisect%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>假设你刚接手一个项目，这时线上出现了一个 bug，因为对业务不熟悉加上老板施压，导致 bug 定位过程异常艰难，开始焦头烂额。</p><p>聪明的你转念一想：既然无法准确定位 bug，那不如先找到是哪个提交引入的 bug，这样再去定位 bug 就简单很多了。</p><p>于是你确认了bug 存在的 commit 区间，使用二分查找来找 <code>bug commit</code> ，假设 bug 存在的 commit 区间是（3 ~ 10），你开始了如下过程：</p><p><img src="/../picture/GitBisect%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/09b81c4f-3a12-469e-aa3d-2bd9bfcb8fa7.png" alt="find-bug-commit.png"></p><p>你确定了 3 是没有 bug ，10 有 bug，于是使用二分查找，找到 6，判断 6 有 bug。继续缩小范围，最终找到了第一次出现 bug 的 commit 是 4，就能确定 bug 是 4 引入的。</p><p>这个手动查找的过程比较繁琐，而恰好 git 是有命令来支持这个查找行为的，这个命令就是 <code>git bisect</code>。</p><h2 id="bisect-命令参数使用"><a href="#bisect-命令参数使用" class="headerlink" title="bisect 命令参数使用"></a>bisect 命令参数使用</h2><p>将上诉过程使用基本 Git 命令，来表示。</p><ol><li>找到引入 bug 的 commit 范围</li><li>二分查找，并切换到分支</li><li>运行代码，判断是否有 bug 是否存在</li><li>重复 2、3，最终确认第一次引入 bug 的 commit</li></ol><p>现在使用 <code>Git Bisect</code>来实现，步骤和上面都差不多，只不过省去了很多人为的动作。</p><ol><li>告诉 Git 需要开启 <code>bisect</code> 模式</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect start<br></code></pre></td></tr></table></figure><ol start="2"><li>告诉 Git 需要查找的 commit 范围，需要指定一个 good (正常代码) 和一个 bad（存在 bug 的提交）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs git">// 切换到 commit 10，并标记为 bad<br>git checkout 10<br>git bisect bad<br><br>// 切换到 commit 3，并标记为 good<br>git chekcout 3<br>git bisect good<br><br>// 这样 bisect 就确认了 commit 范围<br></code></pre></td></tr></table></figure><ol start="3"><li>步骤 2 执行结束后，Git 会进行二分查找，并自动切换到对应分支。只需要再验证分支是否还存在 bug，存在标记为 bad，反之 good</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">// 根据实际情况标记为 bad 或者 good<br><br>git bisect good <br>或<br>git bisect bad<br></code></pre></td></tr></table></figure><ol start="4"><li>只需重复 3 的过程，最后 bisect 会帮我们找到第一个出现 bug 的 commit。</li></ol><h2 id="In-Action"><a href="#In-Action" class="headerlink" title="In Action"></a>In Action</h2><p>实战 Demo 地址: <a href="https://github.com/greek-zzf/advanced-git">GitHub</a> 或 <a href="https://gitee.com/geek-zzf/git-bisect-practice">Gitee</a>。</p><p>这个项目有多个版本，从 v1.0 到 v9.1，其中我们能确定 v1.0 是没有 bug，v9.1 是有 bug 的，bug 的表现形式是一条输出语句<code>I have a bug!</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m version 9.1!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;I have a bug!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;A bad feature!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>git bisect</code> 查找过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs git"># 切换到任意版本(需要提前确认该版本是否存在 bug)，由于已确认 v9.1 有 bug，切换到 v9.1<br>git checkout v9.1<br><br># 标记 git bisect 开始<br>git bisect start<br><br># 存在 bug，标记为 bad<br>git bisect bad<br><br># 切换到不存在 bug 的分支，标记为 good<br>git checkout v1.0 <br>git bisect good<br><br># 此时 git 已经自动切换到一个新的 commit，标记当前 commit<br>git bisect (good or bad) <br><br># 重复上一步，直到 git，给出如下提示<br>xxxxxx is the first bad commit<br>commit xxxxxx<br><br># git 已经帮我们找到了，第一次出现 bug 的 commit id，此时需要手动结束 bisect 过程<br>git bisect reset<br></code></pre></td></tr></table></figure><p>执行 <code>git bisect reset</code> 后，bisect 过程即结束。</p><p><strong>使用脚本</strong></p><p>bisect 支持使用脚本，使用脚本的目的是帮 git 来判断 bug。git 执行脚本，根据脚本的执行结果，自动帮我们标记 good 或 bad。</p><p>上面的例子，可以根据输出结果包含 <code>bug</code>字样来判断 bug，对应的 shell 脚本命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>javac Product.java<br>OUTPUT=$(java Product)<br><br>if [[ $OUTPUT == *&quot;bug&quot;* ]]; then<br>  exit 1<br>else<br>  exit 0<br>fi<br></code></pre></td></tr></table></figure><p>这个脚本执行 <code>java Product</code>，判断输出结果是否包含 <code>bug</code> 字样，包含则 exit code 为 1，反之为 0；</p><p>有了这个判断脚本之后，上面的查找流程可以大大简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"># 标记开始<br>git bisect start<br><br># 把 v9<span class="hljs-number">.0</span> 标记为 bad，把 v1<span class="hljs-number">.0</span> 标记为 good<br>git checkout v9<span class="hljs-number">.0</span><br>git bisect bad<br>git checkout v1<span class="hljs-number">.0</span><br>git bisect <span class="hljs-title function_">good</span> <span class="hljs-params">(in v1<span class="hljs-number">.0</span>)</span><br>    <br># 执行脚本自动化查找过程<br>git bisect run &lt;脚本名称&gt;<br>    <br># 脚本执行完之后，手动关闭 bisect<br>git bisect reset<br></code></pre></td></tr></table></figure><p>至此，bisect 查找过程结束。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>git bisect</code> 在业务开发方面使用的比较少，但是在开源项目中，使用相对比较频繁。</p><p>对于开源项目，可以使用 <code>git bisect</code> 帮助开发者定位 bug，贡献 issues。</p><p>对于棘手的 bug 定位，<code>git bisect</code> 为我们提供了另外一种解决思路。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操蛋的 Git</title>
    <link href="/2022/10/16/%E6%93%8D%E8%9B%8B%E7%9A%84%20Git/"/>
    <url>/2022/10/16/%E6%93%8D%E8%9B%8B%E7%9A%84%20Git/</url>
    
    <content type="html"><![CDATA[<p>Git 中的一些抓狂经历，平时遇不到，一遇到就很操蛋。</p><blockquote><p>部分参考：<a href="https://ohshitgit.com/zh">Oh Shit, Git</a>  <a href="https://github.com/k88hudson/git-flight-rules">git-flight-rules</a></p></blockquote><p><a name="ICrHo"></a></p><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><h3 id="本地分支太多了，老子要删掉。"><a href="#本地分支太多了，老子要删掉。" class="headerlink" title="本地分支太多了，老子要删掉。"></a>本地分支太多了，老子要删掉。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 看一眼本地有哪些分支<br>git branch <br><br># 删掉本地对应分支<br>git branch -d &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="远程分支有点多余，老子要删掉。"><a href="#远程分支有点多余，老子要删掉。" class="headerlink" title="远程分支有点多余，老子要删掉。"></a>远程分支有点多余，老子要删掉。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 看一眼远程有哪些分支<br>git branch -r<br><br># 删掉远程对应分支<br>git push origin --delete &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="要从远程分支-checkout-一个新分支"><a href="#要从远程分支-checkout-一个新分支" class="headerlink" title="要从远程分支 checkout 一个新分支"></a>要从远程分支 checkout 一个新分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"># 常规写法<br>git checkout -b &lt;本地分支名&gt; &lt;远程分支名&gt;<br><br>或<br><br># 简写<br>git checkout --track &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="老子忘记当前分支是基于哪个分支创建的了"><a href="#老子忘记当前分支是基于哪个分支创建的了" class="headerlink" title="老子忘记当前分支是基于哪个分支创建的了"></a>老子忘记当前分支是基于哪个分支创建的了</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reflog show &lt;分支名&gt;<br></code></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><h3 id="老子提交信息打错了，要把提交信息改一下"><a href="#老子提交信息打错了，要把提交信息改一下" class="headerlink" title="老子提交信息打错了，要把提交信息改一下"></a>老子提交信息打错了，要把提交信息改一下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># 输入命令根据提示修改提交信息<br>git commit --amend<br></code></pre></td></tr></table></figure><h3 id="老子提交之后（还未-push），发现还有东西忘记提交了"><a href="#老子提交之后（还未-push），发现还有东西忘记提交了" class="headerlink" title="老子提交之后（还未 push），发现还有东西忘记提交了"></a>老子提交之后（还未 push），发现还有东西忘记提交了</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 正常 add<br>git add &lt;忘记提交的文件路径&gt;<br><br># 把这次提交合并到最新的一次提交中<br>git commit --amend --no-edit<br></code></pre></td></tr></table></figure><h3 id="靠，点错了。这个文件不应该提交，撤回这次提交（未-push）"><a href="#靠，点错了。这个文件不应该提交，撤回这次提交（未-push）" class="headerlink" title="靠，点错了。这个文件不应该提交，撤回这次提交（未 push）"></a>靠，点错了。这个文件不应该提交，撤回这次提交（未 push）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"># 本质上是让 head 指针指向上一次提交<br>git reset --soft HEAD@&#123;1&#125;<br><br>或<br><br># 让 head 指针指向上一次的 commit <br>git reset --soft &lt;commit id&gt;<br></code></pre></td></tr></table></figure><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><h3 id="我要让当前分支恢复成最初的样子"><a href="#我要让当前分支恢复成最初的样子" class="headerlink" title="我要让当前分支恢复成最初的样子"></a>我要让当前分支恢复成最初的样子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 重置当前分支到的最近的一次提交<br>git reset HEAD --hard<br><br># 重置当前分支到的远程分支的最新一次提交<br>git reset &lt;远程分支名&gt; --hard<br></code></pre></td></tr></table></figure><h3 id="我要把文件移出暂存区"><a href="#我要把文件移出暂存区" class="headerlink" title="我要把文件移出暂存区"></a>我要把文件移出暂存区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset head --mixed <br><br>或<br><br>git reset head<br></code></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><h3 id="靠，merge-错分支了，我要恢复-merge-前的状态"><a href="#靠，merge-错分支了，我要恢复-merge-前的状态" class="headerlink" title="靠，merge 错分支了，我要恢复 merge 前的状态"></a>靠，merge 错分支了，我要恢复 merge 前的状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># ORIG_HEAD 变量保存了 merge 前的 HEAD 变量<br>git reset --hard ORIG_HEAD<br></code></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><blockquote><ul><li><strong>摘樱桃，把一次或多次 commit 应用到当前分支</strong></li></ul></blockquote><h3 id="oh-shit-最新的提交解决了一个历史-bug，其他分支代码也要修改这个-bug。"><a href="#oh-shit-最新的提交解决了一个历史-bug，其他分支代码也要修改这个-bug。" class="headerlink" title="oh shit! 最新的提交解决了一个历史 bug，其他分支代码也要修改这个 bug。"></a>oh shit! 最新的提交解决了一个历史 bug，其他分支代码也要修改这个 bug。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs git"># 应用场景：假设已修复 bug 的分支是 bug-fix，需要修改 bug 的分支是 release-1.0<br><br># 1.切换到需要修改 bug 的分支<br>git checkout release-1.0<br><br># 2.使用 cherry-pick<br>git cherry-pick &lt;bug 修复的 commit id&gt;<br><br>或<br><br>git cherry-pick bug-fix<br></code></pre></td></tr></table></figure><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><blockquote><ul><li><strong>用于撤销历史的某次更改，例如：bug 或者功能</strong></li><li><strong>回滚某次发布</strong></li></ul></blockquote><h3 id="产品加了个没卵用的功能，现在要上线，这个功能还要不要？"><a href="#产品加了个没卵用的功能，现在要上线，这个功能还要不要？" class="headerlink" title="产品加了个没卵用的功能，现在要上线，这个功能还要不要？"></a>产品加了个没卵用的功能，现在要上线，这个功能还要不要？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 不上线该功能：把该功能对应的 commit id 并 revert,之后会产生一个新 revert 提交。<br>git revert &lt;commit id&gt;<br><br># 最终还是决定要上: 只需对 revert 提交进行 revert<br>git revert &lt;revert 提交的 commit id&gt;<br></code></pre></td></tr></table></figure><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><h3 id="我要把改动文件暂存起来，不想提交这些文件"><a href="#我要把改动文件暂存起来，不想提交这些文件" class="headerlink" title="我要把改动文件暂存起来，不想提交这些文件"></a>我要把改动文件暂存起来，不想提交这些文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"># 给改动存储<br>git stash<br><br>或<br><br># 给改动取名并存储<br>git stash save &lt;自定义名称&gt;<br></code></pre></td></tr></table></figure><h3 id="忘记了-stash-中存储了哪些改动"><a href="#忘记了-stash-中存储了哪些改动" class="headerlink" title="忘记了 stash 中存储了哪些改动"></a>忘记了 stash 中存储了哪些改动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># 列举所有的 stash 信息<br>git stash list<br></code></pre></td></tr></table></figure><h3 id="我要取出改动，应用到-feature-分支"><a href="#我要取出改动，应用到-feature-分支" class="headerlink" title="我要取出改动，应用到 feature 分支"></a>我要取出改动，应用到 feature 分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs git"># 切换到 feature 分支，把改动取出应用到 feature 分支并自动删除 stash<br># 命令末尾加 &lt;stash id&gt; 应用指定的 stash <br>git stash pop<br><br>或<br><br># 把改动取出应用到 feature 分支,stash 不会删除<br># 命令末尾加 &lt;stash id&gt; 应用指定的 stash <br>git stash apply<br></code></pre></td></tr></table></figure><h3 id="老子要手动删除-stash-信息"><a href="#老子要手动删除-stash-信息" class="headerlink" title="老子要手动删除 stash 信息"></a>老子要手动删除 stash 信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 删除全部的 stash 信息<br>git stash clear<br><br># 删除指定的 stash 信息<br>git stash drop &lt;stash id&gt;<br></code></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="我去，tag-怎么用啊，老板跟我说打个-tag。"><a href="#我去，tag-怎么用啊，老板跟我说打个-tag。" class="headerlink" title="我去，tag 怎么用啊，老板跟我说打个 tag。"></a>我去，tag 怎么用啊，老板跟我说打个 tag。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git"># 创建 tag<br>git tag &lt;标签名&gt;<br><br># 将创建的 tag 推到远程仓库<br>git push origin &lt;标签名&gt;<br><br></code></pre></td></tr></table></figure><h3 id="丢，手抖打错了-tag-名称，怎么删了这个-tag-啊。"><a href="#丢，手抖打错了-tag-名称，怎么删了这个-tag-啊。" class="headerlink" title="丢，手抖打错了 tag 名称，怎么删了这个 tag 啊。"></a>丢，手抖打错了 tag 名称，怎么删了这个 tag 啊。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 删除本地 tag<br>git tag -d &lt;标签名&gt;<br><br># 删除远程仓库中的 tag<br>git push --delete origin &lt;标签名&gt;<br></code></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h3 id="嗨，忘记上次提交改了哪些文件"><a href="#嗨，忘记上次提交改了哪些文件" class="headerlink" title="嗨，忘记上次提交改了哪些文件"></a>嗨，忘记上次提交改了哪些文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git"># 查看每次提交文件<br>git log --name-only <br><br>或<br><br># 查看每次提交的文件，以及对文件进行的操作<br>git log --name-status<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 与事务</title>
    <link href="/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事务是让人生厌的八股，也是面试中的常客。网路上关于 Spring 与事务的问题非常多，然而大部分解答都是在「 背答案」，并没有把它的底层逻辑讲清楚，只要问题一经变通，也就无从下手不知所措。</p><p>Spring 使用魔法般的注解 <code>@Transactional</code> 帮我们解决事务的使用问题，给我们带来便利的同时，也屏蔽了底层的细节。屏蔽了底层的细节，也就导致事务相关的使用都是靠着积累的经验，而无法真正理解它。</p><p><strong>说明：</strong>本文仅对 Spring 中事务的原理进行说明，MySQL 中的事务实现不在本文阐述。</p><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>事务这个概念有点抽象，可以把它看做由一堆 SQL 语句组成的操作。</p><p>事务可以保证它里面的 SQL 语句要么全部成功，要么全部失败，不存在第三种中间状态。</p><p>事务还有 ACID 四种特性，陈词滥调这里不想过多阐述，可以自行 Google 了解。</p><h2 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h2><p>首先要说明的是，「 事务」更像是一种约定，数据库可以选择遵守或不遵守该约定。即便是在支持事务的数据库中，它们实现事务的方式也各不相同，MySQL 提供对事务的支持，接下来看看在 MySQL 中要如何使用事务。</p><p>在使用事务之前，需要了解事务相关的一些概念。</p><ul><li>事务（transaction）指一组 SQL 语句，对应的是整个转账流程。</li><li>回滚（rollback）指撤销指定的 SQL 语句</li><li>提交（commit）将未存储的 SQL 语句结果写入到数据库</li><li>保留点（savepoint）指事务处理中设置的临时占位符，用于事务回滚到指定的 SQL 语句。</li></ul><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>假设这样一个场景：用户注册一个账号，默认金额是 0 元，之后充值了 100 元，两个操作都在一个事务内。对应的 SQL 语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL 中标识事务开始</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>上诉操作完成了一个事务的提交，倘若要回滚上诉操作只需要将 <code>COMMIT</code> 替换成 <code>ROLLBACK</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>不知道你发现了没有，提交和回滚都是针对一组 SQL 进行的。用户注册账号成功，但是充值失败，能否让「 充值失败」不影响到用户注册。</p><p>答案是肯定的，上面提到的 <code>SAVEPOINT</code> 就是解决该问题的。</p><p><code>SAVEPOINT</code> 就像游戏存档一样，可以在事务的执行过程中建立多个存档，遇到异常可以随时返回到指定的存档。如下面的语句，「 注册」会成功，而「充值」失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">-- 创建名为 `register_user` 的保留点</span><br><span class="hljs-keyword">SAVEPOINT</span> register_user;<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 回滚到 `register_user` 保留点</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> register_user;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h2 id="传统的-JDBC-管理事务"><a href="#传统的-JDBC-管理事务" class="headerlink" title="传统的 JDBC 管理事务"></a>传统的 JDBC 管理事务</h2><h3 id="提交与回滚操作"><a href="#提交与回滚操作" class="headerlink" title="提交与回滚操作"></a>提交与回滚操作</h3><p>看下这段代码，你是否熟悉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection(); <span class="hljs-comment">// (1)</span><br><br><span class="hljs-keyword">try</span> (connection) &#123;<br>    connection.setAutoCommit(<span class="hljs-literal">false</span>); <span class="hljs-comment">// (2)</span><br>    <span class="hljs-comment">// 执行一些 SQL 代码</span><br>    connection.commit(); <span class="hljs-comment">// (3)</span><br><br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    connection.rollback(); <span class="hljs-comment">// (4)</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取数据库连接，获取的方式有多种，现在大多数都是维护一个数据库连接池，然后从连接池分配一个连接。</li><li>把获取到的数据库连接，关闭自动提交。因为事务要交由代码管理，而不是让数据库默认提交。</li><li>当执行完 SQL 代码之后，开始提交。</li><li>数据库进行 COMMIT 提交出现异常，代码中进行捕获，并执行回滚操作。</li></ol><h3 id="设置隔离级别与保留点（SAVEPOINT）"><a href="#设置隔离级别与保留点（SAVEPOINT）" class="headerlink" title="设置隔离级别与保留点（SAVEPOINT）"></a>设置隔离级别与保留点（SAVEPOINT）</h3><p>在  jdbc 中设置数据库隔离级别和 <code>SAVEPOINT</code> 也是非常简单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">Savepoint</span> <span class="hljs-keyword">savePoint</span> <span class="hljs-operator">=</span> connection.setSavepoint(); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">2</span>)<br><br>connection.rollback(<span class="hljs-keyword">savePoint</span>);  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><ol><li><code>setTransactionIsolation</code> api 就可以设置数据库的隔离级别</li><li><code>setSavepoint</code> 创建一个 <code>SAVEPOINT</code></li><li><code>rollback</code> 到上一个 <code>SAVEPOINT</code></li></ol><p>可以看到 jdbc 中对数据库事务的操作都是非常简单的，Spring 与 jdbc 实现事务的操作并无太大差别，只是他把这些封装的太好，会让你觉得是魔法，难以理解。</p><h2 id="Spring-的事务魔法"><a href="#Spring-的事务魔法" class="headerlink" title="Spring 的事务魔法"></a>Spring 的事务魔法</h2><h3 id="Transactional-注解"><a href="#Transactional-注解" class="headerlink" title="Transactional 注解"></a>Transactional 注解</h3><p>使用 JDBC 开启事务，需要写大量的 <code>try...catch</code> 。通常 <code>try</code> 代码块执行 SQL 操作，<code>catch</code> 中捕获异常进行回滚。</p><p>来看下 Spring 中为一个方法添加事务有多简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        userDao.save(user);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>加上 <code>@Transactional</code> 注解等价代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            userDao.save(user);<br><br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个操作，相比上面的 JDBC 操作，简便不少。操控事务的样板代码，不用在每个方法中写了，一个注解 Spring 统统搞定。</p><p>因此，Spring 的事务魔法秘密就揭开了。对加了 <code>@Transactional</code>的方法或者类，使用 AOP 的方式，帮你生成数据库的链接，事务开启、提交、回滚代码，仅此而已。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在深入 <code>@Transcational</code> 注解之前，还是要先简单介绍下 AOP 在事务上的实现，这对你理解后面的问题，大有裨益。</p><p>首先要清楚 AOP 在实现事务时，并不会改变原来类的行为，它只是生成了一个代理类。生成代理类的方式有 CGLIB、JDK 动态代理，两种代理方式各不相同，但这里不对代理方式阐述。</p><p>通过一个简单的 Demo 看下这个流程：</p><p>在 <code>UserService</code> 的 <code>registerUser</code> 方法开启事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 注册用户代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 使用 AOP 为 <code>UserService</code> 生成代理类 <code>UserServiceProxy</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 调用 UserService 的 registerUser 方法</span><br>            invoke();<br>           <br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>UserController</code> 中注入 <code>UserService</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/register&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span>&#123;<br>userService.registerUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>/register</code> 请求的流程如下：</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/01acb810-c014-487d-9a72-7a6111fd0920.png" alt="aop.png"></p><p>可以看到，<code>Controller</code>  实际上是调用 <code>UserServiceProxy</code> 的 <code>registerUser</code> 方法，然后在代理方法中操控事务，并调用真正的 <code>UserService</code> 的 <code>registerUser</code>。</p><p>或许你还有个疑问：注入的是 <code>UserService</code> ，为什么调用的却是它的代理类？</p><p>这就涉及 Spring  的依赖注入原理，详细可以自行搜索。实际上在 <code>UserController</code> 中注入的是 <code>UserServiceProxy</code> ，而非看到的 <code>UserService</code>。</p><h3 id="一些疑难杂症"><a href="#一些疑难杂症" class="headerlink" title="一些疑难杂症"></a>一些疑难杂症</h3><p>列举一些关于 Spring 事务的疑难杂症，也是面试的常考题。</p><h4 id="为什么-private-方法加-Transactional-注解不生效"><a href="#为什么-private-方法加-Transactional-注解不生效" class="headerlink" title="为什么 private 方法加 @Transactional 注解不生效?"></a>为什么 <code>private</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>这个问题其实是和 AOP 相关的，因为 AOP 无法对 <code>private</code> 方法生成代理。无法代理也就意味着对 <code>priavte</code> 方法的调用，都是直接调用被代理的类。</p><h4 id="为什么-final-方法加-Transactional-注解不生效"><a href="#为什么-final-方法加-Transactional-注解不生效" class="headerlink" title="为什么 final 方法加 @Transactional 注解不生效?"></a>为什么 <code>final</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>原理同上，还是 AOP 无法代理被 <code>final</code> 关键字修饰的方法和类</p><h4 id="为什么类方法相互调用事务不生效？"><a href="#为什么类方法相互调用事务不生效？" class="headerlink" title="为什么类方法相互调用事务不生效？"></a>为什么类方法相互调用事务不生效？</h4><p>事务方法 <code>a</code>调用同类的事务方法 <code>b</code> ，在外部调用 <code>a</code> 方法，<code>b</code> 方法的事务不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个只需要分析下调用过程就清楚了：</p><ol><li>先调用代理类中的 <code>a</code> 方法，然后代理类中调用真正的 <code>a</code> 方法。</li><li><code>UserService</code> 的 <code>a</code> 方法执行过程中，发现要调用 <code>b</code> 方法，因此调用了自己的 <code>b</code> 方法。</li></ol><p>可以看到，<code>a</code> 调用 <code>b</code> 的时候，并没有先经过代理类，而是直接在 <code>UserService</code> 中执行了，所以 <code>b</code> 的事务不会生效。</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/9559d6ef-b67e-49b3-b2a3-6ed40d97aa6d.png" alt="question_1.png"></p><h4 id="为什么注入自己就能解决相互调用问题？"><a href="#为什么注入自己就能解决相互调用问题？" class="headerlink" title="为什么注入自己就能解决相互调用问题？"></a>为什么注入自己就能解决相互调用问题？</h4><p>同样是上面的代码，只需要在 <code>UserService</code> 中注入自己，<code>b</code> 的事务就生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Autowird</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        userService.b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面说的依赖注入吗，这里注入自己，实际上注入的是 <code>UserService</code> 的代理类。因此在执行 <code>userService.b()</code> 这段代码时，会调用代理类的 <code>b</code> 方法，所以 <code>b</code> 的事务生效。</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/4f01d7cf-3c53-4e24-ae76-69b835d7d61b.png" alt="question_2.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的 GC</title>
    <link href="/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/"/>
    <url>/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/</url>
    
    <content type="html"><![CDATA[<p>人在日常活动中不可避免会产生垃圾，程序也是如此。在方法中 new 一个对象，每次调用该方法都会进行 new 对象操作，如果没有人去管理这些对象，没有把这些对象占有内存及时释放掉，内存很快就会满。因此，在程序运行过程中，需要及时寻找和处理「 死去」的对象。这个「 死去」的对象就是<strong>垃圾</strong>，而寻找和处理垃圾的过程就叫做 <strong>GC</strong>。</p><p>GC 全称 “Garbage Collection” 即垃圾收集。不同的语言对于 GC 的处理都是不一样的，因此也产生了不同的「流派」。</p><p><strong>需要说明的是</strong>：本文介绍的 GC 都是基于 HotSpot。</p><h2 id="垃圾管理流派"><a href="#垃圾管理流派" class="headerlink" title="垃圾管理流派"></a>垃圾管理流派</h2><p>根据内存的管理方式，划分出两个流派：手动管理和自动管理。</p><p>手动管理的代表就是：C ++ 和 C。它们需要在编码过程中，手动去释放内存。</p><ul><li>优点：能明确垃圾的产生，以及提高回收的效率。 </li><li>缺点：垃圾太多，在代码中手动清理内存很「痛苦」，很容易忘记释放内存，导致内存泄露。由于需要明确垃圾的产生位置，因此也需要对该语言非常熟悉，这也无形中加大了语言的上手难度。</li></ul><p>自动管理的代表：Java (当然还有很多其他语言，篇幅有限，暂不阐述)。</p><ul><li>优点：使用者无需关心内存的使用，只需专注功能和业务的实现。内存的处理和回收有个智能的程序替我们完成。</li><li>缺点：屏蔽了底层细节，出现了内存问题，使用者无法着手解决。当然解决办法也很简单，就是去了解 GC 原理。</li></ul><h2 id="寻找垃圾"><a href="#寻找垃圾" class="headerlink" title="寻找垃圾"></a>寻找垃圾</h2><p>现在我们知道 Java 是自动 GC，那现在问题来了：它是怎么去找到垃圾？怎么保证找的对象就一定是垃圾呢？</p><p>在「 找垃圾」这块，也有两种方式：引用计数和可达性分析。虽然有两种方式，但主流的 Java 虚拟机里面都没有选用引用计数。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>如图所示，小圆圈代表对象，箭头代表引用关系，数字代表对象被引用的次数。可以看到蓝色的对象都是处于「 活跃」状态的，而灰色的对象要么没有被引用，要么引用它的对象没有被引用，这些对象就是程序需要回收的垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/2069ac04-c401-4330-bb40-6fda0dea5fcb.png" alt="GC-in-Java-01.PNG"></p><p>这一切看似完美无缺，实则存在一个巨大问题：对象间的循环引用。</p><p>仔细看上面这张图，红色的对象相互循环引用，程序并没有使用到，理应当作垃圾处理。但是，在引用计数方法看来这是个「 活跃」的对象，因此并不会进行处理。</p><p>在一些文章上有谈论到解决该问题的方法，例如：循环引用的对象使用 <code>弱引用</code>，使用单独的算法等，详情可以自行搜索。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>Java 就是通过<code>可达性分析</code>算法来进行内存管理的。</p><p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，即通过 GC Roots 访问不到该对象时，则证明此对象是垃圾。</p><p>用比较生活化的例子来解释：家是内存，家庭成员是 GC Roots，物品是对象，家庭大扫除就是可达性分析。家庭大扫除的结果就是把家庭成员都用不到的东西归为垃圾，并把它清除掉。</p><p>如图所示：灰色的对象就是 GC Roots 访问不到的对象，这些对象就是垃圾。图中也可以看到对象循环引用的问题的，在这里也已经不复存在，都会被当做垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/09db1a69-e11e-4a4b-9bdd-43946cb355a5.png" alt="GC-in-Java-02.PNG"></p><p>大扫除的例子，我们知道「 家庭成员」是 GC Roots，在 Java 技术体系中常见的 GC Roots 包括以下几种：</p><ul><li>线程</li><li>native 方法</li><li>栈帧中的局部变量表</li><li>Class 引用的 static field</li><li>所有被同步锁（synchronized关键字）持有的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过上面两种方法来看，似乎对象在内存中的状态只有「 被引用」和「 未被引用」两种状态，GC 把「 未被引用」 的对象收集。</p><p>在在内存空间充足时，可能并不希望「 未被引用」的对象被清除，只有当内存紧张时，才把那些对象抛弃。</p><p>在 Java 中对引用的概念进行扩充，将引用分为：</p><ul><li>强引用（Strongly Re-ference） <ul><li>在 Java 程序代码中普遍存在的就是<code>强引用</code>，比如你 new 一个对象。</li></ul></li><li>软引用（Soft Reference） <ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li></ul></li><li>弱引用（Weak Reference） <ul><li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li></ul></li><li>虚引用（Phantom Reference） <ul><li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。类似于 Linux 中的 <a href="https://zh.wikipedia.org/wiki/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">退出状态</a>。</li></ul></li></ul><p>这4种引用强度依次逐渐减弱。</p><h2 id="垃圾自我救赎"><a href="#垃圾自我救赎" class="headerlink" title="垃圾自我救赎"></a>垃圾自我救赎</h2><p>使用可达性分析找到「未被引用」的对象并不会立即将内存释放，而是给这些对象进行<code>标记</code> ，当对象被<strong>标记两次</strong>后才会进行回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/8939c679-8d1a-4d66-8bd4-910e8e25d6bd.png" alt="image.png"></p><p>当对象第一次标记之后，随后会进行一次筛选，筛选的依据是：<strong>对象是否有必要执行 finalize() 方法？</strong></p><p>假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>「没有必要执行」</strong>。</p><p>对象被判定为「没有必要执行」，则直接进行回收。否则，会把对象放入到一个名为 <code>F-Queue</code> 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。流程如下：</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/f74a1943-9e8f-440b-b097-b3eb7995cd64.png" alt="image.png"></p><p>对象的 finalize() 方法执行，GC 对 <code>F-Queue</code> 中的对象进行第二次标记。如果 finalize() 方法执行之后，对象重新回到了 GC Roots 的引用链上，则把它移出队列。否则，被 GC 回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/41e3ebdc-ac30-40a3-9783-9bdd08b958f7.png" alt="image.png"></p><p>这个时候你可能就有问题了：那我在对象的 finalize() 方法中，编写代码使得当前对象重新回到 GC Roots 引用链上，这个对象岂不是永远不会被 GC 回收？</p><p>答案是会被回收。可以看到「没有必要执行」的条件中有一条是： <strong>finalize() 方法已经被虚拟机调用过</strong>。因此对象虽然能回到引用链上，但是下一次 GC 它一定会被回收。<strong>总结就是：一个对象只能被救赎一次。</strong></p><p>其实关于  finalize() 方法，很多人也不了解，只需要知道它会于 GC 过程产生联系即可。在 《Effective Java》第三版 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md">Item 8</a> ，以及《深入理解 Java 虚拟机》第三版中，作者都不建议在代码中使用 finalize，甚至让我们忘记这个 API。</p><p>因此，使用  finalize() 方法的最佳实践就是：从不使用它。</p><blockquote><p>文章参考《深入理解 Java 虚拟机》第三版、《Effective Java》第三版、《Plumbr Handbook Java Garbage Collcetion》。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例实现的几种方式</title>
    <link href="/2022/06/24/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/06/24/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是单例"><a href="#什么是单例" class="headerlink" title="什么是单例"></a>什么是单例</h2><p>单例是一个只实例化一次的类，即类仅存在一个对象。</p><h2 id="私有化构造器-静态成员变量"><a href="#私有化构造器-静态成员变量" class="headerlink" title="私有化构造器 + 静态成员变量"></a>私有化构造器 + 静态成员变量</h2><p>显示声明构造器，并使用 <code>private</code> 关键字将其私有化，避免使用 <code>new Object</code> 来创建对象。需要使用该实例，只需要通过成员变量 INSTANCE 访问即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：会被 AccessibleObject.setAccessible 方法利用反射调用私有构造函数，实例化新的对象。</p><h2 id="私有化构造器-静态工厂方法"><a href="#私有化构造器-静态工厂方法" class="headerlink" title="私有化构造器 + 静态工厂方法"></a>私有化构造器 + 静态工厂方法</h2><p>该单例实现方法与上面基本一致，只需要将成员变量私有化，添加工厂方法来访问该成员变量即可。获取实例只需要调用 <code>getInstance</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：同上。</p><p><strong>实现序列化需要注意的问题</strong></p><p>使用上述两种方法实现单例，且需要实现可序列化时，仅仅是实现 Serializable 接口是不够的，要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md">Item-89</a>）。</p><p>否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 MySingleton。为了防止这种情况发生，将这个 readResolve 方法添加到 MySingleton 类中。</p><p>详细的解决方法可以查看《Effective Java》第三版 Item 89。</p><h2 id="单元素枚举"><a href="#单元素枚举" class="headerlink" title="单元素枚举"></a>单元素枚举</h2><p>优点：默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MySingleton</span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：当类需要扩展超类时，enum 便不在适合。</p><h2 id="延迟加载单例（双重检查不成立？）"><a href="#延迟加载单例（双重检查不成立？）" class="headerlink" title="延迟加载单例（双重检查不成立？）"></a>延迟加载单例（双重检查不成立？）</h2><p>延迟加载即只有第一次调用时，才进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当程序第一次调用 <code>getInstance</code> 方法时，MySingleton 实例才被初始化。</p><p>该延迟加载在多线程情况下，可能会创建多个实例，因此需要对 <code>getInstance</code> 方法进行加锁处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>          INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> INSTANCE;<br>  &#125;<br></code></pre></td></tr></table></figure><p>加锁的意图在于第一次初始化的时候，保证只有一条线程进入到 if 语句中，生成实例。直接在方法上加锁，会导致性能下降。因为每次去取该实例都要去获得锁，所以需要对该方式进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">synchronized</span> (MySingleton.class)&#123;<br>               <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                   INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> INSTANCE;<br>   &#125;<br></code></pre></td></tr></table></figure><p>该方法称作 <code>双重检查</code> ，保证了多线程环境下，只生成一个实例，且后续对该实例的调用都不会进行加锁处理。</p><p><strong>由于类加载以及对象初始化的特殊性值，会导致该双重检查不成立，可以使用 volatile 关键字声明变量，防止指令重排，实现最终目的。想了解该问题具体产生的原因，可以</strong><a href="writing"><strong>查看</strong></a><strong>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (MySingleton.class)&#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一份来自 Java 巨佬关于 <code>双重检查</code>的阐述，点击<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">这里</a> 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>单例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins 自动化部署</title>
    <link href="/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>简介：Java 编写的最广泛使用的开源持续集成工具，非常易用，广泛的第三方插件支持，以及分布式构建。</p><p>文章所演示的项目地址：</p><p>GitHub: <a href="https://github.com/greek-zzf/oh-my-jenkins.git">https://github.com/greek-zzf/oh-my-jenkins.git</a><br>Gitee: <a href="https://gitee.com/geek-zzf/oh-my-jenkins.git">https://gitee.com/geek-zzf/oh-my-jenkins.git</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="War-包方式"><a href="#War-包方式" class="headerlink" title="War 包方式"></a>War 包方式</h3><p>优点：安装启动非常方便。</p><p>缺点：与环境强绑定，服务器要为 Jenkins 提供部署项目所需要的环境，例如：Node、Java 等。 部署成服务需要使用对应平台的命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到安装方式，下载 War 包。或者直接点击<a href="https://www.jenkins.io/download/">这里</a>下载。 </p></li><li><p>下载完成运行命令 <code>java -jar jenkins.war</code> ，等待几分钟。 </p></li><li><p>在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>优点：与宿主机环境隔离，不依赖宿主机环境。注册成服务非常方便，只需要启动时设置好参数 <code>--restart=always</code> 即可。</p><p>缺点：启动稍微复杂，需要配置好启动命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到 Docker 安装方式。或者直接点击<a href="https://www.jenkins.io/doc/book/installing/docker/">这里</a>访问。 </p></li><li><p>运行 Docker 命令如下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">step1: docker network create jenkins<br><br>step2: docker run --name jenkins-docker --rm --detach \<br>  --privileged --network jenkins --network-alias docker \<br>  --env DOCKER_TLS_CERTDIR=/certs \<br>  --volume jenkins-docker-certs:/certs/client \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --publish 2376:2376 \ <br>  docker:dind --storage-driver overlay2   --insecure-registry 47.107.74.10:5000 <br> <br><br>step3: 创建 Dockerfile 文件，并把如下内容复制进去<br><br>    FROM jenkins/jenkins:2.332.2-jdk11<br>    USER root<br>    RUN apt-get update &amp;&amp; apt-get install -y lsb-release<br>    RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \<br>      https://download.docker.com/linux/debian/gpg<br>    RUN echo &quot;deb [arch=$(dpkg --print-architecture) \<br>      signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \<br>      https://download.docker.com/linux/debian \<br>      $(lsb_release -cs) stable&quot; &gt; /etc/apt/sources.list.d/docker.list<br>    RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli<br>    USER jenkins<br>    RUN jenkins-plugin-cli --plugins &quot;blueocean:1.25.3 docker-workflow:1.28&quot;<br><br>step4: docker build -t myjenkins-blueocean:2.332.2-1 .<br><br>step5: docker run --name jenkins-blueocean --rm --detach \<br>  --network jenkins --env DOCKER_HOST=tcp://docker:2376 \<br>  --env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \<br>  --publish 8080:8080 --publish 50000:50000 \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --volume jenkins-docker-certs:/certs/client:ro \<br>  myjenkins-blueocean:2.332.2-1<br></code></pre></td></tr></table></figure></li><li><p>等待一会，在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><p><strong>注意</strong>：步骤4构建失败，可能是由于 Docker 权限问题，解决方案可参考<a href="https://github.com/docker/buildx/issues/476">这里</a>。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>解锁 Jenkins：浏览器中提示输入管理员密码。War 在启动的控制台中会打印密码，或者页面提示的文件中。Docker 方式使用命令，查看容器日志信息即可看到 <code>docker logs jenkins-blueocean</code>。 </p></li><li><p>插件下载镜像设置：为了部署和运行项目，需要安装一些插件。首先需要给插件站点设置一个镜像，不然访问速度感人。配置路径 “Manager Jenkins -&gt; Manager Plugins -&gt; Advanced”，在底部的 <code>Update Site</code> 中把地址进行替换。这里提供一个国内可访问的镜像地址：<a href="https://updates.jenkins-zh.cn/update-center.json%E3%80%82">https://updates.jenkins-zh.cn/update-center.json。</a></p></li><li><p>设置好插件镜像源之后，去搜索对应的插件，下载安装即可。 </p></li><li><p>下载并安装插件：由于项目是用 Git 来管理的，并且使用的是 Maven，因此需要下载这两个插件。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建 Job 之前，需要先了解一个 Job 任务涉及到哪些流程。Jenkins 给我们提供了以下几个模块：</p><ul><li><p><code>General</code> Job 描述，可选。 </p></li><li><p><code>Source Code Management</code> 源代码管理，有多个版本工具选择：Git、Svn 等。 </p></li><li><p><code>Build Triggers</code> 构建触发器，选择构建代码的时机 </p><ul><li>Trigger builds remotely，手动去触发。</li><li>Build after other project are built，在其他项目构建完成后触发。</li><li>Build periodically，周期的进行构建</li><li>GitHub Hooks，当有代码更新到 GitHub，GitHub 会触发一个 Hooks，并通知 Jenkins 服务开始构建，这个需要在 GitHub 中配置推送地址信息。</li><li>Poll SCM 定时任务轮询，填写 Cron 表达式指定轮询的时机。例如：每 10 分钟去检查 GitHub 仓库是否有代码更新。</li></ul></li><li><p><code>Build Environment</code>构建环境，配置项目构建的环境，可以在构建的时候传递环境变量信息。 </p></li><li><p><code>Build</code> 可以选择构建所需步骤。 </p></li><li><p><code>Post-build Actions</code>可以指定项目完成构建之后的行为。</p></li></ul><h2 id="手动创建-Job"><a href="#手动创建-Job" class="headerlink" title="手动创建 Job"></a>手动创建 Job</h2><p>在 Jenkins 中添加两个任务，一个用于拉取代码运行测试、打包任务，另一个可以手动选择版本的部署任务。</p><h3 id="创建测试打包任务"><a href="#创建测试打包任务" class="headerlink" title="创建测试打包任务"></a>创建测试打包任务</h3><ol><li>填写创建的 Job 信息</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/24e982a6-9b83-4233-99f0-15c083663bb5.png" alt="image.png"></p><ol start="2"><li>选择 Git 作为代码管理工具，配置对应的仓库地址。如果是私密仓库，需要填写对应的账号密码。这里使用了 ssh 方式，并提前配置好了私钥信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/0c9f33b3-b50e-45dd-b984-8fdd5c4a1ea9.png" alt="image.png"></p><ol start="3"><li>选择一个构建方式，这里我们选择 SCM，填写一个每 10 分钟轮询一次的 corn 表达式。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/415593ca-72bb-4786-a3c5-14271c5d15ac.png" alt="image.png"></p><ol start="4"><li>构建的时候选择 <code>Execute shell</code> 并在文本框中填写要执行的脚本信息，这里我们填写 <code>mvn clean package</code>，该命令会执行清理、测试、打包操作，在 target 目录下生成 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3fea80cf-d62d-4d27-a028-4bae6b70c59a.png" alt="image.png"></p><ol start="5"><li>保存任务，回到页面。等待 10 分钟或者手动点击立即构建，即可开始构建。 控制台最终打印了文件夹下所有项目版本信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b452178d-9bdd-4873-98f7-663fd62ef8bf.png" alt="image.png"></p><h3 id="创建部署任务"><a href="#创建部署任务" class="headerlink" title="创建部署任务"></a>创建部署任务</h3><ol><li>创建 deploy 任务，在页面中填写描述，并勾选 <code>This project is parameterized</code>，选择 String 参数，这里定义一个变量 version。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f0e1221-1b21-4ac1-a991-19753f4085ca.png" alt="image.png"></p><ol start="2"><li>由于部署任务和打包任务是分开，此处无需在使用 Git 去拉取代码，也无需定义构建触发器，直接手动构建即可。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/8489f466-cf27-4f07-b07a-304f8b42769b.png" alt="image.png"></p><ol start="3"><li>build 环节还是去执行一个 shell，这里我们配置一个 java 程序启动命令 <code>java -Dserver.port=5000 -jar  /c/Users/Administrator/Desktop/jenkins/$&#123;version&#125;.jar</code>指定 5000 端口，并且根据输入的版本号，去执行对应的 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f823c65-51d5-4936-b226-d635fc86e3c3.png" alt="image.png"></p><ol start="4"><li>根据上个任务构建的输出，我们执行部署任务的构建。Jenkins 会弹出提示，此时输入对应的项目版本号，点击开始构建，等待构建完成项目就启动成功了。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b651a7f8-0267-42c9-861b-4ea128b5f596.png" alt="image.png"></p><h2 id="使用-Jenkinsfile-创建-Job"><a href="#使用-Jenkinsfile-创建-Job" class="headerlink" title="使用 Jenkinsfile 创建 Job"></a>使用 Jenkinsfile 创建 Job</h2><p>图形化页面创建一个 Job 很方便，但是当 Jenkins 需要为多个项目创建 Job 时，一个一个手动创建就会很繁琐，并且 Job 信息也没办法进行版本管理。</p><p>Jenkinsfile 就是来解决这个问题的，他将 Job 的配置信息用脚本语言来表示，这样只需要维护这个脚本即可。Jenkinsfile 就像是一份说明书，指导 Jenkins 的工作，让他自动帮我们完成配置。编写 Jenkinsfile 的脚本语言是 Groovy，推荐学习。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>整个流程如图：<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/70124ec6-6334-457c-9f47-4341127d490c.png" alt="image.png"></p><p><strong>创建流程</strong>：</p><ul><li><p>为项目编写 Dockerfile。</p></li><li><p>创建 Jenkinsfile。</p></li><li><p>使用 pipleline 语法编写脚本：使用 Dockerfile 文件 build 一个镜像，并上传到 Docker 私服。</p></li><li><p>使用一个新的 Job，用来获取 Docker 私服所有项目版本信息，支持选择对应版本部署。</p></li></ul><h3 id="为项目编写-Dockerfile"><a href="#为项目编写-Dockerfile" class="headerlink" title="为项目编写 Dockerfile"></a>为项目编写 Dockerfile</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">FROM <span class="hljs-attr">java:</span>openjdk<span class="hljs-number">-8</span>u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target<span class="hljs-regexp">/oh-my-jenkins-0.0.1-SNAPSHOT.jar /</span>app<br><br>EXPOSE <span class="hljs-number">8080</span><br><br>CMD [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;oh-my-jenkins-0.0.1-SNAPSHOT.jar&quot;</span> ]<br></code></pre></td></tr></table></figure><h3 id="在-master-分支创建-Jenkinsfile-并编写对应的脚本"><a href="#在-master-分支创建-Jenkinsfile-并编写对应的脚本" class="headerlink" title="在 master 分支创建 Jenkinsfile 并编写对应的脚本"></a>在 master 分支创建 Jenkinsfile 并编写对应的脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>     agent any<br>     triggers &#123;<br>          pollSCM(<span class="hljs-string">&#x27;* * * * *&#x27;</span>)<br>     &#125;<br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            agent &#123; docker &#123;<br>                image <span class="hljs-string">&quot;circleci/openjdk:8u212-jdk-stretch&quot;</span><br>                args <span class="hljs-string">&#x27;-v /usr/local/docker-cache:/root/.m2&#x27;</span><br>                            &#125;<br>                 &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&#x27;mvn clean package&#x27;</span><br>                stash <span class="hljs-attr">includes:</span> <span class="hljs-string">&#x27;**/target/*.jar&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;app&#x27;</span><br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Docker Build&#x27;</span>) &#123;<br>           steps &#123;<br>               echo <span class="hljs-string">&#x27;Starting to build docker image&#x27;</span><br><br>                unstash <span class="hljs-string">&#x27;app&#x27;</span><br>                script &#123;<br>                    <span class="hljs-keyword">def</span> customImage = docker.build(<span class="hljs-string">&quot;172.29.145.109:5000/on-my-jenkins:$&#123;new Date().format(&#x27;yyyy-MM-dd-HH-mm-ss&#x27;)&#125;&quot;</span>)<br>                    customImage.push()<br>                &#125;<br>           &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本定义了轮询任务，在 docker 中使用 java 环境运行 <code>mvn clean package</code>打包，并把它暂存。之后使用一个 docker build 构建镜像并推送到 docker 私服。由于私服地址和 Jenkins 都在同一个服务器，因此直接使用内网 ip。</p><h3 id="在-deploy-分支创建-Jenkinsfile-并编写部署脚本"><a href="#在-deploy-分支创建-Jenkinsfile-并编写部署脚本" class="headerlink" title="在 deploy 分支创建 Jenkinsfile  并编写部署脚本"></a>在 deploy 分支创建 Jenkinsfile  并编写部署脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> responseJson = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://172.29.145.109:5000/v2/oh-my-jenkins/tags/list&quot;</span>)<br>        .getText(<span class="hljs-attr">requestProperties:</span> [<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&quot;application/json&quot;</span>]);<br><br>println(responseJson)<br><br>Map response = <span class="hljs-keyword">new</span> groovy.json.JsonSlurperClassic().parseText(responseJson) <span class="hljs-keyword">as</span> Map;<br><br><span class="hljs-keyword">def</span> versionsStr = response.tags.join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>pipeline &#123;<br>     agent any<br><br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            input &#123;<br>                message <span class="hljs-string">&quot;Choose a version&quot;</span><br>                ok <span class="hljs-string">&quot;Deploy&quot;</span><br>                parameters &#123;<br>                    choice(<span class="hljs-attr">choices:</span> versionsStr, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;version&#x27;</span>)<br>                &#125;<br>            &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker rm -f oh-my-jenkins&#x27; || true&quot;</span><br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker run --name oh-my-jenkins -p 8081:8080 -d 172.29.145.109:5000/oh-my-jenkins:$&#123;version&#125;&#x27;&quot;</span><br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本获取 Docker 私服的<code>oh-my-jenkins</code>镜像，部署我们选择的版本。</p><h3 id="在-Jenkins-创建多分支流水线任务"><a href="#在-Jenkins-创建多分支流水线任务" class="headerlink" title="在 Jenkins 创建多分支流水线任务"></a>在 Jenkins 创建多分支流水线任务</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b439354a-e1a4-47f4-9bf4-06975e7d8c98.png" alt="image.png"></p><p>然后只需要配置仓库地址就好了，由于 GitHub 抽风，所以使用 Gitee 仓库地址。<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/4047e5a2-911f-4a91-9380-55c45988a209.png" alt="image.png"><br>创建完流水线任务，他会自动扫描仓库上的所有分支，并读取 Jenkinsfile 文件，执行命令。</p><h3 id="选择版本部署"><a href="#选择版本部署" class="headerlink" title="选择版本部署"></a>选择版本部署</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3368c931-7653-4f8a-bc9e-df43d04ee7fc.png" alt="image.png"><br>当流水线分支创建完成之后，deploy 分支会等待我们选择版本，选择需要部署的版本，deploy 即可完成部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节码加载与执行</title>
    <link href="/2022/03/03/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <url>/2022/03/03/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码是高级语言和 JVM 通信的桥梁，高级语言只做一件事：把代码编译成字节码。因此，完全可以编写一套自己的编程语言，定义他的语法规则，然后将实现一个编译器，将代码转为字节码即可。</p><p>来看看 Java 中的字节码长什么样子，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.greek.shop;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译之后部分字节码如下：</p><p><img src="/../picture/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/3f4c78d1-d33f-4463-a2d3-b2a4dc2901d4.png" alt="image.png"></p><p>图中的字节码，正在一行行地执行指令，这些指令作用可以参考 <a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">Java 字节码指令表</a>。</p><p>不知你是否察觉，我们可以直接编写字节码，而不再需要高级语言编译成字节码，这当然是可行的，因为我们熟知的「动态代理」就是这么做的。</p><h2 id="字节码加载"><a href="#字节码加载" class="headerlink" title="字节码加载"></a>字节码加载</h2><p>编译器把高级语言编译成字节码文件，那么 JVM 又是怎么加载和执行字节码的呢？</p><p>不知你注意到没，在使用 IDE 运行程序时，好像只要点击绿色箭头代码就可以运行了。IDE 好像有魔力一般，但实际上那个绿色箭头只是在后台「偷摸」地拼接一个命令行，启动一个 JVM ，仅此而已。</p><p>你可以通过控制台查看到 IDE 帮你拼接的命令行，命令行中有一个参数 **”-classpath”**，这个 classpath 就指明了 JVM 加载字节码路径。想更多了解 Java 启动命令相关知识，可以参考我之前写的<a href="https://www.yuque.com/greek-zzf/uc535m/lvzgfb">博客</a>。</p><p>使用 classpath 指明了加载路径，于是 JVM 便使用类加载器 (ClassLoader) 加载字节码。</p><p>类加载器只有一个作用，负责加载字节码文件，仅此而已。他也支持动态加载代码，动态生成代码等，用一段代码简单演示动态加载代码过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>   <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> scanner.next();<br><br>   <span class="hljs-type">File</span> <span class="hljs-variable">jar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;fastjson-&quot;</span> + version + <span class="hljs-string">&quot;.jar&quot;</span>);<br>   <span class="hljs-keyword">if</span> (jar.exists()) &#123;<br>       <br>       <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;jar.toURI().toURL()&#125;);<br>       <span class="hljs-type">Class</span> <span class="hljs-variable">fastJson</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;com.alibaba.fastjson.JSON&quot;</span>);<br>       System.out.println(fastJson.getField(<span class="hljs-string">&quot;VERSION&quot;</span>).get(<span class="hljs-literal">null</span>));<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       System.out.println(jar.getName() + <span class="hljs-string">&quot; Not Found!&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>上诉代码在项目中没有引入任何依赖和 Jar 包，只是在项目根目录中放了两个不同版本的  FastJson jar 包。用户输入 FastJson 版本，类加载器去加载对应的 jar 包，获取成功打印 jar 包的版本信息，这就是个简单的动态加载过程。</p><p>上诉代码可以让 ClassLoader 加载指定版本的 jar 包，其实热部署的原理也类似于此。通过监听器监听对应的文件或文件夹，倘若发生改变，则调用自定义的 ClassLoader 进行重新加载，达到热部署的目的。</p><p>当然类加载器的场景还存在 Mock ，AOP 中，使用过 Mockito 或者 AOP 就会知道，他们都是通过<strong>字节码增强</strong>的方式生成目标对象的子类，然后交给 JVM 执行。</p><h3 id="双亲委派加载模型"><a href="#双亲委派加载模型" class="headerlink" title="双亲委派加载模型"></a>双亲委派加载模型</h3><p>由于 ClassLoader 只负责加载字节码，因此完全有可能，编写一个恶意的字节码文件，让 ClassLoader 去加载执行它，破环我们的程序。为了程序的安全性，于是就有了<strong>「双亲委派加载模型」</strong>。</p><p>在 Java 8 及之前的双亲委派加载模型如图：</p><p><img src="/../picture/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/83a6b7ef-4646-4e08-bd37-8568ca3b1ff7.png" alt="classloader.png"></p><p>通过图中的关系，可以发现 JVM 的启动不止有一个类加载器，而是有三个。这三个类加载器各司其职，分工明确，且三个类加载器都是继承关系。</p><ul><li><strong>Application ClassLoader （应用类加载器）</strong>是负责加载 classpath 里面的包，即我们编写好的代码，该加载器继承 Extension ClassLoader。 </li><li><strong>Extension ClassLoader （扩展类加载器）</strong>负责加载与运行程序相关的 jar 包，像使用的 ArrayList，Object 等等，该类加载器继承 Bootstrap ClassLoader。 </li><li>** Bootstrap ClassLoader（启动类加载器） **负责加载 JVM 启动时至关重要的包。</li></ul><p>双亲委派加载模型简单描述就是：<strong>子加载器加载类之前，需要先去询问父加载器，如果父加载器不为空且找到该类，则直接返回，否则子加载器才去加载</strong>。</p><p>在这个过程中你发现了吗？越核心的类都是由父加载器去加载的，这样在一定程度上保存了程序的安全。倘若你伪造一个 java.lang.Object 类，想让类加载器去加载该 Object 类，这是做不到的。当 Application ClassLoader 去加载伪造的 Object 时，就会先去询问父加载器是否加载该类，显然该 Object 类已经被 Extension ClassLoader 加载，只不过加载的 Object 并非你伪造的 Object，因此你伪造的 Object 并不会被加载。</p><h3 id="神奇的类"><a href="#神奇的类" class="headerlink" title="神奇的类"></a>神奇的类</h3><p>自定义一个 ClassLoader 并且实现了 loadClass 方法，如果加载的类名字为 BadClass 则使用自定义的类加载器去加载，否则由父加载器加载。然后将加载好的 BadClass 字节码文件，实例化一个 BadClass 对象。详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.greek;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BadClass</span> <span class="hljs-variable">bad</span> <span class="hljs-operator">=</span> (BadClass) <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>().loadClass(BadClass.class.getName()).newInstance();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">if</span> (name.contains(<span class="hljs-string">&quot;BadClass&quot;</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;target/classes/com/greek/BadClass.class&quot;</span>).toPath());<br>                <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;Class &quot;</span> + name + <span class="hljs-string">&quot; Not Found!&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当你运行这段代码时，你会发现竟然报错了，在我的控制台中错误信息如下：</p><p><img src="/../picture/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/162ca5ee-c88c-48af-8cd7-14fdd98ebfa0.png" alt="image.png"></p><p>什么？两个相同的类包名也完全一样，竟然不能互转，，真是令人大跌眼镜。</p><p>那么为什么会这样呢？这是因为这两个 BadClass，不是由同一个类加载器加载的。BadClass 在 JVM 中是由 Application ClassLoader 加载的，上面的代码使用 MyClassLoader 覆盖 loadClass 逻辑，主动去加载 BadClass 并用加载的字节码实例化一个 BadClass 对象，但由于声明的对象和实例化的对象并非相同的类加载器加载的，就会导致类型转换异常。</p><p>同样的在 Java 的 instanceof 方法，类加载器也会被检查，若不是同一个类加载器加载的类，则 instanceof 判断为 false，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">badClass</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>().loadClass(BadClass.class.getName()).newInstance();<br>System.out.println(badClass <span class="hljs-keyword">instanceof</span> BadClass);<br></code></pre></td></tr></table></figure><h2 id="JIT-Compiler"><a href="#JIT-Compiler" class="headerlink" title="JIT Compiler"></a>JIT Compiler</h2><p>有了类加载器加载字节码，还需要将字节码「翻译」成对应平台的指令。这个「翻译」过程由两种方式：<strong>编译执行和解释执行</strong>。</p><p><strong>解释执行</strong>就是每执行一行就把该行翻译成机器指令，类似于「同声传译」。自然他会比较慢，因为每次执行都需要一个转换的过程，但是它对于跨平台是很方便的，因为，不用操心平台是否能看懂字节码，只需要带个同声传译的翻译即可。</p><p><strong>编译执行</strong>就是把要翻译的内容，提前翻译好，然后直接给到平台。这样的好处是执行快，平台不用等你翻译，它直接拿翻译好的文件阅读即可。缺点也很明显，就是不灵活，在 Windows 平台运行，要提前翻译成 Windows 的指令，在 Liunx 平台运行，又要翻译成 Liunx 的指令，且翻译后的文件都比较臃肿。</p><p>那么 HotSpot 是用的那种方式呢？</p><p>答案是混合模式，它既不想丢失解释执行的便利性，也不想失去编译执行的速度，所以采取了折中的方案。他把一些常用的方法采用编译执行编译好，以提升执行的代码执行速度，其他的则采用解释执行。</p><p>JIT Compiler 全称是 Just In Time Compiler（即时编译器），HotSpot 就是使用该编译器动态地发现 JVM 运行时的<strong>热点</strong>，然后针对这些热点编译成相应的 native code ，提高运行效率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，字节码的加载与执行过程已经结束了，他的神秘面纱也被揭开。</p><p>高级语言通过编译器编译成字节码，JVM 使用类加载器去加载字节码。字节码存在安全性问题，因此 JVM 采用双亲委派机制去加载字节码。又因为每次执行都需要将字节码编译成机器指令，效率并不高，因此采用了即时编译 JIT 技术，这样既保证了效率又保证了跨平台性。</p><p>纵观整个过程发现，编程语言到可以执行的机器指令，经历了不止一次编译过程。把从高级语言到字节码的过程称为<strong>编译前端，</strong>从字节码到机器指令的过程称为<strong>编译后端。</strong>两个端各司其职，互不干扰，都是通过字节码这个「中介」交流<strong>。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基本结构</title>
    <link href="/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>谈起 JVM 第一印象就是「八股」，毕竟正经人谁学 JVM 啊。当我深入学习，了解了相关原理后，真令人大呼过瘾。</p><p>了解 JVM 并不会让你更快的 CRUD，对大部分工作没有实质性的帮助，但这是成为高级程序员的第一步。</p><h2 id="JVM-初识"><a href="#JVM-初识" class="headerlink" title="JVM 初识"></a>JVM 初识</h2><p>JVM 全称是 <strong>Java virtual machine</strong> 即 Java 虚拟机。JVM 是抽象（虚拟）计算机，它定义了一系列规范，因此他有很多实现，如：HotSpot，Eclipse OpenJ9 等等，最常使用的应该就是 Oracle 的 HotSpot。</p><p>JVM 存在的意义就是抹平所有平台和操作系统的鸿沟。它就像是一个在不同平台提供的翻译官，当用英语和它对话时，他翻译成自己「国家」的语言并执行。这就是为什么在 Windows 下编写好的代码能够在 Linux 等其他系统运行的原因。</p><p>代码编译执行过程如图<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/4ff19c89-d87f-4273-bfe4-3c47e3a8f1ad.png" alt="jvm_1.png"><br>程序员使用像 Java，Kotlin，Scala ，Groovy 等高级语言进行编码，编译成 JVM 能识别的语言。JVM 识别并进行「二次编译操作」，将它翻译成对应的平台语言。</p><p>日常编码所做的仅仅只是用高级语言编写一份「说明书」，说明书如何编译成中间语言，这就是高级语言编译器做的事了，当然也可以自己去实现一个编译器，嗯。。至少我目前没有这个能力。</p><p><strong>JLS</strong></p><p>Java 语言规范 Java Language Specification， 定义了 Java 编程的语法。比如 Java 中的关键字信息 class、public 等等，都是在 JLS 规范下，完成 Java 代码的开发。</p><p><strong>JVMS</strong></p><p>Java 虚拟机规范 Java Virtual Machine Specifiction，定义了字节码如何在 JVM 中执行，仅此而已。</p><h2 id="JVM-堆-Heap"><a href="#JVM-堆-Heap" class="headerlink" title="JVM 堆 (Heap)"></a>JVM 堆 (Heap)</h2><p>堆是 JVM 中非常重要的区域，所有的「对象」都在堆上分配，它是个无情的对象生产机器，只负责生产，不负责销毁。</p><p>堆为我们创建了对象，但是在代码中操作与访问对象实际上都是在操作对象的地址或者引用。</p><p>来看个非常简单的代码，以此来演示堆中发生了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1540f816-9a4c-4b1f-af66-0a4c6b917b3c.png" alt="jvm_heap.png"><br>首先堆内存中创建了一个对象（假设对象地址为 100），然后将该对象的地址赋值给 obj 变量，可以想象有一条线将 obj 和 对象 100 连接起来。</p><p>接着，堆内存中又创建了一个变量 101，然后将该对象地址赋值给 obj，此时 obj 和对象 101 连接起来了。这就是堆所做的一切。</p><p>很显然，上面的例子对象 100 还是存在堆中，他并没有消失，他还在等有缘人「联系」它。</p><p>这样就会存在一个问题，「无人问津」的对象越来越多怎么办？这就涉及到 GC 了，GC 会根据相应的算法来判断对象是否需要回收销毁，因此暂时不需要操心，后续提供 GC 的讲解。</p><p>当然堆中产生的对象太多，大量占用堆内存，导致内存溢出，常见表现为 OOM (Out Of Memory) 异常。当代码出现该异常时，就应该关心，代码是否产生了大量不必要的对象，谨慎的检查代码。</p><h2 id="JVM-栈（Stack）"><a href="#JVM-栈（Stack）" class="headerlink" title="JVM 栈（Stack）"></a>JVM 栈（Stack）</h2><p>当我们用 IDEA Debug 如下代码，可以看到在 IDEA 界面底部，多了一些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    a();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am a&quot;</span>);<br>    b();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我的调试器中表现形式如下：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/9c51eaa9-3ce2-4d47-9a40-b38be9fba7aa.png" alt="method_stack.PNG"></p><p>从 main 方法到 b 方法，中间一系列调用都称作<strong>「栈」</strong>或<strong>「方法栈」</strong>，其中每一次方法调用称作<strong>「栈帧」</strong>，如图中的 main，a，b。</p><p>不知你是否思考过，为什么代码的调用形式会是这样？无论你是否好奇过，现在我来分析下代码执行的过程。</p><p>我们都知道，Java  程序的入口都是 main 方法开始的，因此当代码被执行时，会先调用 <strong>main</strong> 方法。不过，在调用 main 方法之前，JVM 创建一个方法栈，用来保存「当前线程」方法调用过程（因此方法栈是线程私有的）。于是方法栈中会放入第一个栈帧 main，由于栈结构的特性，main 自然而然的就会在栈底。</p><p>接着执行 main 方法，执行到最后需要调用 <strong>a</strong> 方法，因此将栈帧 a 放入方法栈中。接着 a 中又调用 b 方法，以此类推。现在，方法栈中已经有 3 个栈帧了，方法调用已经结束了。于是从栈顶开始，将方法的执行结果依次返回，b 方法中无返回值，因此执行完打印语句，b 栈帧就销毁了。以此类推到 a 方法，最后到 main，这就是上述代码玩完整的执行过程，流程如图：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/41370100-58dc-4f78-bdde-b88dd7483c77.png" alt="method_stack_invoke.png"></p><p>了解了方法调用的基本流程，这里有几个疑问：</p><p><strong>Q：当方法栈满了会发生什么？</strong></p><p>A：当栈深度过⼤时抛出 StackOverflowError，著名的程序员交流网站就是以此命名的 <a href="https://stackoverflow.com/">stackoverflow</a></p><p><strong>Q：栈帧销毁什么时候被销毁？</strong></p><p><strong>A</strong>：这些情况栈帧会被销毁：当方法执行抛出异常或者错误；方法正常返回结果或者无返回。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>来看一段简单的代码， a 方法定义了一个变量，并且调用了 b 方法使得该变量自增，然后打印该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    b(i);<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    i++;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中打印的结果为 0，按照正常的思维去理解的话，i 的值因该为 1 才对，这是为什么？</p><p>这是因为这些变量在方法中都是<strong>「值传递」</strong>的，当把 i 传递给 b 方法时，发生了一次拷贝，因此 b 方法中操作的 i，实际上只存在 b 方法中，并不会影响到 a 方法中的 i 变量。</p><p>上面说的是基本类型变量传递，接下来用引用数据类型来进行参数传递，看看发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    b(obj);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(Object obj)</span>&#123;<br>    obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中初始化了一个变量 obj，并把它当作参数传递给 b 方法，b 方法中创建一个新的对象，并把该对象地址赋值给参数 obj。整个过程就是这样，此时 a 中的 obj 对象和 b 中的 obj 是什么关系？他们是同一个对象吗？b 中的对象改变了，会影响到 a 吗？</p><p>有过编程经验的应该都知道，答案是否定的。<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/42e48b45-6083-49b6-ae87-95fe66c76114.png" alt="stack_argument.png"><br>如图所示，a 中 obj 变量指向 Object 10087，把 obj 当作参数给 b 方法时，他会直接复制 obj 所指向的对象地址，即 b 方法刚开始也指向 10087 对象。之后创建了一个新对象地址为 10086，并把地址重新赋值给了 obj，因此 b 中的 obj 指向的是 10086，而 a 指向的是 10087，两者操作的都不是同一个对象，因此也不会相互影响。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>现在已经对 JVM 中的堆和栈有所了解，但是对于方法栈中的每个栈帧还不了解，目前只是知道方法调用就入栈，结束就出栈。因此，现在将栈帧放大来看，看看代码执行过程中，栈帧发生了什么。</p><p>每个栈帧中都有一个「操作数栈」和「局部变量表」。</p><p>每当方法调用开始的时候，局部变量表会被初始化成当前方法的参数。操作数栈上会根据代码实际情况，加载局部变量表中的数据，或者直接加载常量，根据<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">字节码指令集</a>，完成相应的数据操作。</p><p>这就像是人在吃饭一样，用筷子在碟子（局部变量表）中夹菜，夹到碗中（操作数栈），然后根据自己喜好（代码）吃自己的菜。</p><h2 id="JVM-方法区"><a href="#JVM-方法区" class="headerlink" title="JVM 方法区"></a>JVM 方法区</h2><p>方法区中包含了整个虚拟机所共享的 Class 信息，JVM 就是根据方法区中 Class 这份说明书，来帮我们生成对象的。</p><p>方法区中存的所有信息都是共享，基本都是只读的，但这并不是一定的。<strong>「运行时常量池」</strong>就是个例外，在程序运行时往往会往常量池中放入常量信息。</p><p>运行时常量池会保存经常使用的常量，例如 String 字符串常量，当重复 new 一个相同字符串对象时，新的对象就会指向字符串常量池中的字符串常量，这样就节省了内存开销。同时在 String api 中，由于常量的重复使用，可以使得它的 equals 方法可以更快速地进行判断。</p><p><strong>永久代和元空间</strong></p><p>JVM 方法区是一块所有的线程共享的区域，是 JVM 所定义的规范。</p><p>Java 7 之前发方法区的实现称作<strong>「永久代」</strong>，即 <strong>PermGen</strong>。Java 8 之后的称作<strong>「元空间」</strong>，即 <strong>Metaspace</strong>。</p><p>在 Java 7 中，方法区和堆是使用一块连续的物理内存，仅仅是在逻辑上分开的。如果没有设置方法区的大小的话，使用默认大小很容易遇到 OOM 错误。</p><p>在 Java 8 之后，把方法区和堆区分开来，使用了本地内存（Native memory），大小取决于本地内存大小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2022/01/03/Stream/"/>
    <url>/2022/01/03/Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Stream-流"><a href="#什么是-Stream-流" class="headerlink" title="什么是 Stream 流"></a>什么是 Stream 流</h2><p>流就相当于工厂的流水线工作，传送带上是一件件产品，而传送带周围是一些工人。有的负责把挑出次品，把它放到其他另一条流水线中重新加工，有的负责根据产品颜色进行收集，等等。如下图所示。<br><img src="/../picture/Stream/446cbca4-82a6-49e7-8ceb-1ceadcbcc8a9.png" alt="image-20210424211146663.png"></p><p>三个员工对传送带上的产品进行操作，老王负责收集把黄色产品挑出，老周负责把产品按先后排序，而老赵负责把残次品挑拣出来，拆开零件放到新的床送带中，继续加工。传送带的终点就是篮子，产品都流向篮子里面。</p><p>流的操作就是如此。在没有流之前，我们要自己从一堆产品中找到残次品很难。但是我们有了流之后，我们有了流水线，有了工人，我们就可以让工人帮我们收集，让他们来处理，我们只是充当老板的角色，下达命令即可。在 Java 的流 (Stream) 中，我们只需要使用一些命令，剩下的交给程序本身去执行。这样做既减少了代码量，又能高效完成我们的需求，真是两全其美。</p><p>在上面的过程中，我们把老王和老周，以及老赵操作叫做<strong>中间操作</strong>。因为他们并没有把产品收集起来，他们只是把其他不合格的产品过滤挑出，产品最终都是到篮子里面。但是你装产品不一定是用篮子，你也可以使用箱子，等其他容器。我们把使用这些<code>容器</code>装产品的操作称作<strong>终结操作</strong>。在 java 中，<strong>中间操作就是返回为 Stream 的操作，终结操作就是返回非Stream 的操作。</strong>下面会详细讲解。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p><strong>创建 Stream</strong></p><ul><li>Collection.stream()</li><li>Stream.of()</li><li>String.chars()</li><li>IntStream.range() 等</li></ul><p><strong>Stream 中间操作</strong></p><ul><li>filter 按照输入的条件，过滤流中的元素</li><li>map</li><li>sorted 对流中的元素排序</li></ul><p><strong>Stream 终结操作</strong></p><ul><li>forEach 遍历流中的元素</li><li>count &#x2F; max &#x2F; min 统计元素个数 、最大元素、最小元素</li><li>findFirst &#x2F; findAny 找到第一个元素、随机找一个元素</li><li>anyMatch &#x2F; noneMatch 是否有匹配的元素、没有匹配的元素</li><li><strong>collect</strong> 等</li></ul><p>从方法名中我们就能了解它的用处，更为详细的 API 操作可以查看 Stream 源代码。</p><h2 id="Collector-操作"><a href="#Collector-操作" class="headerlink" title="Collector 操作"></a>Collector 操作</h2><p>Collector 操作是 Stream 中最强大的操作，他就是我们上面例子中提到的「篮子」「箱子」等。它具有以下 API</p><ul><li>toSet &#x2F; toList &#x2F; toCollection</li><li>joining()</li><li>toMap()</li><li>groupingBy()</li></ul><p>通过这些 API 操作，使得我们能将流中的元素收集起来</p><p>下面通过一些实际案例，加深对 Stream 的理解。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        User(String name, <span class="hljs-type">int</span> age) &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有个需求<strong>筛选出年龄大于等于60的用户，然后将他们按照年龄从大到小排序，将他们的名字放在一个LinkedList中返回</strong>。我们可以使用 Stream 写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LinkedList&lt;String&gt; <span class="hljs-title function_">collectNames</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>       <span class="hljs-keyword">return</span> users.stream()<br>               .filter(user -&gt; user.age &gt;= <span class="hljs-number">60</span>)<br>               .sorted(comparing(User::getAge).reversed())<br>               .map(user -&gt; user.name)<br>               .collect(toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><p>解析：要使用 Stream 首先就需要创建它<code>users.stream()</code>，根据要求筛选出年龄大于 60 的用户 <code>filter(user -&gt; user.age &gt;= 60)</code>，然后使用 sorted 对筛选后的用户按照年龄排序。由于我们要返回的是一个字符串列表<code>LinkedList&lt;String&gt;</code>，而我们 Stream 中的元素都是对象类型，因此我们使用 <code>map(user -&gt; user.name)</code>，把User 映射成 String 类型，这样 Stream 中的元素都是用户的名字了。最后，使用 collect 操作将用户的名字收集成一个 Linked ，这样就解决了我们的需求。</p><p>通俗解释：我们作为老板，我们要创建一条流水线，然后安排工人在流水线旁边进行操作。安排员工老赵把用了60年以上的产品，筛选出来。筛选完后，安排老周按使用时长进行从大到小排序。排序之后，安排老王把可用的零件拆下来，最后用一个篮子收集这些可用的零件。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>统计一个给定的字符串中，大写英文字母（A,B,C,…,Z）出现的次数</strong>。例如，给定字符串”AaBbCc1234ABC”，返回6，因为该字符串中出现了6次大写英文字母 ABCABC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUpperCaseLetters</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) str.chars()<br>            .filter(Character::isUpperCase)<br>            .count();<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：String 类型创建流 <code>str.chars()</code>，然后使用 filter 进行过滤操作，过滤出大写字母 <code>filter(Character::isUpperCase)</code>，接着对过滤出的字母进行统计，完成需求。</p><p>更多关于 Stream 操作 demo点击<a href="https://github.com/greek-zzf/my-demo/tree/main/example/Stream%20%E7%BB%83%E4%B9%A0">这里</a></p><h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>可以通过并发提高<strong>互相独立操作</strong>的性能。</p><p><strong>互相独立操作</strong>指的就是，操作相互之间不影响。例：1个人割麦子需要10天，那10个人割相同面积的麦子就只需要1天。</p><p><strong>非互相独立操作</strong>就像女人生孩子，1个女人十10个月生1个孩子，但是10个女人并不是一个月就能把孩子生出来。</p><p>在正确使用的前提下，可以获得近似线性的性能提升。要使用并发流我们可以使用 <code>parallelStream()</code>创建并发流。或者在原有流的基础上，使用 <code>parallel()</code> 方法将流转化为并发流。</p><p>使用一个简单的案例来使用并发流，统计 1 到 100万之间的质数个数 。原始的 Stream 写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).filter(是否为质数).count()<br></code></pre></td></tr></table></figure><p>并发流写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).parallel().filter(isPrime).count();<br></code></pre></td></tr></table></figure><p>因为统计个数属于互相独立操作，就像两个人数羊群有多少只绵羊一样，两人分别数自己区域的羊，然后再加起来汇总。</p><p>对于并发流来说，使⽤要⼩⼼，性能要测试，如果你不知道⾃⼰在做什 么，就忘了它吧。对于详细的操作可以参考<a href="https://book.douban.com/subject/30412517/">《Effective Java 第三版》</a>42-48节。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-年终总结（技术向）</title>
    <link href="/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/"/>
    <url>/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。</p><h3 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h3><ul><li>Maven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。</li><li>学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。</li><li>了解 Jenkis 自动化部署的流程，能够进行简单的构建。</li><li>学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。</li><li>编写了自己的自动化脚本，自动拉取代码打包，运行项目。</li><li>会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。</li><li>学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）</li><li>深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。</li><li>了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。</li><li>熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。</li><li>写了一个简单的新浪新闻爬虫。</li><li>GitHub 也开始有绿点了，尽管不多，但也是个很好的开始。</li></ul><p><img src="/../picture/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/a2f75394-0052-49aa-8e37-a56774bf8a47.png" alt="image.png"></p><ul><li>帮助开源项目 <a href="https://github.com/ByteLegend/ByteLegend">https://github.com/ByteLegend/ByteLegend</a>，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。</li><li>了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。</li></ul><h3 id="知识获取渠道推荐："><a href="#知识获取渠道推荐：" class="headerlink" title="知识获取渠道推荐："></a>知识获取渠道推荐：</h3><ul><li>正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 <a href="https://fsou.cc/">https://fsou.cc/</a>，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。</li><li>取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。</li><li>论坛：<ul><li><a href="https://v2ex.com/">V站</a> 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。</li><li>HackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。</li><li>GitHub 全球最大的同性交友平台（手动滑稽）</li><li>CoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。</li><li>[<a href="https://nipafx.dev/]">https://nipafx.dev/]</a>(You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。</li></ul></li><li>许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。</li><li>了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是<strong>无所不知</strong>)、陈皓（Collshell 作者）</li></ul><h3 id="2022-的一些目标"><a href="#2022-的一些目标" class="headerlink" title="2022 的一些目标"></a>2022 的一些目标</h3><ul><li>工作顺利、生活愉快。</li><li>去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》</li><li>参与到更多开源项目中去、GitHub 绿点也可以多一些。</li><li>保持自己的好奇心、做自己想做的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？</p></blockquote><p>我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。</p><p>上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。</p><p>对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></blockquote><p>简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。</p><p><strong>二进制向量</strong>就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。</p><p>下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/54a416e0-66c1-4893-aade-ede8e001bd04.png" alt="1.png"></p><p><strong>映射函数</strong>我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。</p><p>布隆过滤器对一个 key 使用多个映射函数，得到多个值。</p><p>哈希函数映射</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/63b9a80b-0cd5-48ea-ac54-a93256a7caf7.png" alt="hash.png"></p><p>布隆过滤器中映射函数</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/51445b83-d4a0-497f-8ebb-5f0fb9ddcc76.png" alt="bloomfilter.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解一些基本概念之后，布隆过滤器的原理就很明了了。</p><p>布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。</p><p>例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/ccf230bf-6de4-49ab-8238-c9387cad586d.png" alt="insert.png"></p><p>我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。</p><p>如果是，则该元素<strong>可能</strong>在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。</p><p>如果不是，则表示该元素一定不在集合中。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。</p><h3 id="误识别率"><a href="#误识别率" class="headerlink" title="误识别率"></a>误识别率</h3><p>插入字符串 “zzh” 得到下标 2、7、11</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8b034b8d-b422-4dfc-a270-10c65db5d255.png" alt="insert.png"></p><p>插入字符串 “greek” 得到下标 5、8、9</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4bc4c95c-abee-4c20-9d5e-cf66a4b02cd5.png" alt="insert_greek.png"></p><p>插入字符串 “gem” 得到下标 2、5、8</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/66253d9d-d8ac-4783-9ba3-a3f954bfb9fa.png" alt="insert_gem.png"></p><p>可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。</p><h3 id="删除困难"><a href="#删除困难" class="headerlink" title="删除困难"></a>删除困难</h3><p>删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。</p><p>我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。</p><h3 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h3><p>识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。</p><p>假设在布隆过滤器里面有 <em>k</em> 个映射函数, <em>m</em> 个比特, 以及 <em>n</em> 个已插入元素，那么该过滤器误判率近似于：_(1-e-kn&#x2F;m)k_ 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。</p><p>对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情<a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/#footnote2">点击</a></p><blockquote><p>对于给定的 <em>m</em> 和 <em>n</em> ，有一个函数可以帮我们确定最优的 <em>k</em> 值: <em>(m&#x2F;n)ln(2)</em></p><p>所以可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的_n_, <em>m</em>, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束</li></ol></blockquote><p>事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">wiki</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>查询效率和插入效率高</strong>，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。</p><p><strong>空间效率</strong>。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。</p><p>假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。</p><p>一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 提交作业</title>
    <link href="/2021/12/24/GitHub%20%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/"/>
    <url>/2021/12/24/GitHub%20%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>使用一个工具的时候，应该先要问自己他是什么，他有什么作用？所以先根据这两个来初步了解下 Git 和 GitHub。</p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>GitHub 简单来说就是一个<code>代码仓库</code>，里面存放着世界各地程序员写的代码，我们也可以在 GitHub 上注册自己的账号，拥有自己的代码仓库。我们可以往自己的仓库提交代码，也可以去看一些大牛的仓库，学习他们的编码技巧，倘若发现一些小 Bug，我们也可以帮助别人解决，贡献一份力量。</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>想一个问题：我们已经有了自己的代码仓库 GitHub，那么我们该怎么把自己电脑上的代码放到 GitHub 中去呢？</p><p>解决这个问题的办法有：我们打开 GitHub ，在自己的代码仓库点击上传文件，这样就可以上传自己的代码。但是这样上传速度慢，而且容错性较差，可能遇到提交错误的代码，导致无法回到上一版本。</p><p><code>Git</code> 最大的用处，应该就是版本控制。可以记录你提交记录与版本，相当于「后悔药」，也支持多人协作，每个人的代码提交记录都会保存，所做的修改也有记录，这就是 <code>Git</code> 的好处。</p><h1 id="修改别人的代码"><a href="#修改别人的代码" class="headerlink" title="修改别人的代码"></a>修改别人的代码</h1><p>这是一次在 GitHub 上完成提交的经历，整个过程如下：</p><h2 id="一、Fork-别人的代码"><a href="#一、Fork-别人的代码" class="headerlink" title="一、Fork 别人的代码"></a>一、<code>Fork</code> 别人的代码</h2><p>首先，找到你要修改的仓库地址。因为是别人的代码，你没办法直接 「clone」复制下来，修改并提交，除非仓库的主人你认识，并且赋予了你修改的权限。既然没有直接的修改权限，那么我们就要 <code>Fork</code> 一份代码。<code>Fork</code> 的意思是：<strong>把当前仓库，拷贝到自己的 GitHub。</strong><code>Fork</code> 的结果就是你的 GitHub 中多了一个一模一样的仓库。<code>Fork</code> 操作如图：</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/cb59b504-916e-4f55-af84-6dc15999ca16.png" alt="image.png"><br>图中的 <code>Fork</code> 结果，在我的 GitHub 中多了一个「JavaCollection」的仓库，代码也和拷贝过来的一模一样。</p><h2 id="二、Clone-代码，并在本地进行修改"><a href="#二、Clone-代码，并在本地进行修改" class="headerlink" title="二、Clone 代码，并在本地进行修改"></a>二、<code>Clone</code> 代码，并在本地进行修改</h2><p>Clone 代码就相对简单很多了，找到 Fork 之后的仓库。我这边对应的就是我 GitHub 中的「JavaCollection」仓库，打开，并点击「code」，弹框选择 「HTTPS」,复制 「HTTPS」下面的地址。需要说明一点：如果你对 「SSH」和「GitHub CLI」不熟悉，就老老实实选择「HTTPS」。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/d3c61600-7248-4c10-be02-f8bb0a09b2f0.png" alt="image.png"></p><p>复制好地址之后，打开<strong>开发者工具</strong>，此处以 IDEA 举例。打开 IDEA，并在首页点击 <code>Get from Version Control</code> ，不同的 IDEA 版本可能名称不一样。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/3b5b086c-ccd2-4dc9-8870-53f0888ae0f9.png" alt="image.png"></p><p>在弹出的对话框中，选择在 <code>Version control</code> 选择 Git，并在 <code>Url</code> 一栏粘贴刚才复制的地址，再点击 <code>Clone</code> 即可</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/94d71270-bf17-4655-82c8-e34d275a0a9c.png" alt="image.png"></p><p>点击 Clone 之后，IDEA 会自动帮你把代码拷贝到本地，拷贝完成之后 IDEA 提示你「是否需要打开它」，选择「Yes」，等待一会，就可以对代码就行操作了。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/e55425a2-2f40-407f-8d8e-c1f85262010b.png" alt="image.png"></p><h2 id="三、Commit-代码，并-Push-本地代码到-GitHub"><a href="#三、Commit-代码，并-Push-本地代码到-GitHub" class="headerlink" title="三、Commit 代码，并 Push 本地代码到 GitHub"></a>三、<code>Commit</code> 代码，并 <code>Push</code> 本地代码到 <code>GitHub</code></h2><p>点击 IDEA 左下角的 Version Control，可看到修改的文件详情，在需要提交的文件处右键，然后点击 <code>Commit</code> ，代码就会先提交到本地仓库</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/64deed58-e000-482f-a9a7-4a34f2a7ccb7.png" alt="image.png"></p><p><code>Commit</code> 代码之后，接下来就要进行 <code>Push</code> 操作，在 IDEA 工具栏中找到「VCS」「Git」「Push」，就可以把本地代码提交到自己的 GitHub 中。接下来可以在 GitHub 中找到对应的代码仓库，查看刚才提交 <code>Push</code> 的结果。</p><h2 id="四、发起-Pull-requests"><a href="#四、发起-Pull-requests" class="headerlink" title="四、发起 Pull requests"></a>四、发起 <code>Pull requests</code></h2><p>在 GitHub 点击上传代码的仓库，就可以看到 <code>Pull requests</code> ，点击它，然后选择要提交的分支，以及他人仓库的分支，点击完成就可以了。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/269c3072-c82c-4bf3-8981-dc5abe3189e8.png" alt="image.png"><br>发起 <code>Pull requests</code> 之后只需要等待开发者查看你的 <code>PR</code>，根据情况判断是否需要，如果通过了，恭喜你成功贡献了一份力量，没有通过也不用气馁，可以看看不通过的原因什么，下次继续努力。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective Java》- Object 通用方法</title>
    <link href="/2021/12/16/%E3%80%8AEffective%20Java%E3%80%8B%20-%20Object%20%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/12/16/%E3%80%8AEffective%20Java%E3%80%8B%20-%20Object%20%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在日常 coding 中，我们会经常使用或者覆盖 Object 对象中的方法，如：equals、toString、hashcode 等。除此之外，还有 clone、finalize 方法。限于作者实力，很少用到这两个方法，即使看过原书也是一知半解，因此不敢用来「忽悠」别人。因此，这篇文章只对 equals、toString、hashCode、compareTo（该方法并非 Object 的方法）进行讲解。</p><blockquote><p>强烈推荐去看原书《Effective Java》，Java 程序员不能没有这本书，就像西方不能没有耶路撒冷。</p></blockquote><h2 id="equals-覆盖最佳实践"><a href="#equals-覆盖最佳实践" class="headerlink" title="equals 覆盖最佳实践"></a>equals 覆盖最佳实践</h2><p>equals 方法对于刚入行的人既熟悉又陌生。给人的感觉是知道这个方法，但是在实际工作中从来没有用过。虽然我也用的很少，但还是知道它的用处，以及在日常业务代码中的一些技巧，作用。</p><h3 id="equals-作用"><a href="#equals-作用" class="headerlink" title="equals 作用"></a>equals 作用</h3><p>一句话概述：<strong>比较两个对象是否相等</strong>。仅仅是比较对象是否相等，好像不值得拿出来一说。因为是 Object 的方法，因此所有的类都可以重写这个 equals 方法，满足不同类的需求，以及和 Java 中的集合类搭配使用，会产生不一样的化学反应（后面会具体描述）。</p><h3 id="业务场景与-equals-产生的化学反应"><a href="#业务场景与-equals-产生的化学反应" class="headerlink" title="业务场景与 equals 产生的化学反应"></a>业务场景与 equals 产生的化学反应</h3><blockquote><p>假设老板给你提这样一个需求：在一组用户数据中，筛选出每个省份，年龄不重复用户数据。例如不能包含两条籍贯江西，年龄一岁的用户</p></blockquote><p>你可能会想到，每次往筛选好的集合中添加数据，都要进行判断，插入的数据在集合是否有重复，这样就写成了一个双重 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;User&gt; noDuplicatedUserList, List&lt;User&gt; allUserList)</span> &#123;<br>       <span class="hljs-keyword">for</span> (User user1 : allUserList) &#123;<br>           <span class="hljs-keyword">for</span> (User user2 : noDuplicatedUserList) &#123;<br>               <span class="hljs-keyword">if</span> (user1.getHome.equals(user2.getHome) &amp;&amp; user1.getAge().equals(user2.getAge())) &#123;<br>                   <span class="hljs-keyword">continue</span>;<br>               &#125;<br>               noDuplicatedUserList.add(user1);<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>    <span class="hljs-keyword">return</span> noDuplicatedUserList;<br>   &#125;<br></code></pre></td></tr></table></figure><p>任务当然可以完成，但是你掌握一些 equals 的用法后，你就可以开始玩一些「骚操作」了。</p><p>我们开始覆盖 User 类的 equals 方法，使得这个行为变得更简单，equals 覆盖后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;User&gt; noDuplicatedUserList, List&lt;User&gt; allUserList)</span> &#123;<br>       <span class="hljs-keyword">for</span> (User user : allUserList) &#123;<br>           <span class="hljs-keyword">if</span>(!noDuplicatedUserList.contains(user))&#123;<br>           noDuplicatedUserList.add(user);<br>           &#125;;<br>       &#125;<br>    <span class="hljs-keyword">return</span> noDuplicatedUserList;<br>   &#125;<br></code></pre></td></tr></table></figure><p>是的，重写完 equals 之后，只需要使用 <code>contains</code>判断两个对象是否相等即可，因为 <code>contains</code>方法内部使用的就是对象的 equals 方法。</p><p>你还可以将代码更简化，让他返回一个去重的 HashSet 即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Set <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;User&gt; allUserList)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(allUserList);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="覆盖-equals-注意事项"><a href="#覆盖-equals-注意事项" class="headerlink" title="覆盖 equals 注意事项"></a>覆盖 equals 注意事项</h3><p>覆盖 equals 能帮我们解决问题，但必须使用得当，如果覆盖的 equals 方法，没有遵守相关约定，那么你的程序必然会在一些类的使用上出现 bug。出现 bug 一点都不可怕，可怕的是你不知道 bug 出现在哪，检查代码也发现不了错误，到头来才发现原来是这个不起眼的 equals 导致的。</p><ul><li><p>自反性：对于任何非 null 的引用值 x，x.equals(x) 必须返回 true。</p></li><li><p>对称性：对于任何非 null 的引用值 x，x.equals(y) 返回 true，y.equals(x) 也必须返回 true。</p></li><li><p>传递性：对于任何非 null 的引用值 x，y，z，x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 必须返回 true。</p></li><li><p>一致性：如果两个对象相等，在没有改变对象的前提下，他们就始终相等。</p></li><li><p>非空性：所有的对象都不能等于 null，x.equals(null)，因此在一些 equals 方法中都会进行 null 检查，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(o == <span class="hljs-literal">null</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这些规定，你可能头都炸了，我就写个 equals 还要遵守这么多约定，我还不如直接使用第一种方法呢。别急，往下看，最佳实践有人已经帮你总结出来了。</p></li></ul><h3 id="覆盖-equals-最佳实践"><a href="#覆盖-equals-最佳实践" class="headerlink" title="覆盖 equals 最佳实践"></a>覆盖 equals 最佳实践</h3><p>了解 equals 的注意事项后，以下经验就能帮助我们优雅地，高质量地覆盖 equals。拿上面的 User 来举例说明，步骤如下。</p><p><strong>步骤一</strong>：使用 “&#x3D;&#x3D;” 操作检查对象是否相等，如果是，返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(obj == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>步骤二</strong>：使用 instanceof 操作符检查「参数是否为正确类型」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> User))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：把参数转化成正确的类型（需要先通过步骤二的检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) obj;<br></code></pre></td></tr></table></figure><p><strong>步骤四</strong>：比较参数中的字段与该对象的字段，匹配返回 true，不匹配返回 false;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(user.getHome().equals(home) &amp;&amp; user.getAge.equals(age))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p><strong>完整的 equals 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br><span class="hljs-keyword">if</span>(obj == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> User))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <br><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) obj;<br><span class="hljs-keyword">if</span>(user.getHome().equals(home) &amp;&amp; user.getAge.equals(age))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>这样就写完了一个高质量的 equals 方法。但是还需要注意的是，覆盖 equals 方法，必须也覆盖 hashCode 方法（原因见下一节）。equals 的参数是 Object 对象，而不是具体的某个类，因为前者才是覆盖了 equals 方法，后者只是类中的一个普通方法。</p><h2 id="hashCode-覆盖最佳实践"><a href="#hashCode-覆盖最佳实践" class="headerlink" title="hashCode 覆盖最佳实践"></a>hashCode 覆盖最佳实践</h2><h3 id="覆盖-equals-为什么一定要覆盖-hashCode"><a href="#覆盖-equals-为什么一定要覆盖-hashCode" class="headerlink" title="覆盖 equals 为什么一定要覆盖 hashCode"></a>覆盖 equals 为什么一定要覆盖 hashCode</h3><p>回答这个问题很简单，其实就是违反了 hashCode 的约定：<strong>两个对象相等，则必须返回相同的 hashCode</strong>。</p><p>由于覆盖了类的 equals 方法，导致对象相等的逻辑发生了改变，而类的 hashCode 方法还是使用的 Object 提供的方法，就会导致相同的对象返回不同的 hashCode。</p><p>你可能觉得 hashCode 不同就不同嘛，但是你也就此失去了使用 HashMap，HashSet 等集合类的权利，强行使用会给你的代码带来未知的 bug，因为这些类都是根据 hashCode 约定来实现的。</p><p>我们可以通过一个例子演示该行为带来的问题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;User, String&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>m.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;江西&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>), <span class="hljs-string">&quot;渣渣辉&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们向 HashMap 插入了一条数据，你可能期望 <code>m.get(new User(&quot;江西&quot;，&quot;18&quot;))</code>会返回「渣渣辉」，但很可惜并不是，而是返回 null。</p><p>这是因为，虽然是两个是相同的对象，但是没有覆盖 hashCode 方法，导致存进 map 的对象的 hashcode 和 取值对象 hashcode 不一样，因此就会取不到对应的 value。</p><h3 id="覆盖-hashCode-方法"><a href="#覆盖-hashCode-方法" class="headerlink" title="覆盖 hashCode 方法"></a>覆盖 hashCode 方法</h3><p><strong>计算 hashCode</strong> </p><ol><li>我们在方法中初始化变量 result，并让他的值等于第一个需要计算字段的值。</li><li>如果字段是基本类型，我们就使用它的装箱基本类型的 hashCode 方法，计算该字段的 hashcode。</li><li>如果是对象，并且类的 equals 方法调用了该对象的 equals 方法进行比较，则我们也需要在类的 hashCode 方法中递归地调用该对象的 hashCode 方法。</li><li>如果是数组，则需要对数组中的重要元素使用上诉的方法计算 hashCode。如果所有元素都很重要，则可以使用 Arrays.hashCode 方法</li></ol><p><strong>合并返回 hashCode</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">result = <span class="hljs-number">31</span> * result + c;  <span class="hljs-comment">// 其中 C 为单个字段的 hashCode 值</span><br></code></pre></td></tr></table></figure><p>这里估计你又会好奇，为什么是要乘 31。首先 31 是一个奇素数，如果是偶数的话并且乘法导致数据溢出，就会产生信息丢失。31 有个很好的特性，可以使用移位和减法来代替乘法，可以获得更好的性能，如：<code>31 * i == (i &lt;&lt; 5) - i</code>。</p><p>我们把上述实践运用到 User 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> String.hashCode(home);<br>    result = <span class="hljs-number">31</span> * result + String.hashCode(age);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写算是比较高效的合理的覆盖，有时我们需要让 hashCode 值尽可能地不会造成冲突，我们可以使用 Guava 包下得 Hashing。如果对性能没有该要求可以使用 Objects 提供的静态 hash 方法 <code>Objects.hash(home, age);</code>。</p><p>如果是一个不可变类，且每次计算 hashCode 的开销比较大，我们可以把 hashCode 值保存到对象内部，这样下次计算 hashCode 时可以直接把保存的 hashCode 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashCode;<br>    <br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> hashCode;<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 执行相应的 hashCode 计算操作</span><br>            hashCode = result; <span class="hljs-comment">// 计算完成记得赋值保存</span><br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优雅地覆盖-toString"><a href="#优雅地覆盖-toString" class="headerlink" title="优雅地覆盖 toString"></a>优雅地覆盖 toString</h2><p>我们在开发中，使用打印语句打印对象，或者在 debug 中查看对象的信息，经常能看到如下形式：<code>User@1b456</code> 。上诉这些行为都默认的调用了对象的 toString 方法，如果类本身没有覆盖 toString 的话，则会调用 Object 的 toString 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br> &#125;<br></code></pre></td></tr></table></figure><p>从打印的对象信息来看，给我们的开发调试，提供不了任何有用的信息，因此覆盖 toString 旨在提供更多有效的信息，而不是那一串干巴巴的 <code>User@1b456</code>。</p><p>在 toString 方法中应该包含一些与类相关的信息。例如 User 类，可以返回 <code> User=&#123;&quot;江西&quot;, &quot;18&quot;&#125;</code>，这样清晰明了，比 <code>User@1b456</code> 不知好了多少。当 toString 生成的格式没有那么清晰时，就应该考虑在 javadoc 中添加格式说明，让这一过程容易被调用者接收。</p><blockquote><p>tips: 应该在抽象类中编写 toString 方法，让他的子类享有公共的 toString 方法。大多数集合类就是如此，例如：ArrayList 使用的就是 AbstractCollection 的 toString 方法。</p></blockquote><p>总而言之：如果 toString 能够为你的开发和调试等带来美观的格式，返回对象简明有用的描述，那你就应该毫不犹豫的覆盖它。</p><h2 id="优雅地实现-Comparable-接口"><a href="#优雅地实现-Comparable-接口" class="headerlink" title="优雅地实现 Comparable 接口"></a>优雅地实现 Comparable 接口</h2><p>虽然这博客说的是 Object 通用方法，但是必须说明的是 compareTo 并不是 Object 中的方法，而是 Comparable 接口的唯一方法。因为该方法很重要，且使用频率很高，所以就放在一起介绍。实现了 Comparable 接口的类，就表明该类有内在的排序关系，当然这个排序肯定是自己定义的。</p><p>java 中的有序集合类会根据其中元素类的 compareTo 方法，将内部的元素进行排序。例如：TreeSet、TreeMap 等。</p><h3 id="撞脸-equals"><a href="#撞脸-equals" class="headerlink" title="撞脸 equals"></a>撞脸 equals</h3><p>compareTo 方法在官方文档的说明如下：</p><blockquote><p>将此对象与指定对象进行比较。当该对象小于、等于、大于指定对象的时候、分别返回一个负整数、零或者正整数。如果由于指定的对象类型与该对象类型不一致、则会抛出 ClassCastExcetion 异常。</p></blockquote><p>除了上诉说明，compareTo 方法还必须遵守和 equals 类似的约定：</p><ul><li><p>sgn(x.compareTo(y)) &#x3D;&#x3D; -sgn(y.compareTo(x))，其中 sgn 是根据表达式的值为负数、正数、零，分别返回 -1、1、0。上面那个公式翻译过来就是：如果 x 大于等于 y，则 y 一定小于或等于 x，并且暗示着后者抛出异常时，前者也必定抛出异常。反之亦然。</p></li><li><p>可传递性：如果 x 大于 y，并且 y 大于 z，则 x 必须大于 z。反之亦然。</p></li><li><p>如果 x.compare(y) &#x3D;&#x3D; 0，则 sgn(x.compare(z)) 等于 sgn(y.compare(z))。</p></li><li><p>强烈建议，但非必要。(x.compareTo(y) 等于 (x.equals(y))。</p></li></ul><p>相信看完 equals 的约定，遵守这些约定对你来说应该是小菜一碟了。遵守这些约定，就能安全的使用有序集合类，以及包含搜索和排序算法的工具类。</p><h3 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="与 equals 的区别"></a>与 equals 的区别</h3><p>上面提到的强烈建议，与 equals 保持同等性。即当 compareTo 比较两个对象相等时， 两个对象进行 equals  方法比较也应该相等。</p><blockquote><p>如果违反这条建议，那么它的顺序就与 equals 不一致。如果一个类的 compareTo 方法强加了一个与 equals 不一致的顺序，那么这个类仍然可以工作，但是包含该类元素的有序集合可能无法遵守集合接口（Collection、Set 或 Map）的一般约定。这是因为这些接口的一般约定是根据 equals 方法定义的，但是有序集合使用 compareTo 代替了 equals 实施同等性检验。</p></blockquote><p>以下例子可以很好的解释。</p><p>Java 中的 BigDecimal 类，它的 compareTo 方法与 equals 不一致（没有遵守上述的建议）。如果你创建一个空的 HashSet 实例，然后添加 new BigDecimal(“1.0”) 和 new BigDecimal(“1.00”)，那么该 HashSet 将包含两个元素，因为添加到该集合的两个 BigDecimal 实例在使用 equals 方法进行比较时结果是不相等的。但是，如果你使用 TreeSet 而不是 HashSet 执行相同的过程，那么该集合将只包含一个元素，因为使用 compareTo 方法比较两个 BigDecimal 实例时结果是相等的。</p><p>因此，在使用具有排序功能的集合类时，需要特别注意 compareTo 和 equals 实现，防止引入 bug 。</p><h3 id="编写-comparaTo-方法"><a href="#编写-comparaTo-方法" class="headerlink" title="编写 comparaTo 方法"></a>编写 comparaTo 方法</h3><p>应该杜绝使用关系运算符 “&gt;” 和 “&lt;” 来表示大小关系，推荐使用包装类型提供的 compareTo 方法，来比较值。假设用户的年龄值为 int 类型，比较年龄可以使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age &gt; user.getAge())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(age &lt; user.getAge())&#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的写法也能达到比较的目的，但是很容易出错，而且需要比较的字段一多整个逻辑就很复杂。所有的装箱类型在 java7 中已经提供了静态的 compare 方法，并且也都实现了 comparable 接口。</p><blockquote><p>我们给 User 类添加一个字段 name，然后对他进行排序，先比较年龄，然后根据姓名进行排序</p></blockquote><p>使用包装类型的 compareTo 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> age.compareTo(user.getAge);<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>        result = name.compareTo(user.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用包装类型的静态 compare 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.compare(age, user.getAge);<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>        result = String.compare(name, user.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 java 8中，Comparator 接口配置了一组比较器构造方法，使得构造比较器非常简单，并且代码的可读性非常高。还是上面的示例，我们为 User 类编写一个比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;User&gt; COMPARATOR = <br>    comparingInt(User::getAge)<br>.thenComparing(User::getName);<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>   <span class="hljs-keyword">return</span> COMPARATOR.compare(<span class="hljs-built_in">this</span>, user);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码为 User 类编写了一个比较器，先比较年龄，然后比较名字。定义好比较器后，就直接在 User 的compareTo 方法使用即可。comparingInt 对应比较 int 类型，相似的也有 comparingLong_、和 _comparingDouble等。</p><p><strong>一个错误地实践</strong>，有时我们会把比较结果的正负来判断大小，我们就很容易偷懒写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> value1, <span class="hljs-type">int</span> value2)</span>&#123;<br><span class="hljs-keyword">return</span> value1 - value2;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用它的比较结果，来判断是正还是负，以此来判断 value1 和 value2 的大小关系,但是我们却没有考虑过整数溢出的情况。因为 int 类型最大，最小能表示正负21 亿左右的数字，假如 value1 是 int 类型最小值，value2 是正数，两者相减就会导致整数越界。因此使用官方为我们提供的比较方法 <code>Integer.compare(value1, value2)</code>，更为安全实用。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Effective Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 基础</title>
    <link href="/2021/12/08/Docker%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/08/Docker%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>软件的依赖，开发环境不确定性，导致部署软件项目是一件令人头疼的事。</p><p>虚拟机解决了这个问题，但是太吃内存，很耗资源。 Docker 使用了一个轻量的虚拟机。</p><p><strong>优点</strong></p><ul><li>保证开发、测试、交付、部署的环境完全一致</li><li>保证资源的隔离</li><li>启动临时的、用完即丢弃的环境，例如测试</li><li>迅速（秒级）扩容</li></ul><h2 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h2><p>docker 可以类比装系统，换系统操作。有了这个前置知识，对于 docker 的一系列知识会更容易理解。</p><h3 id="镜像-images-与容器-container"><a href="#镜像-images-与容器-container" class="headerlink" title="镜像 (images) 与容器 (container)"></a>镜像 (images) 与容器 (container)</h3><p>镜像就和电脑镜像是一样的，而容器对应的就是电脑。电脑和电脑之间是相互隔离的（A 电脑数据无法与其他电脑共享，除非使用特殊手段），容器之间也是如此。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>pull</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 镜像:镜像版本 <br></code></pre></td></tr></table></figure><p>从 docker 官方拉取镜像，镜像版本不指定默认下载 Latest 版本。镜像地址不指定默认从 Docker 官方仓库下载。</p><p><strong>images</strong> 查看所有下载的 docker 镜像</p><p><strong>run</strong> 运行容器</p><ul><li>–name 为将要启动的容器起一个名字，在引用容器 id 的时候可以替换成容器 name</li><li>–restart&#x3D;always 遇到错误自动重启</li><li>-p 与宿主机（自己的电脑）</li><li>-v &lt;本地文件&gt;:&lt;容器文件&gt; 与宿主机进行文件映射，使得容器内部和宿主机共享同一份文件</li><li>-p &lt;本地端口&gt;:&lt;容器端口&gt; 将本地端口映射到 docker 容器内部</li><li>-e  <NAME>&#x3D;<VALUE>  启动容器时传递的环境变量，使得容器在初始化时可以使用这些变量</li></ul><p><strong>rm</strong> 删除容器</p><p><strong>start&#x2F;stop&#x2F;restart</strong> 启动&#x2F;停止&#x2F;重启一个容器</p><p><strong>exec</strong> 访问容器，进入容器内部</p><p><strong>logs</strong> 容器id 查看容器日志</p><p><strong>inspect</strong> 容器id 查看当前容器的状态信息</p><p><strong>tag</strong> 镜像id 给镜像取名字</p><h2 id="创建自己的镜像"><a href="#创建自己的镜像" class="headerlink" title="创建自己的镜像"></a>创建自己的镜像</h2><p>我们可以很方便的从 Docker 官方拉取镜像，就像我们可以很方便的去网上找到 win10 镜像一样。但是，Docker 镜像并不能完全满足你的需求，所以就需要我们自己制作一个镜像。</p><p>在开始制作镜像之前，需要知道镜像内部都是分层的，我们来看一个 Redis 的 Dockerfile 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM debian:buster-slim<br><br>RUN groupadd -r -g 999 redis &amp;&amp; useradd -r -g redis -u 999 redis<br><br>ENV GOSU_VERSION 1.12<br>RUN .... // 一系列命令（此处已省略）<br><br>ENV REDIS_VERSION 6.2.5<br>ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-6.2.5.tar.gz<br>ENV REDIS_DOWNLOAD_SHA 4b9a75709a1b74b3785e20a6c158cab94cf52298aa381eea947a678a60d551ae<br><br>RUN .... // 一系列命令（此处已省略）<br><br>RUN mkdir /data &amp;&amp; chown redis:redis /data<br>VOLUME /data<br>WORKDIR /data<br><br>COPY docker-entrypoint.sh /usr/local/bin/<br>ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]<br><br>EXPOSE 6379<br>CMD [&quot;redis-server&quot;]<br></code></pre></td></tr></table></figure><p>上面的代码都很简单</p><ul><li>使用 FROM 指定基础镜像（当多个镜像指定同一个基础镜像时，就不需要重复下载）</li><li>RUN 后面跟一系列需要执行的命令</li><li>ENV 配置环境变量</li><li>VOLUME 创建可持久化目录</li><li>WORKDIR 指定了工作目录</li><li>ENTRYPOINT 为容器提供命令和参数</li><li>EXPOSE 对外暴露的端口</li><li>CMD 容器启动之后执行的命令</li></ul><p>可以看到镜像的制作都是一步一步来的，就好像你跟一个智能机器人说，我要 debian，然后帮我运行一些命令，帮我设置一个工作目录，帮我暴露一个对外端口等等，你只需要用机器人能听懂的语言跟它说，他就会按照你的要求去执行相应步骤。</p><p>Dockerfile 文件创建好之后，我们就需要把它构建成一个镜像文件。只需要使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build &lt;dockerfile 所在目录&gt;<br></code></pre></td></tr></table></figure><p>等待 Docker 帮你构建完成，接下来你就可以同其他镜像一样使用自己的镜像。</p><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><p>可以通过上面的步骤，自己编写了一个 Dockerfile，并且使用该文件构建一个镜像。如图：<br><img src="/../picture/Docker%E5%9F%BA%E7%A1%80/cb2c1d1e-f3d5-4401-a041-d0af4089e3a5.png" alt="image.png"></p><p>由于新构建的镜像是没有名字的，为了方便后续使用我们可以给它取个名字。我们可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag cf6ef720090d zzf:1.0.0<br></code></pre></td></tr></table></figure><p>再次查看我们的镜像<br><img src="/../picture/Docker%E5%9F%BA%E7%A1%80/a07b120e-37c5-4ddf-84ad-444a6622e869.png" alt="image.png"></p><p>可以看到 <code>REPOSITORY</code> 那一栏名字变成了 <code>zzf</code>，<code>TAG</code>栏也变成了 <code>1.0.0</code>。需要特别声明的是，<code>REPOSITORY</code>那一栏的名称，定义了镜像的 push 和 pull 地址，由于我们命令为 <code>zzf</code>，并没有给镜像设置地址，因此当我们 push 的时候，docker 会使用默认的 docker 官方仓库的地址，如图：<br><img src="/../picture/Docker%E5%9F%BA%E7%A1%80/c7b36c39-9367-4528-ab5e-0088e06224c2.png" alt="image.png"></p><p>为了发布到自己的 docker 仓库中去，我们需要注册一个 Docker 账号。然后把我们的镜像名称改成如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag cf6ef720090d wszzh/zzf:latest<br></code></pre></td></tr></table></figure><p>只需要在镜像名前加上 docker 用户名加 <code>/</code>，即可。这样使用 docker push 命令就能推送到我们的仓库，如图：<br><img src="/../picture/Docker%E5%9F%BA%E7%A1%80/0011501c-d73f-4819-b9a1-2409b4de1e51.png" alt="image.png"><br>这样就推送成功，我们可以登录自己的 Docker 账户查看该镜像。需要使用的时候只需要使用如下命令即可拉取我们自己的镜像，如果有多个版本，则需要在镜像地址后面加冒号跟上对应的版本号即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull wszzh/zzf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 函数式编程</title>
    <link href="/2021/09/20/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/09/20/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><strong>优点：</strong>减少工作量，减少 Bug，提高效率</p><p>减少工作量：做同样一件事，普通的方法实现，可能需要几十行代码，而函数式编程只需要几行代码</p><p>减少 Bug：代码写的越少，Bug 自然也变的越少</p><p>提高效率：别人还在吭哧坑次的写几十上百行代码时，你已经写完，顺便刷了个知乎</p><h2 id="函数式编程深入浅出"><a href="#函数式编程深入浅出" class="headerlink" title="函数式编程深入浅出"></a>函数式编程深入浅出</h2><p>你可能对我的话不信，那咱们就来看看实际的例子</p><p>假如给定一个用户列表信息，现在要你分别获取<code>id 为偶数的用户</code>、<code>姓周的用户</code>、<code>姓王的用户</code>，你会如何实现这个需求。</p><p>大多数人会写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤 id 为偶数的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithEvenId</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br><br> <span class="hljs-comment">// 过滤姓周的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterZhouUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>)) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br><br> <span class="hljs-comment">// 过滤姓王的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterWangUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.name.startsWith(<span class="hljs-string">&quot;王&quot;</span>)) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>代码达到了我们需要的效果，但是你仔细观察，会发现重复的代码太多了，不同的地方仅仅是 if 中的条件判断，这个时候就需要思考一下如何简化这些代码。稍微细心的人就会发现，过滤姓张的用户，和过滤姓王的用户可以抽取成一个方法，只需要把姓氏当做参数传给函数就行了，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤指定姓氏的用户</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithLastName</span><span class="hljs-params">(List&lt;User&gt; users,String lastName)</span>&#123;<br>      List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (User user : users) &#123;<br>          <span class="hljs-keyword">if</span> (user.name.startsWith(lastName)) &#123;<br>              result.add(user);<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样的确简化了部分代码，但是仅此而已吗？难道<code>过滤id为偶数的用户</code> 方法，就不能跟其它方法合并了吗？</p><p>这个时候你可能会想，要是可以传条件就好了，这样方法就能根据条件，过滤我们需要的用户信息。的确，这种方法确实可行，那要怎么去实现呢？既然传递的都是自己「实现」的条件，那么很容易想到「接口」这个东西。所以我们可以根据要求写一个接口，并提供一个方法，让其他实现该接口的类，自己定义方法的实现，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users,Condition condition)</span> &#123;<br>    List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-keyword">if</span> (condition.isSatisfied(user)) &#123;<br>            result.add(user);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhouUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WangUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;王&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsersWithEvenId</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用了一个接口，以及三个类，每个类对应不同的实现。编写一个根据条件过滤的方法 <code>filterUsersWithCondition</code>，我们传入接口类，然后进行条件判断。</p><p>但是实际上 Java 已经帮我们定义好了这些通用接口，不用我们再去定义，在 <code>java.util.function</code>包中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><p>他与我们自己定义的 Condition 接口很像，方法都是接收一个参数，返回一个布尔值。因此，我们完全可以把自己定义的接口，替换成官方提供的。这样又减少了一点代码量，以 <code>ZhouUser</code>类举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhouUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Predicate</span> &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(User user)</span> &#123;<br>          <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这个时候我们得 <code>filterUsersWithCondition</code> 方法，更改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users,Predicate&lt;User&gt; predicate)</span> &#123;<br>    List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-keyword">if</span> (predicate.test(user)) &#123;<br>            result.add(user);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，做到这样已经很不错了，但是我们还能精简。每次调用 <code>filterUsersWithCondition</code> 方法的时候，都要传入一个实现类，并且每次有新需求，都要生成一个新类实现 Predicate 接口，这样代码量还是很多。</p><p>我们可以这样，直接使用匿名类完成操作，这样我们就不用频繁的实现接口了。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>filterUsersWithCondition(users, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;User&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(User user)</span> &#123; <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候 IDEA 就会提示你了，按下快捷键 alt + enter 建，将匿名类转化为 Lambda 表达式。于是我们上面的代码就变成这样，代码瞬间简洁了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>filterUsersWithCondition(users, user -&gt; user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>));<br></code></pre></td></tr></table></figure><p>这边简单的介绍下 Lambda 表达式：<code>user -&gt; user.name.startsWith(&quot;周&quot;)</code>它对应的就是过滤姓周用户的匿名内部类 test 方法。<code>-&gt;</code> 左边对应参数，他完整的参数是 <code>(User user)</code>，由于 Lambda 可以通过上下文推断出参数类型，因此我们得式子仅仅指定了参数名<code>user</code>。<code>-&gt;</code> 右边的就是要执行的语句了，遇到多行执行语句需要用 <code>&#123;&#125;</code>括起来，用分号分隔语句。</p><p>Predicate 中的 test 方法，是将一个 User 对象到 boolean 的映射。实际上只要我们写的方法满足<code>object-&gt;boolean</code>，都可以自动转化成一个函数接口。比如我们刚写的 Lambda 表达式 <code>user -&gt; user.name.startsWith(&quot;周&quot;)</code> ，以及我们将要展示的方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        filterUsersWithCondition(users, Main::zhouUser);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">zhouUser</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users, Predicate&lt;User&gt; predicate)</span> &#123;<br>        List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(user)) &#123;<br>                result.add(user);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们自己编写了一个方法 <code>zhouUser</code>，这个方法也是满足 Object -&gt; boolean  的映射关系，因此他会被转化成相应的函数接口，这时使用方法引用调用这个方法，即可达到相同的目的。方法引用相比 Labmda 表达式的实现，更为清晰易懂，因为有方法名，我们很容易根据方法的名称来了解代码在干什么，对于日常维护开发更为友好。</p><h2 id="Java-中的函数接口"><a href="#Java-中的函数接口" class="headerlink" title="Java 中的函数接口"></a>Java 中的函数接口</h2><p>先说一个结论：<strong>任何只包含一个抽象方法的接口，都可以转化成函数接口</strong>，例如我们刚开始使用的 <code>Condition</code>接口。</p><p>在 Java 中不只有 Predicate，还有很多默认的实现。像，<code>Consumer</code>是 Object-&gt;void 的映射；<code>Supplier</code>是 void-&gt;Object 的映射;<code>ToIntFunction</code> 是 Object-&gt;int 的映射，等等，如图：</p><p><img src="/../picture/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/8360c589-7218-40e8-9bd9-f4f03414de05.png"></p><p>我们可以根据我们得需求使用以上接口，或者自己定义我们所需的接口。</p><h2 id="使用-Comparator-实战"><a href="#使用-Comparator-实战" class="headerlink" title="使用 Comparator 实战"></a>使用 Comparator 实战</h2><p>当我们需要对数据进行比较的时候，就需要 Comparator</p><p>还是上面说到的 User 对象，现在有了新需求，需要对 user 的 id 进行从小到大排序，然后按照年龄从大到小排列。我们可以使用 Collections.sort() 方法，对数据进行排序。可以发现需要传入的参数是一个 Comparator 接口，因此我们可以直接 New 一个 Comparator，并实现他的方法。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">4</span>, <span class="hljs-number">20</span>));<br><br>Collections.sort(users, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User o1, User o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o1.id &lt; o2.id) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.id &gt; o2.id) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Java 8 之后，JDK 为我们提供了更好的方法。在 Comparator 接口中有一个静态方法 comparing()，我们可以查看代码，发现他需要我们传入一个 Function 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">        Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>&#123;<br>    Objects.requireNonNull(keyExtractor);<br>    <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>        (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们传入的参数遵循 Function 接口对应的映射关系就可以了，打开发现 Function 是 T-&gt;R 的映射关系，即我们传入的参数转化成另一种数据类型。因此我们可以写成这样，User 类转化成整形，符合映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users,Comparator.comparing(user -&gt; user.id);<br></code></pre></td></tr></table></figure><p>我们可以使用方法引用替换 Lambda 表达式，getId 方法表面上没有参数，实际上是有一个隐藏的 this，因次该方法引用也符合映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users,Comparator.comparing(User::getId);<br></code></pre></td></tr></table></figure><p>比较了 id 之后我们还需要比较年龄的倒序排列，使用 thenComparing 继续比较，再使用 reversed() 方法将结果倒序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users, Comparator.comparing(User::getId).thenComparing(User::getAge).reversed());<br></code></pre></td></tr></table></figure><p>这样就完成了我们得需求，一行代码完成了我们得工作，还减少了 bug，头发又可以少掉几根了，真是幸福。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的分布式部署流程</title>
    <link href="/2021/09/01/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/09/01/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>使用 3 种不同的方式，将项目部署成 3 个实例，每个实例监听不同的端口，由 Nginx 负责将请求转发到对应的实例中，完成请求流程。</p><h2 id="Docker-启动-MySQL，Redis"><a href="#Docker-启动-MySQL，Redis" class="headerlink" title="Docker 启动 MySQL，Redis"></a>Docker 启动 MySQL，Redis</h2><p>首先使用 Docker 启动一个全局的 Redis，MySQL，Nginx，让项目连接上对应的数据库。</p><p><strong>获取并启动 MySQL</strong></p><p>获取最新的 MySQL 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql<br></code></pre></td></tr></table></figure><p>启动 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql<br></code></pre></td></tr></table></figure><p><strong>获取并启动 Redis</strong></p><p>获取最新的 Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis<br></code></pre></td></tr></table></figure><p>启动 Redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 6379:6379 -d redis<br></code></pre></td></tr></table></figure><h2 id="使用-Maven-Exec-插件进行部署"><a href="#使用-Maven-Exec-插件进行部署" class="headerlink" title="使用 Maven Exec 插件进行部署"></a>使用 Maven Exec 插件进行部署</h2><p>在项目的 pom 文件中，引入并配置 exec 插件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;plugin&gt;<br>    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br>    &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">3.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>    &lt;configuration&gt;<br>        &lt;executable&gt;java&lt;/executable&gt;<br>        &lt;arguments&gt;<br>            &lt;argument&gt;-classpath&lt;/argument&gt;<br>            &lt;classpath/&gt;<br>            &lt;argument&gt;com.github.hcsp.Application&lt;/argument&gt;<br>        &lt;/arguments&gt;<br>    &lt;/configuration&gt;<br>&lt;/plugin&gt;<br></code></pre></td></tr></table></figure><p>改配置信息指定了<strong>可执行程序</strong> java，指定使用 classpath 中的 jar 包，配置了主类（即程序入口），完成以上配置即可使用 <code>mvn exec:exec</code> 运行程序，演示项目运行的端口为 8081。</p><h2 id="使用-java-jar-方式运行部署"><a href="#使用-java-jar-方式运行部署" class="headerlink" title="使用 java -jar 方式运行部署"></a>使用 java -jar 方式运行部署</h2><p>使用 maven 命令对项目进行打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn package<br></code></pre></td></tr></table></figure><p>得到一个可执行的 jar 包：xxx.jar，接着使用命令执行该 jar，并指定端口为 8082</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Dserver.port=8082  -jar xxx.jar<br></code></pre></td></tr></table></figure><h2 id="使用-Docker-部署项目"><a href="#使用-Docker-部署项目" class="headerlink" title="使用 Docker 部署项目"></a>使用 Docker 部署项目</h2><p>在当前项目文件中编写 Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM java:openjdk-8u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target/spring-aop-redis-mysql-0.0.1.jar /app<br><br>EXPOSE 8080<br><br>CMD [&quot;java&quot;,&quot;-jar&quot;, &quot;spring-aop-redis-mysql-0.0.1.jar&quot;]<br></code></pre></td></tr></table></figure><p>根据编写好的 Dockerfile 生成一个 Docker 镜像文件，在当前目录运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build .<br></code></pre></td></tr></table></figure><p>构建好镜像之后运行该镜像文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -v /C/Users/Administrator/Desktop/application.properties:/app/config/application.properties -p 8083:8081 镜像id<br></code></pre></td></tr></table></figure><p>由于项目默认使用的 Redis 和 MySQL 连接都是 localhost，因此在 Docker 中运行该项目会访问不了数据库，因此，我们在本地重写了 <code>application.properties</code> 文件，并把该配置文件映射到 Docker 内部，使得 Docker 内的项目可以读取并使用该配置文件（配置文件有优先级关系，详情<a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/html/boot-features-external-config.html">点击</a>）。</p><h2 id="使用并配置-Nginx，完成分布式部署"><a href="#使用并配置-Nginx，完成分布式部署" class="headerlink" title="使用并配置 Nginx，完成分布式部署"></a>使用并配置 Nginx，完成分布式部署</h2><p>获取最新的 Nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><p>在启动 Nginx 之前需要对它进行配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">events <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>http <span class="hljs-punctuation">&#123;</span><br>    upstream backend <span class="hljs-punctuation">&#123;</span><br>        server <span class="hljs-number">192.168</span><span class="hljs-number">.110</span><span class="hljs-number">.112</span><span class="hljs-punctuation">:</span><span class="hljs-number">8081</span>;<br>        server <span class="hljs-number">192.168</span><span class="hljs-number">.110</span><span class="hljs-number">.112</span><span class="hljs-punctuation">:</span><span class="hljs-number">8082</span>;<br>        server <span class="hljs-number">192.168</span><span class="hljs-number">.110</span><span class="hljs-number">.112</span><span class="hljs-punctuation">:</span><span class="hljs-number">8083</span>;<br>    <span class="hljs-punctuation">&#125;</span><br>    <br>    server <span class="hljs-punctuation">&#123;</span><br>    listen <span class="hljs-number">80</span>;<br>        location / <span class="hljs-punctuation">&#123;</span><br>            proxy_pass http<span class="hljs-punctuation">:</span><span class="hljs-comment">//backend;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面配置的意思是：Nginx 监听 80 端口，并对所有 80 端口的请求转发给 <code>backend</code>，<code>backend</code> 里面又配置了三个服务，这三个服务就是上面用三种方式开启的。由于没有配置具体的转发规则，因此 Nginx 会使用默认的负载均衡机制轮询，即请求在三个服务之间均匀分布。详细的负载均衡机制点击<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">这里</a>。</p><p>由于 Nginx 是 Docker 启动的，因此需要把本地编写的配置文件映射到 Docker 容器内部，使用 <code>-v</code> 参数。最后 Nginx 的启动命令如下，其中 <code>--restart=always</code> 表示 Nginx 遇到错误会自动重启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --restart=always -v /C/Users/Administrator/Desktop/nginx.conf:/etc/nginx/nginx.conf -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>启动完成后，本机上所有的 80 端口请求都会交给 Nginx 去处理，Nginx 把请求转发到对应的服务上，服务完成请求解析，执行相应过程，返回结果，流程结束。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>使用了 3 种方式部署 Java 项目，但还是推荐使用 Docker 方式。使用 Docker 编写好一个 Dockerfile，然后构建一个 Docker 镜像，要运行多个服务，使用该镜像启动多个容器即可，非常方便。</p><p>Docker 是未来的趋势，学习并使用 Docker 很有必要。最近打算使用 Docker 打造一个 Java 开发环境，理想的结果是本机使用 IDEA，其他所有的环境都在一个 Docker 镜像中，只需要让本机的代码和 Docker 内部的代码保持同步即可。</p><p>下一节搞个 Docker 基本概念介绍，以及理解并手动编写自己的 Dockerfile。</p>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 包管理</title>
    <link href="/2021/08/26/Java%20%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/26/Java%20%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>java 程序的本质就是在拼接命令行，如何拼接的细节，都由 ide 帮我们实现了。假如我们在程序中添加一个包，我们只需要 java -cp 后面补上包的位置，以及这个包依赖的其他包的位置。 当程序中引用的包越来越多时，带来传递性依赖也会越来越多，要在 Java -cp 后面一个个补上包的位置，并且保证不遗漏传递性依赖的包，并且还要保证包不能同名。这将是一比巨大的工作量，费时费力，还容易出错。</p><p>这个时候就需要使用包管理了。它的本质就是告诉JVM如何找到所需的第三⽅类库，以及成功地解决其中的冲突问题。</p><h2 id="JVM-加载包"><a href="#JVM-加载包" class="headerlink" title="JVM 加载包"></a>JVM 加载包</h2><p>首先，JVM 的工作被设计地相当简单：执行一个类的字节码，假如这个过程中碰到了新的类，就去加载它。</p><p>既然碰到新的类就会去加载，那么就存在一个问题：去哪里加载呢？</p><p><strong>类路径（Classpath）</strong></p><p>当 jvm 去找一个新的类时，就会到类路径（Classpath）中挨个去找，碰到 jar 包就会解压缩再去查找。<br>由于类的全限定类名（⽬录层级）唯⼀确定了⼀个类，因此 jvm 可以找到这个类。其中 jar 包本质上就是把许多类放在一起打的压缩包。</p><p><strong>包加载存在的一些问题</strong></p><ul><li><strong>传递性依赖。</strong>简单的解释就是，你依赖的类还依赖了别的类。例如：A -&gt; B -&gt; C，A 依赖 B，B 依赖 C。</li><li>Classpath hell。因为全限定类名是类的唯⼀标识，所以当多个同名类同时出现在Classpath中，就会出现问题。例如：当 classpath 中存在同名的但是不同版本的 jar 包，A-1.0.jar 和 A-1.2.jar。jvm 会根据声明顺序去选择执行，假如 A-1.0.jar 声明在前，jvm 就会加载 A-1.0.jar，而不使用 A-1.2.jar。如果 A-1.0.jar 中是存在安全风险，那么到时候程序运行到安全风险时，就会导致灾难性后果。</li></ul><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><h3 id="Apache-Ant"><a href="#Apache-Ant" class="headerlink" title="Apache Ant"></a>Apache Ant</h3><p>Apache Ant 解决了部分包管理的问题。通过⼿动下载 jar 包，放在⼀个⽬录中。然后写XML配置，指定编译的源代码⽬录、依赖的jar包、输出目录等。</p><p>这样做带来的缺点是什么呢？</p><ul><li>每个人都要自己造一套轮子库</li><li>依赖的第三⽅类库都需要⼿动下载，费时费力。依赖的第三方类库越多，越麻烦。</li><li>没有解决 Classpath hell 问题。即，还是可能存在包同名的问题。</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="Maven-包管理"><a href="#Maven-包管理" class="headerlink" title="Maven 包管理"></a>Maven 包管理</h4><p>Maven 是划时代的包管理工具，但是 Maven 能做的远不止包管理。 </p><p>Maven 的理念是约定优于配置，默认的 Maven 项目结构都是一样的。Maven 具有中央仓库，包都是按照一定约定存储的。Maven 还有本地仓库，默认是位于 <code>~/.m2</code> 。当我们引入一个依赖时，Maven 就会根据填写的信息找到对应的包，并把它下载到本地仓库，下载到本地仓库之后，下次再有相同的包，则直接从本地仓库找。</p><p>Maven 的包按照约定为所有的包编号，方便检索。例如要在项目中引入 fastjson.jar </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.75<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 通过 groupId &#x2F; artifactId &#x2F; version，来定位唯一的包。开发过程中只需要在 pom.xml 文件添加包相应的信息即可。</p><p>其中 version 中的版本 1.2.75 是有一个规约的，1表示主版本号，2表示此版本号，75表示修订号</p><ol><li>主版本号：当你做了不兼容的 API 修改。</li><li>次版本号：当你做了向下兼容的功能性新增。</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><h4 id="Maven-的传递性依赖以及包冲突"><a href="#Maven-的传递性依赖以及包冲突" class="headerlink" title="Maven 的传递性依赖以及包冲突"></a>Maven 的传递性依赖以及包冲突</h4><p><strong>maven 传递性依赖的⾃动管理原则：绝对不允许最终的 classpath 出现同名不同版本的jar包</strong></p><p><strong>maven 解决传递性依赖</strong></p><p>当我们引入相关的包时，maven 会帮我们下载这个包，<strong>并且把他的传递性依赖的包都下载下来。</strong>因此，在 maven 中我们不需要去管理包的传递性依赖问题，maven 都会帮我们处理好。 </p><p><strong>maven 解决传递性依赖带来的包冲突问题</strong></p><p>假设你的项目有以下依赖。A 依赖 C，C 依赖 D 的0.2版本；B 依赖 D 的 0.1版本。<br> <img src="/../picture/Java%E5%8C%85%E7%AE%A1%E7%90%86/90d36004-cdb8-47f4-9707-1c5d3ef77706.png" alt="image.png"></p><p>如果按照图上所示，把所有的包都下载，势必会造成前面的 Classpath hell 问题，因为两个包 D 同名了。首先，maven 会根据包的 groupId 和 artifactId 来判断是否为同一个。存在相同的包 maven 就会帮我们自动解决。</p><p>maven 解决的原则就是：离项目最近的胜出，如果一样近，则靠前声明的胜出。回到图中，D-0.2 离项目的距离是3，而 D-0.1 离项目的距离是2，因此 D-0.2就会被 maven 剔除，classpath 路径中只存在 D-0.1。maven 解决冲突的做法，在大部分情况下是可行的，但也有不行的时候。假设项目中使用了 D-0.2 中的 API，由于 D-0.1 是旧版，没有相同的 API，maven 根据原则，帮我们把 D-0.2 剔除了，这个时候项目启动就会报错了。</p><p><strong>手动解决包冲突</strong></p><p>当遇到上诉情况就需要我们手动来解决冲突问题。</p><ol><li>首先我们要对比冲突包的区别，判断项目实际上所需要的包（maven 中央仓库找到冲突的包，通过查看源代码进行对比）</li><li>确定了所需要的版本之后，可以使用如下方法进行解决<ul><li>方法一：根据 maven 的解决原则，最近的胜出，我们可以直接在项目中引入一个 D-0.2 版本，此时 D-0.2 离项目的距离是1，所以会使用 D-0.2。</li><li>方法二：指定 maven 排除不需要的包，把不需要的依赖排除掉，剩下需要的依赖就可以了。使用exclusions，在 B 的 dependency 中排除掉 D 的依赖。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>**tips: ** 可以使用<code>Maven helper</code> 查看依赖树，也可以通过 <code>mvn dependency:tree</code> 命令查看依赖树。</p><p><strong>依赖的 scope</strong></p><p>我们经常可以在 pom 文件中看到以下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 groupId、artifactId、version 来定位这个包。scope 则是用来声明这个包在项目的作用范围。通常有这三个值<br><code>test</code> 、 <code>compile</code> 、 <code>provided</code> 。test 表示包作用在测试代码中，src&#x2F;test 目录下。compile 作用在源代码和测试代码中，并且编译和运行都有效。procided 作用在代码的编译期间，代码运行期间不生效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行的入门与详解</title>
    <link href="/2021/08/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是命令行"><a href="#什么是命令行" class="headerlink" title="什么是命令行"></a>什么是命令行</h1><p>操作系统都有内核的概念，内核是直接与硬件打交道的。我们通过包裹内核的一层壳（ shell ）来与内核打交道。</p><p><strong>广义的命令行包括一切通过字符终端控制计算机的⽅式</strong></p><ul><li>Windows - cmd&#x2F;PowerShell&#x2F;Git bash </li><li>UNIX&#x2F;Linux系列：sh&#x2F;zsh&#x2F;Terminal, etc.</li></ul><h1 id="为什么需要命令行"><a href="#为什么需要命令行" class="headerlink" title="为什么需要命令行"></a>为什么需要命令行</h1><ul><li>因为基本所有公司的服务器都运⾏在 Linux 上 ，所以不得不用</li><li>将工作自动化（暂时没有接触到的领域）</li><li>相比 GUI，命令行更容易开发维护，bug 更少</li><li>远程连接命令行占用资源远低于 GUI</li><li>命令行上的开发者工具更丰富</li></ul><h1 id="不同平台命令行启动方式"><a href="#不同平台命令行启动方式" class="headerlink" title="不同平台命令行启动方式"></a>不同平台命令行启动方式</h1><ul><li>Windows：cmd&#x2F;PowerShell&#x2F;WSL </li><li>UNIX&#x2F;Linux：⼀开机就是，不⽤找。Mac OS 对应的是终端。</li></ul><h1 id="命令行的全部要素"><a href="#命令行的全部要素" class="headerlink" title="命令行的全部要素"></a>命令行的全部要素</h1><p><strong>命令是由可执行程序和参数组成的。</strong>例如：git add test.txt，git 就是<strong>可执行程序</strong>，git 后面所有的都是<strong>参数，</strong>即 <code>add test.txt</code> 。命令行输入命令，会把参数原封不动地交给可执行程序解释。</p><h2 id="可执行程序（Executable）"><a href="#可执行程序（Executable）" class="headerlink" title="可执行程序（Executable）"></a>可执行程序（Executable）</h2><p>什么样的东西是可执行的呢？在 Windows 和 Linux &#x2F; Unix有着不同的区别</p><ul><li>Windows：只要是 exe &#x2F; bat &#x2F; com 结尾的文件都是可执行文件</li><li>LIunx &#x2F; Unix：文件有 <strong>x 权限</strong>，表示该文件为可执行文件</li></ul><p><strong>可执行程序的位置</strong></p><ul><li>Windows：Path 环境变量或当前⽬录 </li><li>UNIX &#x2F; Linux：PATH 环境变量</li></ul><p><strong>可以在脚本的第一行指定解释器（shebang）</strong>，假设 zzf.sh文件中有如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/env node</span><br>console.log(123)<br></code></pre></td></tr></table></figure><p><code>#!/usr/bin/env node</code> 意思是在 PATH 环境变量找到 node 解释器位置，来解释 zzf.sh 文件。也可以使用 node.exe 文件的绝对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/d/node</span><br>console.log(123)<br></code></pre></td></tr></table></figure><p>从环境变量找解释器和使用绝对路径是等价的，但是一般都是从环境变量去找，更为灵活。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>UNIX 参数的约定</strong></p><ul><li>使用一个 “-“ 后面只能跟一个字符，例如：-a -f  等等。后面跟多个参数的话可以合并，例如：-a -f 合并成 -af</li><li>使用两个 “-“ 后面可以跟一个单词，例如： <code>ls -a</code>  显示所有文件，等价于 <code>ls --all</code></li></ul><p> </p><p>然而，Java 并不鸟 UNIX 参数约定，例如：当我们查看当前 Java 版本，使用命令 <code>java -version</code> ，一个 “-“ 后面跟了一个单词，与 UNIX 参数约定不符</p><p><strong>参数一些注意事项</strong>默认情况下 “$” 符号会进行展开。假设当前目录存在一个 <code>main$A.class</code> 文件，并且 <code>export A=123</code> 设置环境变量 A 为123， 使用 <code>Java main$A</code> 运行该文件，等价于 <code>Java main123</code> 。即，把 $A 替换成 123，如果不进行替换，就要使用单引号包裹起来，即 <code>Java &#39;main$A&#39;</code> 。双引号包裹内容也会进行替换。</p><p><strong>因此得出以下结论</strong></p><ul><li>单引号：不会对引号的内容做处理</li><li>双引号：对引号里的内容替换</li><li>空格：当做参数处理</li></ul><h2 id="环境变量（Environment-variable）"><a href="#环境变量（Environment-variable）" class="headerlink" title="环境变量（Environment variable）"></a>环境变量（Environment variable）</h2><ul><li>进程（Process）<ul><li>进程是计算机程序运⾏的最⼩单位 </li><li>独占⾃⼰的内存空间和⽂件资源</li></ul></li><li>每个进程都和⼀组变量相绑定 <ul><li>传递不同的环境变量可以让程序表现出不同的⾏为 </li><li>CLASSPATH&#x2F;GOPATH</li></ul></li><li>在进程的fork过程中，环境变量可以被完全继承</li><li>所有的操作系统&#x2F;编程语⾔都⽀持环境变量 </li><li>局部和全局的环境变量<ul><li>局部变量：只在当前环境生效</li><li>全局变量：全局生效的变量</li></ul></li></ul><p>我们可以通过 export &#x2F; set 设置环境变量，通过 echo 读取环境变量 。修改全局变量就需要在全部变量文件中修改，不同操作系统对应的文件不同。</p><h2 id="工作目录（Working-directory）"><a href="#工作目录（Working-directory）" class="headerlink" title="工作目录（Working directory）"></a>工作目录（Working directory）</h2><p><strong>工作目录就是输入命令行时，所处的目录即为工作目录。绝对路径是以根目录开头的路径，相对路径是相对于当前目录的路径。</strong></p><h1 id="进程的输入与输出"><a href="#进程的输入与输出" class="headerlink" title="进程的输入与输出"></a>进程的输入与输出</h1><p>标准输⼊ stdin ，进程将从标准输入中得到输入数据。例如使用 <code>rm -rf *</code> 命令，会提示是否确认删除，当我们回复y 的时候，就时一个标准输入。</p><p><strong>输出的重定向</strong>，我们可以使用 “&gt;” 符号来重定向输出，例如在终端输入 <code>date +&quot;%Y-%m-%d %H:%M:%S&quot; &gt; output.txt</code> ，就是将<strong>标准输出</strong>重定向到 output.txt 文件中，若再次运行该命令，会将之前的 output.txt 文件覆盖 。使用 “&gt;&gt;” 可以将标准输出追加到 output.txt 文件中。</p><p><strong>标准输出 stdout</strong> 和<strong>标准错误 stderr <strong>相当于一个进程的两个管道。标准输出对应着文件描述符1，标准错误 对应着文件描述符2。假设我们要将一个</strong>进程的标准输出重定向</strong>到 output.txt 文件中，我们可以使用 <code>命令 &gt; output.txt</code> 或者 <code> 命令 1&gt; output.txt</code> 。同理类推，将<strong>进程的标准错误重定向到</strong> error.txt 文件，可以使用    <code>命令 2&gt; error.txt</code> 。要让标准输出和标准错误都重定向到 output.txt 文件，使用 <code> 命令 &gt; output.txt &gt; 2&gt;&amp;1</code> 。该命令代表的意思是，先将2（标准错误），重定向到1（标准输出），再把结果重定向到 outout.txt 文件。</p><p><strong>&#x2F;dev&#x2F;null</strong> 相当于一个垃圾桶的概念，可以把标准输出或者标准输入重定向到该文件。 <code> 命令 &gt; /dev/null</code> 即把标准输出丢到垃圾桶里，相当于黑洞一般，把标准输出给「吞」了。</p><h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><p>任何一个 UNIX 文件都有9位，分成3组，分别是自己（文件创建者），同用户组的人，不同用户组的人。每一组都有 rwx，r 代表读（read），w 代表写（write），x 代表可执行。</p><p>假设有一个需求，我们要当前文件只能被当前用户读写执行。就需要把自己组的 r 设置为1，w 设置为1，x 设置为1，其他组的 rwx 都设置为0，设置完成后对应的二进制分别是 <code>111 000 000</code> ，对应的十进制就是 <code>700</code> ，因此使用 <code>chmod 700 当前文件</code> 即可赋予当前用户读写执行权限。</p><p>根据上面的结论，我们需要给所有用户可读可写可执行权限，就需要把所有组的 rwx 设置为1，得到的二进制就是 <code>111 111 111</code> ，对应的十进制为 <code>777</code> ，因此 <code>chmod 777 当前文件</code> 表示为所有用户，赋予可读可写可执行权限。</p><h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><ul><li>进⼊⽬录 cd (change directory) </li><li>展示⽂件 ls&#x2F;ll&#x2F;ls -alth (list) </li><li>移动&#x2F;重命名⽂件 mv (move) </li><li>删除⽂件 rm&#x2F;rm -r&#x2F;rm -rf (remove) </li><li>拷⻉⽂件 cp&#x2F;cp -r (copy) </li><li>显示变量 echo </li><li>导出变量 export </li><li>Git系列操作 git pull&#x2F;push&#x2F;add&#x2F;commit&#x2F;…</li><li>新建⽬录 mkdir&#x2F;mkdir -p (make directory) </li><li>当前⽬录 pwd (print working directory) </li><li>显示⽂件 cat (concatenate and print files)</li><li>编辑⽂件 vi</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 依赖与插件解析机制</title>
    <link href="/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>劝退提醒</strong>：不了解 maven 坐标机制，没有使用过 maven 插件，不了解 maven 插件命令的，可以关闭文章了。</p><p>我们经常在项目中引入包，使用 <code>&lt;dependency&gt;</code> 标签，然后填写包的坐标信息， Maven 就可以帮我们引入该 jar 包。当本地存在该 jar 包时，就从本地引入该 jar 包，否则就从远程仓库引入。</p><p>这背后的解析机制是什么呢？</p><h2 id="依赖解析机制"><a href="#依赖解析机制" class="headerlink" title="依赖解析机制"></a>依赖解析机制</h2><p>依赖解析的背后机制可以概括如下：</p><ol><li><p>依赖范围是 <code>system</code>，maven 就会从本地加载该 jar 包，完成构建。</p></li><li><p>正常解析依赖坐标，先去本地仓库找，找到就完成构建。</p></li><li><p>本地找不到，并且显示的指定了版本信息，就去远程仓库中遍历，找到并下载解析。</p></li><li><p>如果依赖的版本信息并没有指定，而是使用 <code>RELEASE</code>或者 <code>LATEST</code>，他会找到远程仓库的<strong>元数据</strong>和本地的元数据进行合并，然后计算出真正的版本号。元数据指的就是仓库中 <code>groupId/artifactId/maven-metadata.xml</code>文件，例如我们打开 guava 包的元数据。元数据位置就在 com.google.guava&#x2F;guava 包下，打开可以看到如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">metadata</span> <span class="hljs-attr">modelVersion</span>=<span class="hljs-string">&quot;1.1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">versioning</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">latest</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">latest</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">release</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">release</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r03<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r05<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r06<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r07<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r08<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r09<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lastUpdated</span>&gt;</span>20210319161151<span class="hljs-tag">&lt;/<span class="hljs-name">lastUpdated</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">versioning</span>&gt;</span><br>&lt;/metadata<br></code></pre></td></tr></table></figure><p> 上面的信息展示了 latest，release 对应的版本号，以及 guava 包的历代版本号，以及最近一次更新时间。例如我们引入 guava，并使用 latest 版本，maven 就会合并元数据，然后计算出 latest 对应的版本号，然后从本地仓库找到改版本的 guava，没有则去远程仓库下载。</p></li><li><p>依赖的版本是 SNAPSHOT，则同样获取远程元数据与本地合并，计算版本信息，获取对应版本的包。</p></li><li><p>如果依赖版本为时间戳的快照版本，就会先转换成非时间戳的快照版本，然后去解析下载。</p></li><li><p>maven 3 中如果不指定 version，则默认解析使用 RELEASE 版本。</p></li></ol><h2 id="插件解析机制"><a href="#插件解析机制" class="headerlink" title="插件解析机制"></a>插件解析机制</h2><p>我们常用的 maven 插件命令都是 <code>mvn dependency:tree</code> <code>mvn flyway:migrate</code>，诸如此类的，他们的格式都是 <code>mvn 插件前缀:目标</code>。</p><p>为了方便用户使用和配置插件，maven 不需要用户提供完整的坐标信息，就能解析得到正确的插件。那么问题来了，maven 是怎么确定插件的坐标和版本的呢？例如 <code>mvn dependency:tree</code> 他执行了什么插件，插件坐标版本信息是什么？</p><p>插件的解析机制和依赖解析机制基本一致，不同的是远程仓库不一样。配置插件的远程仓库地址需要使用 <code>&lt;pluginRepository&gt;</code> 标签配置，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了 <code>&lt;pluginRepositories&gt;</code>和 <code>&lt;pluginRepository&gt;</code>不同，其他的与依赖的仓库配置信息一致。</p><h3 id="默认的-groupId"><a href="#默认的-groupId" class="headerlink" title="默认的 groupId"></a>默认的 groupId</h3><p>在 pom 文件在红配置插件信息的时候，如果插件是 maven 官方的插件（groupId 为 org.apache.maven.plugins），就可以省略 groupId 的配置。如下是官方的 clean 插件配置，没有指定 groupId，但是解析坐标的时候会带上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在插件配置中，不推荐省略 groupId 的写法，但这与我们使用 maven 插件命令有关。</p><h3 id="省略版本信息"><a href="#省略版本信息" class="headerlink" title="省略版本信息"></a>省略版本信息</h3><p>maven 的核心插件都在超级 pom 中显示的声明了具体的版本信息，因此当这些插件未指定版本信息的时候，就会使用超级 pom 中指定的插件版本。</p><p>如果是非核心插件，且未指定版本信息。在 maven2 中默认解析至 latest，maven3 默认解析至 release，具体的解析过程与依赖解析一致，都是根据合并计算元数据，得到具体的版本信息。</p><h3 id="插件前缀解析"><a href="#插件前缀解析" class="headerlink" title="插件前缀解析"></a>插件前缀解析</h3><p>我们使用命令 <code>mvn dependency:tree</code> 插件前缀是 dependency，我们是如何根据这个前缀信息得到该插件的完整坐标呢？</p><p>这就需要结合上面的知识了，首先存在一个保存 groupId 和 artifactId 对应关系的文件 maven-metadata.xml，该文件存在 groupId &#x2F; maven-metadata.xml。由于上面的 dependency 是官方插件，因此 groupId 为 <code>org.apache.maven.plugins</code> ，我们去远程仓库找到该文件，如下图。</p><p><img src="/../picture/Maven%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/91808d7d-667b-4874-bf53-33765521e002.png" alt="image.png"></p><p>我们可以找到插件前缀 dependency 对应的 articfactId 是 <code>maven-dependency-plugin</code>，因此插件的完整坐标可以确定了。</p><p><strong>获取 groupId</strong></p><p>这里还有个问题，因为我们是提前知道 dependency 是官方的插件，可以推出他的 groupId ，但是 maven 是怎么知道它的 groupId 呢？</p><p>maven 的主要插件都在 <code>[https://repo1.maven.org/maven2/org/apache/maven/plugins](https://repo1.maven.org/maven2/org/apache/maven/plugins)</code>和<code>[https://repository.codehaus.org/org/code-haus/mojo](https://repository.codehaus.org/org/code-haus/mojo)</code>下，他们对应的 groupId 分别是 <code>org.apache.maven.plugins</code> 和 <code>org.codehaus.mojo</code>。maven 解析插件的时候就会默认使用这两个 groupId 去匹配，检查 org&#x2F;apache&#x2F;maven&#x2F;plugins&#x2F;maven-metadata.xml，org&#x2F;codehaus.momjo&#x2F;maven-metadata.xml 文件，判断是否有匹配的插件前缀，如果有则获取对应的坐标信息，完成解析。</p><p>倘若想使用的插件是第三方的，就可以通过配置 setting.xml 文件，让 maven 也检查其他 groupId 上的仓库 metadata.xml 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>第三方仓库 groupId<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><p>解析 dependency:tree 命令</p><ol><li><p>先使用默认的和配置的第三方的  groupId 去找到对应的 <code>maven-metadata.xml</code>文件，然后检查是否包含 dependency 前缀信息。</p></li><li><p>包含前缀信息，获取对应 articfactId，不包含则使用下一个 groupId 的 maven-metadata.xml 文件。如果所有都获取不到，则报错。</p></li><li><p>获取到 articfactId 之后根据上面 <a href="#Ueudm">获取版本信息</a>，即可得到完整的坐标，完成解析执行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2021/08/11/String/"/>
    <url>/2021/08/11/String/</url>
    
    <content type="html"><![CDATA[<p>首先我们要有一个概念，互联网基本上就只干一件事「处理字符串」。我们看的纷繁复杂的网页，都是通过字节传输的，然后经过一个指定的编码转化成人类能看懂的字符串。因此能处理好字符串是 Web 服务器的基本要求，像 Java，PHP，Python，Ruby等。</p><h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p>背过一些八股文面试题的人都知道 String 是不可变的，那么问题来了，「不可变的定义是什么？」，「String 是如何保证不可变的呢？」</p><p><strong>不可变性</strong>，当创建一个<code>String s = &quot;abcd&quot;</code>对象的时候，JVM 的堆内存就生成了一个 String 对象，并且它的值是 abcd，而 s 变量只是指向这个对象。我们说的不可变性指的就是 JVM 生成的对象值不可变，比如刚才的 abcd，创建出来之后它就一直都是 abcd，无法被改变。</p><p>经常使用字符串的人开始疑惑了，那我 <code>String s = &quot;abcdel&quot;</code>不是也可以吗？String 的值不是改变了吗？</p><p>的确，我们是可以给 s 这个变量重新赋值。但是我们给他赋值实际上是 JVM 新创建了一个值为 abcdel 的 String 变量，然后变量 s 从指向值为 abcd 的对象，改为指向值为 abcdel 的对象。原来值为 123 的对象还是存在 JVM 中，并且值并没有改变，只是暂时没有变量指向这个对象罢了。上面的操作，可以用如图所示。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/picture/String/ea0bb048-f46d-4e83-abb9-de31bd9a694d.png" alt="image.png"></h3><p>了解上面的知识后，回到新的问题上来，<strong>String 是如何保证不可变性呢？</strong></p><p>打开 String 的源代码，我们可以发现，String 类以及它的字符数组变量都是被 final 关键词修饰的。这就意味着 String 无法被继承，并且 char[] value 的地址指向无法修改，而且 String 所有的公开 API 都没有修改 char[] value 的方法，这就保证了 String 的不可变性。</p><p><img src="/picture/String/632458ad-4ea5-42bf-b25a-9c0262d646c4.png" alt="image.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>线程安全</strong>，不可变的对象天生就是线程安全的，可以随心所欲的在线程之间传递。</p><p><strong>存储安全，</strong>为什么说是存储安全呢？因为遵守了 hashCode 的约定。</p><p>正是因为 Stirng 的不可变性，才能实现存储安全。我们可以想象一下有一个 <code>Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</code>，假如 String 是可变的话，那么就违反了 hashCode 的约定，想了解 hashCode 的相关约定<a href="https://www.yuque.com/alipayygdprovgrb/uc535m/mdqx4t">访问这里</a> 。</p><p>如图所示，有三个字符串 “a”，”c”，通过计算分别得到了对应的 hashCode。如果 String 是可变的行不行呢？我们可以通过反证法来证明。现在假如 String 是可变的，那么当字符串从 a 变成了 c（即 <code>String a = &quot;a&quot; 到 a = &quot;c&quot;</code> ），他的 hashCode 要不要改变呢？分两种情况。</p><p><img src="/picture/String/1304755d-ad8a-4838-8262-6e408d0c7787.png" alt="image.png"></p><p>如果<strong>不改变 hashCode</strong>，那就违反了 hashCode  的第二条约定「两个对象 equals 方法为 true，则生成的 hashCode 相等」。显然 <code>a.equals(c)</code> 为true，按照约定 a 和 c 的 hashCode 应该相等。但我们的前提是 a 的 hashCode 不改变，因此 a 和 c 的 hashCode 并不相等，前后矛盾。</p><p>如果<strong>改变 hashCode</strong> ，那么就违反了 hashCode 的第一条约定「两个对象相等，hashCode 也相等」。例如我们通过如下代码让 a 和 c 为同一个对象，此时的 a &#x3D;&#x3D; c。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>如果此时 a 改变了值，hashCode 也会跟着变化。但是 a &#x3D;&#x3D; c 依然为 true，因为他们所引用的内存地址都是相同的。hashCode 规定对象相等返回相同的 hashCode ，而我们的前提是值改变，hashCode 改变，也是前后矛盾。</p><p>通过反证法，证明了 String 必须是不可变的，才能达到存储安全的目的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每当想修改字符串的时候，都必须创建新的对象来维持它的不可变性。比如下面这个循环，循环 10 次，就创建了 10 个对象，当循环次数上升到一定程度，就会给内存管理带来巨大的压力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text + i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当我们想创建值相同的两个 String 对象，有以下三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>我们分别用 &#x3D;&#x3D; 和 equals 方法来判断 a，b是否相等，三种方式输出的结果分别会是什么呢？</p><p>方法一，a，b 的值都是 “123”，因此很简单，<code>a.equals(b)</code>肯定为 true，那么 <code>a == b</code> 呢？答案是 true。因为有「字符串常量池」的存在，当 a 创建出来，字符串常量池创建 “123” 这个字符串常量，当 b 赋值的时候，发现字符串常量池中已经有相同的对象，因此直接让 b 指向这个对象，此时 a 和 b 都指向同一个对象。如图</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/picture/String/990942c9-60db-42ef-99c4-370f76819ce7.png" alt="image.png"></h3><p>方法二，a 和 b 都是通过 new 方法，各自声明了一个值为 “123” 的对象，因此这是两个不同的对象。所以，a &#x3D;&#x3D; b 为 false，a.equals(b) 为 true。此时的 a 和 b 是指向不同的对象的，虽然他们的值都是 123。</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/picture/String/d40d7eb9-b7c9-4f13-8720-de56aa0a2859.png" alt="image.png"></h3><p>方法三，a 赋值 b，把 a 的地址指向给 b一份。因此，a，b 两个变量都是引用同一个对象，因此 a&#x3D;&#x3D;b 为 true，a.equals(b) 也为 true。图中就是 a 指向的内存地址是 0x45，然后通过 <code>String b = a</code> b 得到 a 传来的地址，所以也指向 0x45 这个内存。</p><p><img src="/picture/String/2bb22221-4e5c-47cd-a667-e5f2eeec841e.png" alt="image.png"></p><h3 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h3><p>虽然 String 是不可变的，但是在实际生产中我们还是需要可变字符串，这要怎么解决呢？就拿上面那段循环代码来说，每次都要创建一个新的变量，循环次数多了必然占用过多内存。**StringBuilder **就是个可变字符串，因此我们可以使用 StringBuilder 来改进这段代码，这样就避免了创建多个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text.append(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuffer 也是可变字符串，与 StringBuilder 的区别是：StringBuilder 线程不安全，但是速度快；StringBuffer 线程安全，速度相对较慢。因此，要根据实际生产环境，选择合适的类，大多数情况优先使用 StringBuilder。</p><p>String，StringBuffer 和 StringBuilder 更多 API，请参考 Java 官方文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串与编码</title>
    <link href="/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <url>/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，在网络通信和存储的都是字节流，都是一大串的 0 和 1。不知道大家有没想过，存储既然是 0 和 1，为什么我们看到得都是一个个字符，汉子，英文？是不是计算机在背后偷偷的把字节转化成我们人类能看懂的语言？答案是肯定的。</p><h2 id="字符集相关概念"><a href="#字符集相关概念" class="headerlink" title="字符集相关概念"></a>字符集相关概念</h2><p>既然计算机帮我们把字节转成人类的语言，那么肯定存在着一种映射关系「字节 –&gt; 人类语言的映射」，我们把这种关系称为<strong>字符集</strong>。把字节转化成人类看懂的字符，这一过程称为<strong>编码</strong>，反之称为<strong>解码</strong>。</p><p>假如世界都用同一份字符集，同一种编码和解码方式那么就不会存在我们常见的「乱码」问题了。但正是因为世界多样性，也导致了字符集的多样性，每个国家语言不同，所使用的字符集，编解码方式也可能不同。</p><p>假如我们把阿拉伯数字看作字节，把不同语言的翻译看做编解码方式。因此，1，2，3 翻译成汉字就成了一，二，三；翻译成英文就成了 one，two，three。假如，本应该使用中文编码的字节，却使用了英文编码，这就会让没有学过英语的人看不懂，不懂 one，two，three 是什么，对于他们来说这就是<strong>乱码</strong>。</p><h2 id="字符集-Unicode"><a href="#字符集-Unicode" class="headerlink" title="字符集 Unicode"></a>字符集 Unicode</h2><p>在字符集群魔乱舞时代，有人站了出来。他把所有的地区性编码方案废弃，重新搞了一个<strong>包括了地球上所有文化、所有字母和符号的编码 Unicode</strong>。其中 uni 是英文前缀，表示「单一，一个」，因此 Unicode 的字面意思也很好理解，百度百科上翻译成「统一码，也叫万国码、单一码」。</p><p>Unicode 的设计非常的简单：<strong>从一个数字映射到一个字符</strong>。图中简单地演示了 unicode 的映射关系，实际上的对应关系并非如此。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../picture/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/7fb15bf0-053f-43e0-97cf-d914e64d4df8.png" alt="image.png"></h2><p>图中所示，把左边的数字编号称作<strong>码点</strong>（code point）。</p><h3 id="Unicode-数据类型"><a href="#Unicode-数据类型" class="headerlink" title="Unicode 数据类型"></a>Unicode 数据类型</h3><p>现在换位思考下，如果让你来设计 Unicode 码表，你会用什么数据类型来存储上面的数字编号呢？</p><p>现在来对比下这些数据类型关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> --&gt; <span class="hljs-number">0</span>~<span class="hljs-number">255</span> --&gt; <span class="hljs-number">256</span><br>    <br><span class="hljs-type">short</span> --&gt; <span class="hljs-number">2</span> bytes --&gt; <span class="hljs-number">65536</span><br>    <br><span class="hljs-type">int</span> --&gt; <span class="hljs-number">4</span> bytes --&gt; 约 <span class="hljs-number">42</span> 亿<br></code></pre></td></tr></table></figure><p>很显然 byte 不合适，256个数，存中文都不够。short 存中文可能勉强够用，但是这还要包含其他国家的文字啊，加起来肯定不够用。int 42 亿个，足够全世界的文字使用， 因此选用 int 类型，实际上 Unicode 也是这么做的。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>上面提到为了包含全世界所有的文字，Unicode 使用了 int 类型。int 4个字节，对于编号在前面的字符，就会造成空间浪费。例如编号为 1 的字符，把编号转换成字节就变成 “00000000  00000000  00000000 00000001”，我们会发现前三个字节都是 0，这样造成了空间浪费。本来一个字节就能表示的编号，硬是多占用了3个字节，编号靠后的还好，靠前的大多都浪费流量，浪费空间。</p><p>如图我们把前四位编码成 4 个字节，编码后的前三个字节都是 0。更何况Unicode 兼容了 ASCII 码表，前128 位都是常用的一些字符，本来字母 “a” 只需要占用一个字节，经过 Unicode 编码后需要占用 4 个字节，不利于传输和存储。</p><p><img src="/../picture/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/59ab9ba5-2ffa-416c-b1e8-2eef2d58c538.png" alt="image.png"></p><h2 id="常见的两种编码方案：UTF-8，UTF-16"><a href="#常见的两种编码方案：UTF-8，UTF-16" class="headerlink" title="常见的两种编码方案：UTF-8，UTF-16"></a>常见的两种编码方案：UTF-8，UTF-16</h2><p>正是因为 Unicode 对于靠前的码位太占空间了，所以就有了 UTF-8，UTF-16 等编码方案，用来解决空间占用问题。其实我们也很容易想到一种解决方案：把常用的字符用一个字节存储，不常用的用多个字节存储，这样就避免了 Unicode 缺陷</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 根据码位所处的范围进行不同编码。</p><p><strong>U+0000 至 U+D7FF 以及从 U+E000 至 U+FFFF 的码位</strong></p><p>第一个 Unicode 平面（码位从 U+0000 到 U+FFFF ）包含了最常用的字符。只要处于这个范围内，UTF-16 就使用两个字节存储它。我们的汉字基本上都是处于该范围，因此在 UTF-16 中，汉字大多都是两个字节。</p><p><strong>U+10000 至 U+10FFFF 的码位</strong></p><p>当处于码点处于该范围时，UTF-16 就使用 4 个字节进行存储。因此，UTF-16 将常用的字符用 2 个字节存储，不常用的用 4 个字节存储，相比 Unicode 空间节省了不少。</p><p><strong>一个简单的 UTF-16 编码过程</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">21608</span>  --&gt;  <span class="hljs-string">&quot;周&quot;</span>  <span class="hljs-comment">// 已知「周」字在 Unicode 的码位是 21608</span><br>------------------<br><span class="hljs-number">5468</span>     <span class="hljs-comment">// 转换成 16 进制</span><br></code></pre></td></tr></table></figure><p>「周」字的码位，转成 16 进制得到 5468，然后判断所属范围，很显然属于上面的第一种范围，因此「周」字需要两个字节存储 <code>54</code> <code>68</code>。我们可以在程序中打印出来 <code>System._out_.println(&#39;\u5468&#39;)</code>。</p><p><strong>BOM</strong></p><p>两个字节代表一个字符，在存储传输过程中存在着顺序问题。拿刚才的「周」字举例，虽然我们认为在传输过程中都是按照 <code>54 68</code>的顺序，但实际并非如此。在有的系统他是反过来传输的 <code>68 54</code>，为了解决这个问题，<strong>在文件的开头加入了几个不可见的字符，来声明字节顺序。这几个特殊字符称作 BOM（byte order mark），即字节顺序标记。</strong></p><p>上面的字节存储传输的方式，也有专业的名称<strong>。</strong>这个在编码中叫做大端（<strong>Big Endian 简写 BE</strong>）和小端（<strong>Little Endian 简写 LE</strong>）。在很多文本编辑器也有出现，比如我在使用的 Notepad2，就支持 UTF-16 LE BOM 和 UTF-16 BE BOM 编码方式。</p><p>顺带一说的是，Java 程序内部的存储编码方式就是 UTF-16。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>先说一个结论：<strong>如果没有意外，所有的编码方案都改成 UTF-8，UTF-8 是对多语言支持最好的一种解决方案</strong>。在 Mac&#x2F;Linux 默认编码就是 UTF-8，由于历史原因，Windows 默认的中文编码是 GBK。</p><p>UTF-8 是一种可变长的编码方式，那它是怎么做的呢？他对所有的码表进行分区，第一个分区占用一个字节，第二个占用两个字节，以此类推，最多支持到 6 个字节。UTF-8 兼容了 ASCII 码表，因此 ASCII 码表的字符在UTF-8 中占用一个字节，属于下面第一行的范围。我们使用的汉字，属于第三行的范围，因此汉字在 UTF-8 中编码占 3 个字节。下面展示了从 1 到 4分区范围。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">U+ <span class="hljs-number">0000</span> ~ U+  <span class="hljs-number">007</span>F<span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>XXXXXXX<br>U+ <span class="hljs-number">0080</span> ~ U+  <span class="hljs-number">07</span>FF<span class="hljs-punctuation">:</span> <span class="hljs-number">110</span>XXXXX <span class="hljs-number">10</span>XXXXXX<br>U+ <span class="hljs-number">0800</span> ~ U+  FFFF<span class="hljs-punctuation">:</span> <span class="hljs-number">1110</span>XXXX <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX<br>U+<span class="hljs-number">10000</span> ~ U+<span class="hljs-number">10</span>FFFF<span class="hljs-punctuation">:</span> <span class="hljs-number">11110</span>XXX <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX<br></code></pre></td></tr></table></figure><p>例如：「周」字的码位 21608，转换成 16 进制 5468 属于第三行的范围，根据他的编码规则会生成 3 个字节，编码过程如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">5</span>     <span class="hljs-number">4</span>     <span class="hljs-number">6</span>     <span class="hljs-number">8</span><br> <span class="hljs-number">0101</span>  <span class="hljs-number">0100</span>  <span class="hljs-number">0110</span>  <span class="hljs-number">1000</span>    对应的二进制<br>---------------------------<br> <span class="hljs-number">0101</span>    <span class="hljs-number">010001</span>   <span class="hljs-number">101000</span>   根据第三行的模板，每个字节中 <span class="hljs-string">&quot;x&quot;</span> 的数量分成三组<br><span class="hljs-number">1110</span>XXXX  <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX   第三行模板<br><span class="hljs-number">11100101</span>  <span class="hljs-number">10010001</span> <span class="hljs-number">10101000</span>   代入模板<br>   E5        <span class="hljs-number">91</span>       A8     <br></code></pre></td></tr></table></figure><p>不知道大家有没思考过一个问题：UTF-8 编码之后，计算机怎么知道该读几个字节？例如上面的 <code>11100101  10010001 10101000</code>计算机怎么知道这 3 个字节是一起的，而不是分 3 次读单个字节呢？</p><p>其实仔细观察分区之后的模板就能发现端倪，第一分区首字节的第一位是 0，第二分区首字节前两位两个 1，第三个分区有三个1，计算机就是根据这个特点来进行读取的，当读到第一个字节前几位有几个 1 就读几个字节。刚才的「周」第一个字节有三个 1，因此计算机就连续读三个字节。由于这一特性，UTF-8 是不需要 BOM 的，但是 windows 的记事本默认都会加上 BOM，不支持不带 BOM 的编码（最近好像支持了），UTF-8 带</p><p>这个模板是如何设计生成的呢？编解码的算法是如何实现的呢？这里不展开（主要是我也不会），<a href="https://www.wikipedia.org/">维基百科</a>搜 UTF-8 就好了（推荐），或者访问<a href="https://taoshu.in/c-utf-8.html">他人博客</a>，了解相关内容。</p><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>GBK（国标扩展） 字符集，简称国标扩。GBK 完全不鸟 Unicode 标准，对于中文统一采用 2 个字节编码，因此在 GBK 编码中汉字是占用两个字节。</p><p>乱码的来源也与 GBK 有关，如果文件是用 Unicode 字符集编码，而你却使用 GBK 去解码，就会导致乱码问题。比如「周」字，在 Unicode 的码位是 21608，而在 GBK 的码位是 55004，通过去查 GBK 码位 21608 对应的字符就不是 「周」这个字了。</p><p>现在互联网的主流都是使用 UTF-8 编码，GBK 只适合给国人使用的网站上，局限性太大。</p><h2 id="简单的测试"><a href="#简单的测试" class="headerlink" title="简单的测试"></a>简单的测试</h2><p><strong>测试 1</strong>：一份用 UTF-16 编码的全英文文本，更改编码方式为 UTF-8，存储占用会减少吗？答案是会，因为 UTF-16对英文用两个字节编码，而 UTF-8 中英文属于第一分区，因此占用一个字节，所以改为 UTF-8 之后差不多减少一半的空间占用。</p><p><strong>测试 2</strong>：一份用 UTF-8 编码的全汉字文本，更改编码方式为 UTF-16，和 GBK，存储占用会发生什么变化？答案是都会减少占用，GBK 对中文是两个字节编码，UTF-16 对大多数中文也是两个字节编码，而 UTF-8 对中文是 3 个字节编码，因此占用会减少。</p><h2 id="一些小感悟"><a href="#一些小感悟" class="headerlink" title="一些小感悟"></a>一些小感悟</h2><p>写这篇博客的时候，遇到很多问题，本来只是想写 UTF-8 和 Unicode 的，越往下写的时候发现还有很多东西没有掌握，因此一边消化（幸运的是消化难度还能接收），一边写了这篇博客，终于是把字符，乱码相关的搞明白了。</p><p>当我感叹 UTF-8 编解码算法的时候，搜了下发明者<a href="https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A"> Ken Thompson</a>，这么多优秀的作品都与他有莫大的关联，Unix，正则，UTF-8，以及现在火热的 Go 语言，还获得图灵奖，我也只能顶礼膜拜。了解的越多，发现了计算机领域基本上所有伟大的东西，都是那么一小撮人发明的。如图是 Ken Thompson 相关的简介，想具体了解可以去维基百科搜索。</p><p><img src="/../picture/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/61ce26eb-3169-4168-bb62-c1a1929f4bcb.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常体系</title>
    <link href="/2021/05/27/Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <url>/2021/05/27/Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，离开方法的手段可以 靠 return 方法返回，而<strong>异常是 return 方法之外，离开方法的手段</strong>。</p><p>在实际工作中，经常会遇到空指针、找不到、文件找不到，等等不计其数的异常情况。那么 Java 中如何处理这些异常呢？</p><h2 id="try-x2F-catch-x2F-finally"><a href="#try-x2F-catch-x2F-finally" class="headerlink" title="try &#x2F; catch &#x2F; finally"></a>try &#x2F; catch &#x2F; finally</h2><p>当对一个文件进行写入操作的时候，所使用的 IDE 就会提醒，可能存在异常，需要处理。于是我们按照 IDE 的提示，编写了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\1.txt&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>     &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>代码主要分成两部分：try 包裹的部分，以及 catch 包裹部分，其中 catch 专门用来捕获异常。</p><p>其中 try 包裹的，表示可能运行会出错的代码。上面的代码通过 File，构建一个输出流，由于 File 对应的文件不一定存在，导致构建输出流失败，出现异常。因此，构建输出流的代码就要放到 try 中包裹起来。</p><p>catch 包裹的代码，就是对异常进行处理的流程。上面的代码是将错误信息打印到<strong>标准错误流</strong>中。</p><p>一般异常处理使用 try-catch 语句就足够了，但有遇到加载文件资源的情况，使用完之后就需要及时关闭。也许你会想把关闭资源操作放在 try-catch 语句之后，这也是可以的。但是，一旦 try-catch 中有return 操作，导致代码无法往下执行，关闭资源也就失效了。</p><p><code>finally</code>就是解决这个问题的，无论 try-catch 中如何返回，如何调用，它包裹的代码块都会执行。在 catch 语句后加上 finally，以及包裹的代码，这样就完成了一套标准的异常处理流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">//执行资源清理操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：如果 try 中可能存在多种类型异常，我们就需要多个 catch 来捕获他们。</p><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>在上面的代码中提到资源清理操作，在生产过程中，可能不止一个资源需要清理，我们需要进行多个资源关闭操作，难免会忘记对些资源清理。因此，在 Java 7 中就引入了 <code>try-with-resources</code>这个语法糖。</p><p>原先我们关闭资源操作写在 finally 中，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            os.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在我们把 <code>OutputStream os = new FileOutputStream(file)</code>声明在 try 后面的括号里，声明在里面的东西它会帮我们自动关闭，因此 <code>finally</code> 语句也不用写了。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file)) &#123;<br><br>       &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           e.printStackTrace();<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>那么问题来了，什么类型的资源会自动关闭呢 ？</p><p>答案就是<strong>所有实现了</strong> <code>AutoCloseable</code> <strong>这个接口的类</strong>，都能被自动关闭。比如上面的 <code>FileOutputStream</code>就实现了这个接口。当然智能的 IDE 在我们写 try-catch 的时候都会 给与提示，告诉你可以转成 try-catch-resources模式 </p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>上面使用 try-catch 捕获异常，但实际生产环境中也需要抛出异常，不在当前方法处理。手动抛出异常，需要用到关键字 <code>throw</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br> &#125;<br></code></pre></td></tr></table></figure><p>上面代码抛出了一个异常，但没有使用 try-catch 捕获处理。仔细观察的话，你会发现 openFile 方法后面多出了<code>throws Exception</code>，它的意思声明 openFile 方法可能会抛出异常。</p><p>那为什么要声明异常呢？直接抛出异常不行吗？</p><p>这就源于 Java 的「保护机制」，如果你的方法中可能存在异常，要么使用 try-catch 将它捕获处理，要么就使用 throws 给当前方法声明异常。任何调用了声明异常的方法，都需要处理传过来的异常，与前面一样，要么 try-catch，要么继续声明异常等待其他方法调用处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       A();<br>   &#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，B 调用 A 方法，A 方法没有 try-catch，而是使用 throws 声明异常。因此，B 方法就有两种选择，要么 try-catch 处理 A 抛出的异常，要么选择像 A 一样，声明一个异常继续向上抛出。显然 B 是同 A 一样，选择声明异常向上抛出，当其他方法调用 B 方法，也会面临 B 方法的两种选择。如果一直向上抛异常，而不使用 try-catch 处理，那么抛出的异常会击穿所有的栈帧，直到有方法将它 catch 住。</p><p><strong>Tips：throw 是抛出一个异常，而 throws 则是声明方法可能要抛出的异常</strong>，切勿混淆。</p><h2 id="Java-异常体系"><a href="#Java-异常体系" class="headerlink" title="Java 异常体系"></a>Java 异常体系</h2><ul><li>Throwable - 可以被抛出的东⻄（有毒）<ul><li>Exception - checked execption（受检异常，有毒，代表⼀种预料之中的异常）<ul><li>RuntimeException （运⾏时异常，⽆毒，代表⼀种预料之外的异常，因此不需要声明）</li></ul></li><li>Error （错误，无毒）</li></ul></li><li>catch 的级联与合并</li></ul><p>Throwable 是所有 Exception 和 Error 的父类，只要是 Throwable 类型就可以使用 throw 抛出。由于 Error 和 Exception 是他的子类，因此也能被抛出。</p><p>上面的继承体系中提到 「有毒」和「无毒」的概念，有毒指的是方法会<strong>传染</strong>，而无毒不会。「有毒」同前面的 A 方法和 B 方法一样，任何声明了有毒类型的方法，被调用之后，需要再次声明或者自己处理。任何声明了「无毒」类型的方法，被调用之后方法中无需做任何处理。「有毒」的代码实例，参考「抛出异常」章节的 A 和 B 方法。下面展示「无毒」的类型代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>    A();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们抛出了一个「无毒」类型异常 <code>RuntimeException</code>，当 B 方法调用 A 方法的时候，无需 try-catch，也无需声明异常。</p><p>这就是「有毒」和「无毒」的区别，它们有专业的术语 <code>checked</code>和<code>unchecked</code>，表示「受检」和「非受检」。「受检」表示写的代码会被检查，IDE 一般都会提示你做相应的处理。「非受检」表示写的代码不会被检查，无需做处理。</p><p>Exception 是预料之内异常，正因为在预料之内，所以 IDE 才会提示我们去处理这个异常。常见的有 <code>IOException</code>、<code>FileNotFonudException</code> 。RuntimeException 预料之外的异常，也正因为预料之外，因此 IDE 并不会对抛出的异常进行检验，因为根本无法检验。常见的有 <code>NullPointerException</code>，即空指针异常。</p><p>Error 代表一种严重的错误，他与 Exception 的区别是，前者代表不能恢复的异常，后面代表可以恢复的异常。大多数情况下，Error 代表一种不正常的情况，像内存错误（OutOfMemoryError）等。而像网络超时重连就是可恢复异常的表现。</p><p><strong>catch 的级联与合并</strong></p><p>前面我们提到过，方法中存在多个异常，就需要多个 catch 来处理，如下分别对几种不同类型的异常进行处理，进来的异常会从上到下一次比对，进入到对应的 catch 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>但上面代码存在一个问题，Exception 下面的 catch 都不会执行。因为 Exception 是他们的父类，所以每次进来都是第一个 catch 被执行，所以我们应该调整顺序从小到大排列，这样才能根据不同异常类型，做不同处理，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>      &#125;<br></code></pre></td></tr></table></figure><p>在 Java 7 之后引用了新的语法，对于处理方法完全一致的异常可以进行合并。如下，都是将错误信息打印到标准错误流中，因此我们可以对它进行合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>     &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125; <span class="hljs-keyword">catch</span> (EOFException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure><p>合并之后我们的代码就会变成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException | EOFException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="异常的一些原则"><a href="#异常的一些原则" class="headerlink" title="异常的一些原则"></a>异常的一些原则</h2><h3 id="抛出原则"><a href="#抛出原则" class="headerlink" title="抛出原则"></a>抛出原则</h3><ul><li><p>能⽤ if &#x2F; else处理的，不要使⽤异常</p><ul><li>无法保证抓出的异常是你想抓住的</li><li>相比 if 判断，异常的创建是非常昂贵的操作</li></ul></li><li><p>尽早抛出异常</p></li><li><p>异常要准确、带有详细信息</p></li><li><p>抛出异常也⽐悄悄地执⾏错误的逻辑强的多</p></li></ul><h3 id="处理原则"><a href="#处理原则" class="headerlink" title="处理原则"></a>处理原则</h3><ul><li><p>本⽅法是否有责任处理这个异常？</p><ul><li>不要处理不归⾃⼰管的异常</li></ul></li><li><p>本⽅法是否有能⼒处理这个异常？</p><ul><li>如果⾃⼰⽆法处理，就抛出</li></ul></li><li><p>如⾮万分必要，不要忽略异常</p></li></ul><h3 id="使⽤-JDK-内置的异常"><a href="#使⽤-JDK-内置的异常" class="headerlink" title="使⽤ JDK 内置的异常"></a>使⽤ JDK 内置的异常</h3><ul><li>NullPointerException</li><li>ClassNotFoundException&#x2F;NoClassDefFoundError</li><li>IllegalStateException</li><li>IllegalArgumentException</li><li>IllegalAccessException</li><li>ClassCastException</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识多线程</title>
    <link href="/2021/05/12/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/12/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在编程学习中，我们都要接触到多线程，多线程会帮系统性能带来很大提升，但是这种提升是风险与收益并存的。因此，学习并掌握多线程原理至关重要。</p><h2 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h2><p>既然有多线程，那肯定是有单线程的。那单线程是什么呢？单线程就是在特定时间系统只做一件事，这就和人一样只能「一心一意」，不能「三心二意」。</p><p>平时开发中跑的 Java 程序大多都是单应用，对于一些没有什么访问量的系统来说，能勉强支撑。反之，访问量较大的话，一个线程难以处理，很影响用户的体验。就像一片麦子一个人割，和10个人一起割时间完全不同的。因此，我们就需要用到多线程来解决性能问题。</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><p>在 Java 设计之初，就考虑到了线程，因此「多线程」在 Java 中是提供了语言级别的支持。在 Java 中使用多线程也很方便。创建线程最简单的方法就是使用 <code>new Thread()</code>，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wheatHarvest</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始割麦子&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hoeing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始锄地&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面创建两个线程，一个给他 <code>wheatHarvest()</code>割麦子的任务，另一个给他 <code>hoeing()</code>锄地的任务。创建了两个线程之后，这两件事是同时执行的，并不会说非要割完麦子，才去锄地。但上面只是创建了线程，分配了要执行的任务，线程并没有执行，要让线程执行必须调用线程的 <code>start()</code>方法，线程才会执行。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).start();<br></code></pre></td></tr></table></figure><h3 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start 和 run 的区别"></a>start 和 run 的区别</h3><p>刚开始学习多线程的时候经常将这两个方法搞混，现在重新复习一下。</p><p><strong>start 方法就是让线程开始执行，而 run 是要等待线程执行完才往下执行。</strong>如下，start 方法可以让割麦子和锄地同时运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).start();<br></code></pre></td></tr></table></figure><p>而 run 方法则是，先割麦子，等麦子割完了，然后再去锄地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).run();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).run();<br></code></pre></td></tr></table></figure><p>在这个方法上实现中，run 方法和我们的单线程基本没区别，而且还额外增加了线程的开销。</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>既然多线程能给系统性能带来提升，那我们就可以无脑使用吗？答案肯定不是的。既然享受了多线程给我们带来性能上的提升，同时我们也要承担多线程带来的安全问题。</p><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>多线程问题的来源就是，所有被线程共享的变量。当多个线程去操作一个共享变量的时候，线程安全问题就会出现。我们看如下代码，我们使用多线程操作，把共享变量 i 自增1，把结果打印看看会发生什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码，肯定会有人认为程序会按顺序输出 1~100，实际上不是如此。你可以把代码复制到自己的环境中运行，得出的结果可能会出乎你的意料，输出的顺序都乱了，并且可能会出现重复输出。为什么会出现这种情况呢？这是因为 <code>i++</code>操作并非是一个<strong>原子操作</strong></p><p>那什么是原子操作呢？原子操作就是一个不可分割的操作，之所以称作「原子操作」，我猜想和高中学的化学有关，原子是不可再分割的粒子，因此计算机就引用了这一概念。<strong>在多线程中，一个事情在某一时刻只能被一个线程操作，称作原子操作</strong></p><p>回到刚才的 <code>i++</code>操作，表面上我们以为是一步操作，实际上它包含了三个步骤：第一步，取 i 的值。第二步，把 i 的值加 1。第三步，把修改后的值写回 i。</p><p>我们使用两个线程来举例，线程1，线程2。线程1先执行，执行到 i ++的第二步操作，先取 i 的值，取到 i 的值为 0，然后把值加1，这个时候值变为 2，但是请注意，这个值并没有写回 i 中。这时，线程2开始执行了，它把 i++ 操作执行完了。由于线程1并没有把值写回 i 中，因此线程2 取到 i 的值依然为 0，把值加 1，写回到 i 中，完成 i++ 操作，并执行输出语句，打印 i 的值为1，到此线程2完成了。此时线程1继续执行刚才未完成的步骤，把值写回到 i 中，刚才线程1计算的值为1，因此把 1 写回到 i 中，完成 i++操作，打印 i 的值仍然为1。经过上面的操作，会发现 i 被重复写入了，因此我们无法保证输出的结果是 1~100。</p><p><strong>你可能会有疑问，为什么线程1执行的好好的，线程2突然就插一脚呢？</strong></p><p>这是因为，在微观上（cpu 眼中），<strong>多线程问题来源就是 cpu 的上下文切换，每个线程都会占用固定的时间周期，超过时间换线程执行。</strong>上面的例子就刚好是 cpu 的上下文切换，导致了1 这个值重复写入到 i 中。</p><p>我们打开 QQ，打开微信，打开浏览器，我们都认为他们是在同时运行的。但实际上都是 cpu 在进行切换，一会切换到微信，一会切换到浏览器，一会到 QQ，由于这个速度很快，我们就主观的认为他们是在同时运行的。多线程也是如此。</p><h3 id="线程不安全的表现（死循环，死锁，哲学家用餐）"><a href="#线程不安全的表现（死循环，死锁，哲学家用餐）" class="headerlink" title="线程不安全的表现（死循环，死锁，哲学家用餐）"></a>线程不安全的表现（死循环，死锁，哲学家用餐）</h3><blockquote><p>著名的 HashMap 的死循环问题可以点击该<a href="https://coolshell.cn/articles/9606.html">链接</a>，了解详情。</p></blockquote><h4 id="死锁详解"><a href="#死锁详解" class="headerlink" title="死锁详解"></a>死锁详解</h4><p>以下是一个简单的死锁 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread2</span>().start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;拿到lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;拿到lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上这段代码运行之后，控制台并没有输出，但是程序还在一直执行。代码最初声明了两把锁 lock1 和 lock2，使用synchronized 关键字，去获取锁。例如 <code>synchronized(lock1)</code>表示，需要拿到 lock1 才会执行后面的代码块，执行完<code>&#123;&#125;</code>包裹的代码块，锁才会释放。需要注意的是，<strong>一把锁同时只能有一个线程拿到</strong>。</p><p>因此上面的程序执行流程是，主线程开辟了两个线程，Thread1 和 Thread2，并开始执行。其中 Thread1 需要先获取 lock1，获取之后线程休眠 500ms，然后再去获取 lock2。Thread2 则是先去拿到 lock2，休眠 100ms，然后再去拿 lock1。当 Thread1 去拿 lock2 时，发现 lock2 被拿了，于是 Thread1 等待；Thread2 准备去拿 lock1 的时候发现，lock1 被拿走了，于是 Thread2 等待。Thread1 和 Thread2 都在等待彼此释放自己需要的锁，于是产生了死锁等待。</p><h4 id="简单的死锁排查"><a href="#简单的死锁排查" class="headerlink" title="简单的死锁排查"></a>简单的死锁排查</h4><p>既然死锁了，我们就要需要先拿到死锁的进程 id</p><p>在 Linux 中使用 <code>ps aux | grep java</code>，列出所有 java 进程的 id。或者使用 java 自带的 <code>jps</code> 命令，列出所有 java 进程。</p><p>之后使用 jstack 命令打印进程的栈信息，通过输出的栈信息来排查死锁。</p><blockquote><p>一个经典的多线程问题<a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin">哲学家用餐</a></p></blockquote><p><strong>预防死锁产生的原则：所有的线程按照相同的顺序获取资源的锁。</strong>上面的例子 Thread1 和 Thread2 获取锁的顺序不不一致，Thread1 先拿 lock1，Thread2 先拿 lock2。假如两个线程都先去拿 lock1 或者 lock2，那就不会产生死锁了。</p><h2 id="实现线程安全的基本手段"><a href="#实现线程安全的基本手段" class="headerlink" title="实现线程安全的基本手段"></a>实现线程安全的基本手段</h2><p>为了规避和解决线程带来的安全问题，我们可以采取一些措施</p><h3 id="使用不可变类"><a href="#使用不可变类" class="headerlink" title="使用不可变类"></a>使用不可变类</h3><p>使用 Integer &#x2F; String 这些不可变类。</p><h3 id="使用-synchronized-同步块"><a href="#使用-synchronized-同步块" class="headerlink" title="使用 synchronized 同步块"></a>使用 synchronized 同步块</h3><p><strong>方法一：</strong>synchronized（一个对象）把这个对象当成锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>            i++;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是上面的代码，我们把声明了一个锁，并在 <code>modifySharedVariable</code>方法体中使用 <code>synchronized</code>关键字。这样线程每次执行这个方法的时候，都会先去获取 lock1，当代码块中的代码执行后，lock1 被释放，其他的线程才能继续拿 lock1 去执行。</p><p><strong>方法二：</strong>static synchronized 方法，把 Class 对象当成锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次不声明锁，而是直接在 <code>modifySharedVariable</code>方法上使用 <code>synchronized</code>关键字。在 static 方法上使用 synchronized，实际上是把这个类的 Class 对象当成锁。因此每次访问这个方法都要去拿到 Class 对象，也保证了 i++ 顺序执行。</p><p><strong>方法三：</strong>实例的 synchronized 方法把该类的实例当成锁。（调用的对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 synchronized 声明在普通的方法上，实际上是把调用的对象当成锁。上面的代码是通过 Demo 类的一个实例 object 来调用 modifySharedVariable 方法的。因此，object 就被当成锁，也保证了 i++ 顺序执行。上面的代码也可以改成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            i++;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接用 <code>synchronized (this)</code>，这与 synchronized 声明在实例方法，功能是等价的。</p><h3 id="使用-Collections-工具类"><a href="#使用-Collections-工具类" class="headerlink" title="使用 Collections 工具类"></a>使用 Collections 工具类</h3><p>我们可以使用 Java 给我们提供的 Collection 的工具类，把不安全的 Collection 变成安线程全的。像 Collections.<em>synchronizedList</em>()，Collections.<em>synchronizedSet</em>() 等等</p><p>例如将普通的 Map 变成线程安全的 Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><h3 id="使用-JUC（java-util-concurrent）-包"><a href="#使用-JUC（java-util-concurrent）-包" class="headerlink" title="使用 JUC（java.util.concurrent） 包"></a>使用 JUC（java.util.concurrent） 包</h3><p>juc 包提供了很多线程安全的类，遇到线程安全问题，我们都可以把不是线程安全的类，换成线程安全的。</p><p><strong>原子操作类：AtomicInteger、AtomicBoolean..，</strong>之前的我们得 i++ 操作不是原子的，可以使用原子操作类 AtomicInteger，来进行替换。使用 AtomicInteger 的 <code>incrementAndGet</code>方法，就可以实现原子自增1的操作。</p><p><strong>线程安全集合：</strong>ConcurrentHashMap，ConcurrentLinkedQueue 等。在任何使用 HashMap 有线程安全问题的地方，都可以无脑使用ConcurrentHashMap 替换</p><h3 id="ReentrantLock-（可重入锁）"><a href="#ReentrantLock-（可重入锁）" class="headerlink" title="ReentrantLock （可重入锁）"></a>ReentrantLock （可重入锁）</h3><p>ReentrantLock 所做的事情和 synchronized 几乎一样。</p><p><strong>区别在于 ReentrantLock 可以自己定义加锁和解锁时机。</strong>使用 synchronized 关键字，执行完代码块中的代码，锁就会释放，但是有的时候我们需要在其他地方释放锁，而不是执行完就释放。因此可以使用 ReentrantLock 加锁，在适当的时机解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        reentrantLock.lock();<br>        i++;<br>        reentrantLock.unlock();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是之前的例子，如果你对输出结果并不关心的话，进入到 <code>modifySharedVariable</code>方法后，先使用 reentrantLock.lock() 获取锁，等 i++ 操作结束之后，使用 reentrantLock.unLock() 释放锁。reentrantLock 获取锁和释放锁的操作时机，都可以根据实际情况自己定义。</p><p><strong>Tips：可重入锁相关概念。</strong>如下 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        object.a();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        b();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>a 和 b 方法都使用 synchronized 声明了，主线程调用声明了一个实例调用 a 方法。根据前面学的知识，调用 a 方法需要拿到实例锁，然后执行 a 方法。a 方法中又调用了 b 方法，b 方法也需要拿到实例锁，但是因为 a 已经拿到了实例锁，并且 synchronized 也是可重入锁，所以调用 a 方法中调用 b 方法无需再去获取实例锁，这就是可重入锁的概念。</p><blockquote><p>可以点击查看 StackOverflow 上的大牛对于可重入锁的概念的理解<a href="https://stackoverflow.com/questions/16504231/what-is-the-meaning-of-reentrantlock-in-java/16504266#16504266">链接</a></p></blockquote><h2 id="Object-类里的线程方法"><a href="#Object-类里的线程方法" class="headerlink" title="Object 类里的线程方法"></a>Object 类里的线程方法</h2><p>说方法之前，了解下 Java 线程中的 6 种状态</p><ol><li><strong>初始（NEW），</strong>创建一个线程对象，但没有调用 start 方法</li><li><strong>运行（RUNNABLE），</strong>开始执行操作（得到 CPU 使用权）</li><li><strong>阻塞（BLOCKED），</strong>线程阻塞与锁</li><li><strong>等待（WAITING），</strong>需要其他线程唤醒，或中断</li><li><strong>超时等待（TIMED_WAITING），</strong>可以指定时间后，自行返回</li><li><strong>终止（TERMINATED），</strong>线程执行完毕</li></ol><p>使用代码解释这几个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            i++;<br>            System.out.println(i);<br>            lock.wait();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 new 一个线程的时候就是<strong>初始状态，</strong>调用了 start 方法，线程进入<strong>运行状态</strong>。假如第一个线程更快一步拿到 lock，这时其它两个线程就处于<strong>阻塞状态，</strong>当 lock 调用 wait() 方法，拿到 lock 的线程就进入<strong>等待状态，</strong>然后释放 lock，当线程方法执行完之后<strong>，</strong>线程进入<strong>终止状态</strong></p><p><strong>wait() 方法</strong></p><p>让当前线程进入<strong>等待状态</strong>。调用 wait 方法之前，必须先拿到锁。当调用 wait 方法之后，拿到的锁也就会释放。</p><p><strong>notify()</strong></p><p>随机唤醒一个处于等待状态的线程。</p><p><strong>notifyAll()</strong></p><p>唤醒所有处于等待状态的线程。</p><blockquote><p>实现生产者消费者模型 <a href="https://github.com/greek-zzf/my-demo/tree/main/example/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">demo</a>，可点击查看。</p></blockquote><h2 id="线程池与-Callable-x2F-Future"><a href="#线程池与-Callable-x2F-Future" class="headerlink" title="线程池与 Callable &#x2F; Future"></a>线程池与 Callable &#x2F; Future</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>在前面提到，我们每次使用线程都要先创建一个线程，然后使用给他分配任务，最后调用他的 start 方法执行这个任务。上面的步骤看起来没多大问题，仔细想想看，要是任务一多，每次分配任务的时候都要创建一个新的线程，这个创建线程的<strong>花销</strong>在 Java 世界中是很「昂贵的」。</p><p>类比到生活中，公司每次新接一个项目都去招一些人，做完项目就炒了，然后下次又来一个新的项目，又要去招人，这对于 HR 来说很麻烦。市面上的策略大多都是，招一群有潜力的人才，然后公司培养，有项目来就参与项目开发，下次再遇到新项目还是用之前招的人，这样就减少了公司频繁找人的开销。</p><p><strong>线程池就是预先定义好若干个线程，每次需要线程的时候就去调用，避免了每次创建线程的开销</strong>，这与公司找人的策略是一样的。</p><h3 id="定义线程池"><a href="#定义线程池" class="headerlink" title="定义线程池"></a>定义线程池</h3><p>使用 Executors 类去创建相应的线程池，并且可以配置线程的信息，使用 <code>newFixedThreadPool</code>方法，创建固定数量的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="Runable-与-Callable"><a href="#Runable-与-Callable" class="headerlink" title="Runable 与 Callable"></a>Runable 与 Callable</h3><p>在线程池中，都是使用 submit 方法提交并执行任务。使用 submit 方法的时候可以发现，它接收两个不同类型的参数。一个是与之前多线程相同的参数 Runable，而另一个则是 Callable。通过查看两者源代码可以发现，前者是没有返回值的，而 Callable 则有返回值。</p><p><img src="/../picture/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/60ed335c-4bda-4b0b-9b00-7aa0ae60dbe3.png" alt="image.png"></p><p><img src="/../picture/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/c8717165-05fe-4a6f-b7da-95f2d9ca2265.png" alt="image.png"></p><p>我们可以发现 submit 方法返回了一个 Future 对象，Future 泛型的值与 Callable 里 call 方法返回的值是一样的。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><strong>Future 表示异步计算的结果，也可以理解未来返回的结果。</strong>例如：我们让一个工人去割麦子，他去执行之后，我们只需要看看仓库是否增加了这么多麦子即可。工人割麦子的时候，我们可以去干其他事情，只需最后看结果就行。这个 Future 就是工人割的麦子总量。</p><p>Future 的常用 API</p><ul><li>get() 方法即可拿到返回的数据（拿到麦子）</li><li>get(long timeout, TimeUnit unit) 给定等待时间，拿到结果（在规定时间内，检查割了多少麦子）</li><li>cancel() 方法取消当前线程的任务（不让工人割麦子）</li><li>isCancelled() 方法判断当前线程是否在正常结束之前被取消（不让工人割麦子之后，检查麦子是否割完）</li><li>isDone() 判断当前线程是否执行完成（检查麦子是否割完）</li></ul><h3 id="使用多线程实现-Word-Count"><a href="#使用多线程实现-Word-Count" class="headerlink" title="使用多线程实现 Word Count"></a>使用多线程实现 Word Count</h3><p>WordCount 就是给定一段或者多段文本（假设每个单词之间都是用空格分隔），记录每个单词出现的次数。</p><p><strong>实现思路</strong>：可以定义一个线程池，线程池中线程的数量可以根据参数传递。每个线程的任务就是读取文件的一行，然后统计该行每个单词出现的次数。最后把每个线程执行的结果汇总，这样就完成了。</p><p>先把整个思路的代码写好，通过参数 <code>threadNum</code>定义了线程池中线程的数量。使用 Map&lt;String,Integer&gt; 记录单词出现的次数，Future&lt;Map&lt;String, Integer&gt;&gt; 表示线程返回的结果， List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; 就表示多个线程返回的集合。</p><p>由于有多个文件，因此使用 for 循环对每个文件都要进行统计操作。<code>threadPool.submit(() -&gt; workJob(file))</code> 提交了任务并执行，任务就是 <code>workJob</code>，即统计一行，单词出现的次数，返回的结果是<code>Future&lt;Map&lt;String,Integer&gt;&gt;</code>，再用刚才定义好的集合 futures，把所有线程返回的结果收集起来。</p><p>futures 收集完成后，开始遍历这个集合，把线程返回的结果进行统计合并，使用 <code>mergeWorkResultIntoFileResult</code>得到一个最终的结果，然后把最终的结果返回，程序执行结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span> threadNum, List&lt;File&gt; files)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadNum);<br><br>        List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            futures.add(threadPool.submit(() -&gt; workJob(file)));<br>        &#125;<br><br>        Map&lt;String, Integer&gt; finalResult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Future&lt;Map&lt;String, Integer&gt;&gt; workResult : futures) &#123;<br>            mergeWorkResultIntoFileResult(workResult.get(), finalResult);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> finalResult;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来是具体的方法实现，首先是 workJob() 方法。统计一行文本中，单词出现的次数。</p><p>先读取一行文本保存到字符串，然后 split() 方法对单词进行分割，得到单词数组 words。把单词数组遍历，map 记录单词出现的次数。其中 <code>result.getOrDefault(word, 0) + 1</code> 方法表示：<strong>从 map 中拿到 key 为 word 的值，如果存在这个 key，就对这个 key 的值进行 +1 操作，然后 put 进去。如果不存在这个 key，就使它的值默认为 0，然后再进行 +1 操作，put 进去。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">workJob</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file));<br><br>     Map&lt;String, Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     String line;<br>     <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br><br>         String[] words = line.split(<span class="hljs-string">&quot; &quot;</span>);<br>         <span class="hljs-keyword">for</span> (String word : words) &#123;<br>             result.put(word, result.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>最后的工作 <code>mergeWorkResultIntoFileResult()</code>，把线程返回的结果，合并统计，得到最终结果。统计的操作和 workJob() 方法类似。把合并的结果返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">mergeWorkResultIntoFileResult</span><span class="hljs-params">(Map&lt;String, Integer&gt; workResult, Map&lt;String, Integer&gt; fileResult)</span> &#123;<br>    <br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entrySet : workResult.entrySet()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> entrySet.getKey();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mergerResult</span> <span class="hljs-operator">=</span> fileResult.getOrDefault(word, <span class="hljs-number">0</span>) + entrySet.getValue();<br>        fileResult.put(word, mergerResult);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fileResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，一个使用多线程的 wordcount 功能实现。代码可以点击看<a href="https://github.com/greek-zzf/my-demo/tree/main/example/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20WordCount">源代码</a>，后续会在代码中更新其他方法实现 WordCount。</p><h2 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h2><ul><li><p>不推荐：对于 cpu 密集型应用稍有折扣。cpu 密集型操作会把 cpu 跑满，因此再使用多线程去操作，性能上很那有提升。</p></li><li><p>推荐：IO 密集型操作（文件 IO，网络 IO），这两个操作相比 cpu 的执行速度慢如蜗牛，因此用多线程来执行，性能上会有很大提升。</p></li><li><p>多线程性能提升的上限：单核 cpu 100%，如果是多核就是 N*100%。当 cpu 跑满的时候，就很难有「闲工夫」去处理其他请求。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 获取 GitHub PR 消息</title>
    <link href="/2021/05/11/Java%20%E8%8E%B7%E5%8F%96%20GitHub%20PR%20%E4%BF%A1%E6%81%AF/"/>
    <url>/2021/05/11/Java%20%E8%8E%B7%E5%8F%96%20GitHub%20PR%20%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/greek-zzf/get-github-pr">链接</a></p><h2 id="使用-GitHub-API-获取-PR"><a href="#使用-GitHub-API-获取-PR" class="headerlink" title="使用 GitHub API 获取 PR"></a>使用 GitHub API 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jackson Databind 将返回的字符串解析转化成所需对象</li></ul><h3 id="访问-GitHub-API"><a href="#访问-GitHub-API" class="headerlink" title="访问 GitHub API"></a>访问 GitHub API</h3><p>访问 Github API <a href="https://docs.github.com/cn/rest/reference/pulls">文档</a>，找到 List pull requests 该项，根据 API 说明，应当使用 GET 方法，路径中还需要带上 owner 和 repo 参数，还需要设置 request header 中的 accept 为 <code>appliccation/vnd.github.v3+json</code>，这样就建立了一个正确的请求</p><p><img src="/../picture/Java%E8%8E%B7%E5%8F%96GitHubPR%E4%BF%A1%E6%81%AF/5857265f-3856-46c9-ba85-2a75f935b4a1.png" alt="image.png"></p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ol><li><p>创建一个类来封装获取到的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GitHubPullRequest</span> &#123;<br>        <span class="hljs-comment">// Pull request的编号</span><br>        <span class="hljs-type">int</span> number;<br>        <span class="hljs-comment">// Pull request的标题</span><br>        String title;<br>        <span class="hljs-comment">// Pull request的作者的 GitHub 用户名</span><br>        String author;<br><br>        GitHubPullRequest(<span class="hljs-type">int</span> number, String title, String author) &#123;<br>            <span class="hljs-built_in">this</span>.number = number;<br>            <span class="hljs-built_in">this</span>.title = title;<br>            <span class="hljs-built_in">this</span>.author = author;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>新建一个方法，使用 HttpClient 工具包发起 HTTP 请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://api.github.com/repos/&quot;</span> + repo + <span class="hljs-string">&quot;/pulls&quot;</span>);<br>httpGet.setHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/vnd.github.v3+json&quot;</span>);<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br></code></pre></td></tr></table></figure><p>首先创建一个<strong>默认的可关闭的客户端</strong>，使用 HttpGet 创建一个 GET 请求，repo 是我们要接收的参数。再刚才创建的 GET 请求中设置他的请求头信息，与 GitHub 规定的 API 一致。然后使用刚才创建的客户端，去执行 get 请求，将返回的结果用 CloseableHttpResponse 接收。</p></li><li><p>由于返回的结果是字节流，因此我们需要把字节流转换成我们需要的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">responseEntity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> responseEntity.getContent();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>getEntity()</code> 方法获取返回的 body 实体信息，获取到的实体信息调用 <code>getContent()</code> 方法获取内容，接着使用 IOUtils 工具把获取的内容从字节流以 UTF-8 的格式转化为字符串。 </p></li><li><p>把字符串转化成 json 对象或实体对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-type">JsonNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> objectMapper.readTree(result);<br><br>List&lt;GitHubPullRequest&gt; gitHubPullRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> number;<br>        String title;<br>        String author;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; node.size(); i++) &#123;<br>            number = node.get(i).get(<span class="hljs-string">&quot;number&quot;</span>).asInt();<br>            title = node.get(i).get(<span class="hljs-string">&quot;title&quot;</span>).asText();<br>            author = node.get(i).get(<span class="hljs-string">&quot;user&quot;</span>).get(<span class="hljs-string">&quot;login&quot;</span>).asText();<br><br>            gitHubPullRequests.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GitHubPullRequest</span>(number, title, author));<br>        &#125;<br></code></pre></td></tr></table></figure><p>使用 Jackson 工具，以树的形式反序列化 json 字符串得到 JsonNode，然后使用 for 循环将我们需要的数据封装到GitHubPullRequest 对象中，即可。</p></li></ol><h2 id="解析-HTML-获取-PR"><a href="#解析-HTML-获取-PR" class="headerlink" title="解析 HTML 获取 PR"></a>解析 HTML 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jsoup 将 html 字符串转化为 document</li></ul><h3 id="找到要获取的仓库-PR-地址，发起请求"><a href="#找到要获取的仓库-PR-地址，发起请求" class="headerlink" title="找到要获取的仓库 PR 地址，发起请求"></a>找到要获取的仓库 PR 地址，发起请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://github.com/&quot;</span> + repo + <span class="hljs-string">&quot;/pulls&quot;</span>);<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br></code></pre></td></tr></table></figure><p>发起请求并执行请求，获得返回的 response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpEntity</span> <span class="hljs-variable">responseEntity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> responseEntity.getContent();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>获取返回的数据中，body的内容，并把它转化成字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> Jsoup.parse(result);<br></code></pre></td></tr></table></figure><p>由于得到的是 html 字符串，使用 Jsoup 解析工具解析成 Document 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Element&gt; elements = doc.select(<span class="hljs-string">&quot;.js-issue-row&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 document 的 css 选择器，获取页面中的元素。此处可以根据具体页面采用不同的选择器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> number;<br>      String title;<br>      String author;<br>      List&lt;GitHubPullRequest&gt; gitHubPullRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (Element e : elements) &#123;<br>          title = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">0</span>).text();<br>          author = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">3</span>).child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).text();<br>          String[] str = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">3</span>).child(<span class="hljs-number">0</span>).text().split(<span class="hljs-string">&quot; &quot;</span>);<br>          number = Integer.parseInt(str[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>));<br>          gitHubPullRequests.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GitHubPullRequest</span>(number, title, author));<br>      &#125;<br></code></pre></td></tr></table></figure><p>根据元素之间的层级关系，拿到对应元素的信息，把信息封装到 GitHubPullRequest 类中存储。一个简单的 HTML 爬虫实现。</p><h2 id="使用第三方-SDK-获取-PR"><a href="#使用第三方-SDK-获取-PR" class="headerlink" title="使用第三方 SDK 获取 PR"></a>使用第三方 SDK 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jackson Databind 将返回的字符串解析转化成所需对象</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 正则表达式</title>
    <link href="/2021/04/17/Java%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/04/17/Java%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>定义</strong>：用于描述文本&#x2F;字符串的一组规则</p><p><strong>作用</strong>：使用一些自定义的规则来批量处理文本，提取信息</p><p><strong>优点</strong>：使用很少的代码完成复杂的文本提取工作，提高工作效率</p><p><strong>缺点</strong>：难学，难懂。在 java 对于正则表达式的支持不太友好，频繁使用会有性能问题。</p><h2 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h2><p><strong>元字符</strong></p><table><thead><tr><th>^</th><th>开始位置</th></tr></thead><tbody><tr><td>$</td><td>结束位置</td></tr><tr><td>.</td><td>单个任意字符</td></tr><tr><td>\w</td><td>单个”word”字符 字母&#x2F;数字&#x2F;下划线&#x2F;汉字</td></tr><tr><td>\s</td><td>单个空白字符</td></tr><tr><td>\d</td><td>单个数字字符</td></tr><tr><td>\b</td><td>单词的开始或结束</td></tr></tbody></table><p><strong>重复</strong></p><table><thead><tr><th>*</th><th>0次或多次</th></tr></thead><tbody><tr><td>+</td><td>1次或多次</td></tr><tr><td>?</td><td>0次或1次</td></tr><tr><td>{n}</td><td>n次</td></tr><tr><td>{n,}</td><td>&gt;&#x3D;n次</td></tr><tr><td>{n,m}</td><td>n到m次</td></tr></tbody></table><p><strong>选择</strong></p><table><thead><tr><th>[aeiou]</th><th>单个的a&#x2F;e&#x2F;i&#x2F;o&#x2F;u字符之一</th></tr></thead><tbody><tr><td>[0-9]</td><td>单个数字字符</td></tr><tr><td>[A-Z]</td><td>单个大写字母</td></tr><tr><td>[A-Z0-9_]</td><td>大写字母或者数字或者下划线</td></tr><tr><td>Hi&amp;#124;hi等价于[Hh]i</td><td>Hi或者hi</td></tr></tbody></table><h2 id="Java-世界中的正则表达式"><a href="#Java-世界中的正则表达式" class="headerlink" title="Java 世界中的正则表达式"></a>Java 世界中的正则表达式</h2><p>Java 中的正则表达式是比较「昂贵」的</p><ul><li><p>正则表达式需要解析</p><ul><li>Java 需要将正则表达式字符串，转换成自己内部的数据结构，这个转换过程代价较大</li><li>在写代码中可以将正则表达式预编译好，需要的时候再调用就行了，减少了多次编译的开销。例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;0\\d&#123;2&#125;-[1-9]\\d&#123;7&#125;|0\\d&#123;3&#125;-[1-9]\\d&#123;6&#125;&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>匹配过程非常「昂贵」</p><ul><li>Java 的匹配算法并不高效，用到的是<a href="https://www.google.com/search?q=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95&oq=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95&aqs=chrome..69i57j0l9.2220j0j4&sourceid=chrome&ie=UTF-8">回溯算法</a>。就像机器人走迷宫一般，一直尝试，遇到墙就换一条路线继续试，直到走出迷宫</li></ul></li></ul><p>Java 中使用到正则表达式的方法：String 类中的 split，replaceAll，replacefirst，matches，以及 Matches 中的方法。可以查看相关的 demo 链接：<a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%99%AE%E9%80%9A%E7%BB%83%E4%B9%A0/PhoneNumberMatcher.java">判断是不是合法的固定电话号码</a>，<a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%99%AE%E9%80%9A%E7%BB%83%E4%B9%A0/LogProcessor.java">移除文件中的时间戳</a></p><h2 id="分组与捕获"><a href="#分组与捕获" class="headerlink" title="分组与捕获"></a>分组与捕获</h2><p>前面的正则表达式用法，都是用来判断字符串是否满足条件。然而，实际工作中用到较多的都是从一堆字符串中提取所需的信息，那么 Java 又是怎么做的呢？</p><p>想要将所有符合正则表达式的⽂本抓出来处理，需要先了解如下规则：</p><ul><li>使⽤括号来指定⼀个被捕获的分组</li><li>分组的编号从1开始</li><li>分组的编号计算只看左括号</li><li>(?:)不捕获和分配编号，括号只⽤于分组或标记优先</li><li>分组编号为0表示整个匹配的字符串</li></ul><h3 id="Java-中捕获数据"><a href="#Java-中捕获数据" class="headerlink" title="Java 中捕获数据"></a>Java 中捕获数据</h3><p>在 Java 中可以使用 <code>Pattern 类的 matcher() 方法生成 Matcher 对象</code> ，然后我们可以对 <code>Matcher对象进行操作</code>。</p><p>假设有如下数据，我们需要将时间以及消费金额提取出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">2020-01-02 在家玩游戏消费0元<br>2020-01-03 在家敲代码消费3元<br>2020-02-02 出门旅游消费1000元<br></code></pre></td></tr></table></figure><p>我们可以先将该数据读取出来，保存成一个 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">gcLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;message.log&quot;</span>);<br>List&lt;String&gt; lines = Files.readAllLines(gcLog.toPath());<br></code></pre></td></tr></table></figure><p>然后我们可以在类中声明 Pattern，把对匹配时间和事件的正则表达式预编译。经过在线正则表达式测试，我们可以编写如下正则 <code>\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;(.*)?\d</code> 这个可以匹配时间和金额。我们要提取，就需要给时间部分加上括号，金额部分也加上括号。正则表达式变成 <code>(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)(.*)?(\d)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_REGEX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)(.*)?(\d)&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(MESSAGE_REGEX);<br></code></pre></td></tr></table></figure><p>接着对所有字符串进行匹配，匹配过程中会生成 Matcher。调用 Matcher 的 find 方法，判断是否匹配成功。因为分组编号为 0 代表匹配的全部信息，即日期+金额，group(1) 代表匹配的第一组信息，即时间，group(2）就代表金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String line : lines) &#123;<br>          <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(line);<br>          <span class="hljs-keyword">if</span>(matcher.find())&#123;<br>              System.out.println(matcher.group(<span class="hljs-number">0</span>));<br>              System.out.println(matcher.group(<span class="hljs-number">1</span>));<br>              System.out.println(matcher.group(<span class="hljs-number">2</span>));<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><p>一个更为复杂的 GC 日志文件信息提取操作可查看 <a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%88%86%E7%BB%84%E4%B8%8E%E6%8D%95%E8%8E%B7/GCLogAnalyzer.java">Demo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析URL</title>
    <link href="/2021/04/03/%E6%B5%85%E6%9E%90%20URL/"/>
    <url>/2021/04/03/%E6%B5%85%E6%9E%90%20URL/</url>
    
    <content type="html"><![CDATA[<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>ip 主要约定了两件事：如何定位一台设备？如何封装数据报文，以跟其他设备交流？</p><p>只要我们处在互联网中我们就至少有一个独特的 IP</p><h3 id="内网与外网-IP"><a href="#内网与外网-IP" class="headerlink" title="内网与外网 IP"></a>内网与外网 IP</h3><p>当我们通过家里的路由器进行上网时，实际上网络返回的请求是先到路由器，路由器再转发给我们的设备，路由器就充当我们与外界网络交互的工具。路由器分配给我们设备的 IP 就是<strong>内网 IP</strong>，一般来说这个 IP 格式都是 <code>192.168.xxx.xxx</code> 。内网中的设备都可以相互访问。而外网 IP 就是电信&#x2F;联通之类的运营商给你分配的 IP，只要路由器连上网就会有一个外网 IP。这个外网 IP 不是固定的，当我们重启路由器和光猫，得到的 IP 很有可能就会不一样</p><h3 id="几个特殊的-IP"><a href="#几个特殊的-IP" class="headerlink" title="几个特殊的 IP"></a>几个特殊的 IP</h3><ul><li>127.0.0.1 表示自己</li><li>localhost 通过 hosts 指定为自己<ul><li>可以通过修改 hosts 文件将自己定义的名称指定为 <code>自己</code> ，例如：可以将 zzf 指定为自己</li></ul></li><li>0.0.0.0 不表示任何设备</li></ul><h2 id="端口-port"><a href="#端口-port" class="headerlink" title="端口 port"></a>端口 port</h2><p>我们已经知道一台机器的 IP，但是还不能访问它，我们还需要<strong>端口</strong>。</p><p>一台机器可以提供多种服务，并且每个服务都对应一个号码，这个号码就是我们所说的端口。</p><h3 id="一个简单的比喻"><a href="#一个简单的比喻" class="headerlink" title="一个简单的比喻"></a>一个简单的比喻</h3><p>麦当劳提供两个窗口，一号快餐，二号咖啡。当我们去一号窗口点咖啡，会被拒绝，让你去二号点咖啡。去咖啡窗口点快餐也是一样。</p><h3 id="一台机器可以提供多种服务"><a href="#一台机器可以提供多种服务" class="headerlink" title="一台机器可以提供多种服务"></a>一台机器可以提供多种服务</h3><ul><li>HTTP 服务默认 80 端口</li><li>HTTPS 服务默认 443 端口</li><li>FTP 服务默认 21 端口</li><li>一共有 65535 个端口</li></ul><p>要只要应该用什么端口，可以去维基百科搜索，他会告诉你每个端口该做什么。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>0~1023 端口是留给系统使用的</li><li>只有拥有管理员权限才能使用这预留个系统的端口</li><li>其他端口可以给普通用户使用</li></ul><p>更多端口的详细信息，可以访问<a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">链接</a></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>知道 IP 和端口之后，可以正确的享受相应的 <code>服务</code> 了。但是，我们每次都通过 IP 和端口去访问很麻烦，毕竟IP 这串数字太难记了。因此，域名诞生了，<strong>域名就是对 IP 的别称。</strong></p><p>我们访问百度的 IP，就不用找它的 IP了，可以直接使用 baidu.com 来替代。我们也可以使用 <code>ping badu.com</code> 命令，根据域名获取到它对应的 IP。</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>一个域名可以对应不同的 IP，这样是负载均衡，防止一台机器扛不住</li><li>一个 IP 也可以对应不同的域名，这个叫做共享主机，穷开发者才会这样做</li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名和 IP 的关系是如何绑定起来的呢？这个就要靠 DNS 了，它相当于过去的电话本，你要找「张三」的手机号码，就需要找到「张三」这个人，手机号码也同时找到了。</p><p>我们默认使用的 DNS 就是电信&#x2F;联通之类的运营商为我们提供的，我们也可以自己修改 DNS。</p><p><strong>过程：</strong>当我们使用浏览器访问 <code>baidu.com</code> ，DNS 会返回它对应的 IP，然后浏览器向对应的 IP 的 80&#x2F;443 端口发送请求，然后返回百度首页的内容。</p><h2 id="获取网页内容规则"><a href="#获取网页内容规则" class="headerlink" title="获取网页内容规则"></a>获取网页内容规则</h2><ul><li>我们可以通过改变访问地址路径做到，获取不同的内容，假设有该 <code>zzf.com</code>  域名<ul><li><code>zzf.com/docs</code> 获取文档内容</li><li><code>zzf.com/images</code> 获取图片内容</li></ul></li><li>根据修改参数可以达到，同一页面不同内容<ul><li><code>www.baidu.com/s?wd=hi</code> </li><li><code>www.baidu.com/s?wd=hello</code></li></ul><p> </p></li><li>可以使用锚点做到，同一内容不同位置<ul><li><code>zzf.com#教程</code> ，定位到该页面的「教程」位置</li><li><code>zzf.com#参考书</code> ，定位到该页面的「参考书」位置</li></ul></li></ul><p><strong>注意事项：虽然锚点是在请求地址中的，但是锚点不会传给服务器。</strong></p><h2 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h2><ul><li><code>curl -v http://baidu.com</code> 输出通信的整个过程，包括获取 IP，建立 tcp 连接，发送请求，响应内容，关闭 tcp 链接，结束访问。</li></ul><p>更详细的使用规则可以访问<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">链接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 常用标签</title>
    <link href="/2021/04/01/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/04/01/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><strong>href</strong>（指定要跳转的链接），取值如下<ul><li>网址（<a href="https://google.com,http//google.com%EF%BC%8C//google.com%EF%BC%89">https://google.com，http://google.com，//google.com）</a></li><li>路径（&#x2F;a&#x2F;b&#x2F;c，a&#x2F;b&#x2F;c&#x2F;，index.html）</li><li>伪协议（javascript:代码;，tel:手机号，mailto:邮箱）</li></ul></li><li><strong>target</strong>（指定打开链接的窗口），取值如下<ul><li>_blank（新窗口打开）</li><li>_top（顶级窗口打开）</li><li>_parent（父级窗口打开）</li><li>_self（默认值，表示在当前页面打开）</li></ul></li></ul><h2 id="table-标签"><a href="#table-标签" class="headerlink" title="table 标签"></a>table 标签</h2><h3 id="相关的标签"><a href="#相关的标签" class="headerlink" title="相关的标签"></a>相关的标签</h3><ul><li>table</li><li>thead（表头）</li><li>tbody（表内容）</li><li>tfoot（表尾）</li><li>tr，table row 缩写，表示一行。</li><li>td，table data 缩写,表示内容</li><li>th，table header 缩写，表示标题</li></ul><p>我们可以用如下代码的来实现，一个简单的表格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小红<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>246<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>279<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>297<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>小明</th><th>小红</th><th>小白</th></tr></thead></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>246<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>279<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>297<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../picture/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/b13bb768-2d4b-4038-aa44-e996452c2c6f.png" alt="image.png"><br>其中 <code>小明，小红，小白</code> 为表头的标题，所以使用 <thead> 标签包裹，并使用 <th> 标签表示表头。 <code>数学，语文，英语，总分</code> 也为标题，因此也要用 <th> 标签包裹，总分在 <tfoot> 中，使用 <th> 包裹。这样就实现一个简单的表格。</p><h3 id="相关样式"><a href="#相关样式" class="headerlink" title="相关样式"></a>相关样式</h3><ul><li><strong>table-layout</strong><ul><li>auto，根据内容的宽度展示</li><li>fixed，固定的宽度</li></ul></li><li><strong>border-collapse</strong>（border 是否合并）<ul><li>collapse 表示合并</li></ul></li><li><strong>border-spacing</strong>（合并 border 之间的距离）**</li></ul><h2 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>发出 get 请求，展示一张图片</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>alt（图片加载失败时展示的内容）</li><li>height（图片高度，直接使用数字。支持自适应，高度固定则宽度自适应）</li><li>width（图片宽度，直接使用数字。支持自适应，宽度固定则高度自适应）</li><li>src（引用图片地址，可以使用绝对路径，相对路径，网络地址）</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>onload（图片加载成功事件）</li><li>onerror（图片加载失败页面），通常可以做一些处理，例如当图片加载失败之后，可以使用默认的错误图片来展示。</li></ul><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>max-width:100%，自适应不同屏幕分辨率。可以使图片根据不同屏幕大小完整显示。</li></ul><h2 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>发 <strong>get</strong> 或 <strong>post</strong> 请求，然后<strong>刷新页面。</strong></p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul><li>action（请求的地址）</li><li>method（请求方法）</li><li>autocomplete（比如输入账号有自动填充）</li><li>target（指定刷新页面）</li></ul><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><ul><li>onsubmit（表单提交）</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>form 里面放一个 type &#x3D; submit 才能触发事件。</li><li>可以是 <code>&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;</code> ，或者 <code>&lt;input type=&quot;submit&quot;/&gt;</code></li></ul><h2 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>让用户输入内容</p><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul><li>type<ul><li>button，按钮</li><li>checkbox，复选框，提交多个选项将 input 的 name 属性设置为相同的值</li><li>file，上传单个文件，上传多个需要在 input 中加入 multipart 即可</li><li>hidden</li><li>password，密码类型</li><li>radio，单选框，实现单选需要将两个 input 的 name 设为相同的值</li><li>submit，提交表单</li><li>text，文本类型</li></ul></li></ul><h3 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h3><ul><li>onchange，输入框中改变的事件</li><li>onfocus，输入框焦点事件</li><li>onblur，输入框移出事件</li><li>一般不监听 input 的 click 事件</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件与 IO</title>
    <link href="/2021/03/28/%E6%96%87%E4%BB%B6%E4%B8%8E%20IO/"/>
    <url>/2021/03/28/%E6%96%87%E4%BB%B6%E4%B8%8E%20IO/</url>
    
    <content type="html"><![CDATA[<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p><strong>1.I&#x2F;O流是什么?</strong></p><p>对于陌生的东西，最好通过类比的方法去了解。我对于流的理解：<strong>流就是一系列数据</strong>。通过生活中常见的现象进行类比，比如：流中全部是水，我们称为“水流”，流中全是电子，我们称为“电流”。那我们可以根据流中的数据类型，来给流命名。再回到计算中，流中是字节的我们叫“字节流”，是字符的叫“字符流”，等等。</p><p>对于笔者来说，在Java开发中需要用到获取文件信息，经常需要用到流。那个时候不理解流，只知道抄着代码，这里改改那里修修。以至于，每当需要操作文件的时候不知道如何开始下手，对于整个流程不清楚。每当去百度文件操作的时候，又发现很多种实现方法，用的流都不一样，实现起来也有细微差别，搞得笔者也是心态爆炸，于是下决心把这块内容梳理好，方便以后使用。</p><p>关于这部分内容目前存在以下几个问题：</p><ul><li>如何理解文件在流中的角色？</li><li>文件操作的整个流程？</li><li>文件操作选用什么流？</li><li>不同的流的差异与特点</li></ul><p>**流的一些补充:**上面粗略解释了流，现在需要对流进行一个补充。我们说的电流和水流都是从一端流向另一端（可能并不是很准确），比如：电池的电子从负极流向正极，电池的负极像一个电子的生产者一样，而正极就像一个消费者或者接收者一般；还有地下水到你家的水龙头一样，地下水通过加工提取到人引用。通过这两个例子，可以得出一个结论，流的操作或者使用至少需要一个生产对象和一个接受对象。在计算机世界中已经为这两个对象命名，输入对象和输出对象。</p><p><strong>2.流的分类</strong></p><p>关于流的分类，在Java中有如下3种分类标准：</p><ol><li>按照流的流向分，可以分为输入流和输出流。</li><li>按照操作单元划分，可以分为字节流和字符流。</li><li>按照流的角色划分，可以分为节点流和处理流</li></ol><p>流的分类解读：</p><ul><li>根据流向分类：在上面的内容补充中，说流都是从一端流向另一端，说明了流有方向。所以根据流的方向可以分为输入流和输出流，辨别输入流和输出流需要选参照中心。我们以程序作为参照中心，读取本地磁盘上的文件，程序端接收，就说明该是输入流；将程序产生的数据保存到磁盘，程序段输出，就说明是输出流。在Java中所有的IO流的类都是从以下4个抽象类基类中派生出来的：InputStream&#x2F;Reader所有输入流的基类，前者是字节输入流，后者是字符输入流；OutputStream&#x2F;Writer所有输出流的基类，前者是字节输出流，后者是字符输出流</li><li>根据操作单元划分：首先需要理解什么是操作单元，我把他理解为所操作数据的最小单位。我们知道一个字符等于两个字节，字节流取数据按照一个一个字节取，字符流取数据就是一个字符一个字符取。就好比，我们用调羹喝汤，一调羹的量就好比字节，而用勺子喝汤，一勺子的量就好比字符，只不过一勺子比一调羹的量多很多，而字符是一个字节的两倍。</li><li>根据流的角色划分：节点流和处理流。节点流：<strong>可以从一个特定的数据源(称作节点)读写数据</strong>，如：内存，硬盘，文件等。处理流：<strong>可以理解为，根据实际需求在节点流的基础上进行的二次开发和封装。</strong><br>       <strong>例子1</strong>：说明处理流和节点流的关系：想象一个场景，计算机每一次读写的时候都访问硬盘，如果访问次数很频繁的话，性能表现就不佳，而且硬盘的寿命也会减少。所以为了满足这种场景，就设计了缓存流，一次读取较多数据到缓存中，以后的每一次读取都从缓存中访问，直到缓存中的数据读取完毕。用一个生活的例子解释缓存流，吃饭的时候我们不用碗装饭(缓存流)的话，每吃一口都要去电饭锅里面铲，有了碗(缓存流)之后，我们可以把饭装进碗里，吃完了碗里的，我们再去电饭锅里铲。这样就大大减少了去电饭锅里装饭的次数，提高了效率。<br>               <strong>例子2</strong>：因为我们的流的操作最小单位是字节或者字符，为了方便Java程序员使用对象，我们就需要在原来节点流的基础上进行二次开发和封装。比如我们读取一个本地的文本文件，需要一个字节流，又由于流里面是字节，而我们希望方便程序员使用对象来保存这些数据，就在该流的基础上进行开发(具体如何实现，本人暂时也不清楚)，原来的字节流就变成了一个对象流，流里面的内容不在是字节，而是对象，这样就方便了程序员对于该信息的获取。</li></ul><p>以下是关于字节流和字符流，以及节点流和处理流的详细分类图</p><p><img src="/../picture/%E6%96%87%E4%BB%B6%E4%B8%8EIO/983978b9-ae5d-4ea0-ac1b-6f502f183a77.png"></p><p><img src="/../picture/%E6%96%87%E4%BB%B6%E4%B8%8EIO/22c1ab11-4426-47fc-92d4-aae5b175bba3.png"></p><p><strong>3.关于字符流和字节流的选择</strong></p><p>之前在学校做课设的时候，每次做到文件关于文件读取的时候，关于选择字节流还是字符流的选择都是含糊不清，每次都是去网上找代码，这部分知识不是很清楚。现在重新把知识捡起来好好梳理一遍。首先不管是文件读写还是网络发送接收，信息的最小存储的单位是字节。由此可能读者又会问了，既然最小存储单元是字节，那么有了字节流为什么还要字符流呢?</p><p>**解答:**在编程领域中，由于语言的不同，中文等一些其他语言一个字就需要两个字节表示，即一个字符，所以如果不使用字符流的话，就会出现乱码等问题。在日常使用中遇到图片，音频等媒体文件采用字节流比较好，而涉及到字符操作的使用字符流比较好。</p><h2 id="使用文件对象"><a href="#使用文件对象" class="headerlink" title="使用文件对象"></a>使用文件对象</h2><p>说明： 一个File对象就是一个具体的文件或者文件夹目录（作用：指定文件或文件夹保存的路径）。让然，指定的文件或文件夹目录在电脑上不一定存在。以下代码演示了文件对象的用法以及常用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个文件对象，指定他的目录：D盘目录下的java文件夹</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\java\\test&quot;</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">()</span>  <span class="hljs-comment">//判断文件或者文件夹是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isDirectory</span><span class="hljs-params">()</span>  <span class="hljs-comment">//判断是否是文件夹</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isFile</span><span class="hljs-params">()</span>  <span class="hljs-comment">//判断是否是文件</span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>  <span class="hljs-comment">//获取文件的长度</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">lastModified</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取文件最后修改时间</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">setLastModified</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span>  <span class="hljs-comment">//设置文件最后修改时间</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">renameTo</span><span class="hljs-params">(File dest)</span>  <span class="hljs-comment">//文件重命名</span><br>    <br>注：renameto方法重新命名，指的是在磁盘上文件<span class="hljs-string">&quot;1.txt&quot;</span>变成<span class="hljs-string">&quot;2.txt&quot;</span>但是通过file.getName()获得的文件名还是“<span class="hljs-number">1.</span>txt”,无论是命名前还是命名后。<br><br>String[] list()  <span class="hljs-comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹)</span><br>File[] listFiles() <span class="hljs-comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span><br>      <br>String <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span>   <span class="hljs-comment">// 以字符串形式返回当前文件所在文件夹</span><br>File <span class="hljs-title function_">getParentFile</span><span class="hljs-params">()</span> <span class="hljs-comment">// 以文件形式返回当前文件所在文件夹</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 创建文件夹，如果父文件夹不存在，创建就无效。举例：使用第一行的file对象，如果D盘   // 根目录下没有java文件夹,则目录创建失败，java目录，test目录都没有创建。</span><br>    <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>   <span class="hljs-comment">// 创建文件夹，如果父文件夹不存在，就会创建父文件夹。举例：如果D盘根目录下没有java   // 文件夹,就会连同java文件夹一并创建，java目录和test目录都创建成功。 </span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">createNewFile</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 创建一个空文件,如果父文件夹不存在，就会抛出异常。</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">由于创建文件，父文件夹不存在就会抛出异常，所以创建文件的时候需要先创建父文件夹。使用上面提到的方法创建文件夹。例如:file.getParentFile().mkdirs();</span><br><span class="hljs-comment">*/</span><br>File[] listRoots()  <span class="hljs-comment">// 列出电脑上所有的盘符c: d: e: 等等</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>    <span class="hljs-comment">//删除文件或者文件夹</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteOnExit</span><span class="hljs-params">()</span> <span class="hljs-comment">// JVM结束的时候，刪除文件，常用于临时文件的删除</span><br></code></pre></td></tr></table></figure><h2 id="流与文件"><a href="#流与文件" class="headerlink" title="流与文件"></a>流与文件</h2><p>        在做课设的时候经常会遇到文件的读取等功能，在还没弄清楚流的时候就已经强迫使用文件操作，导致每次遇到文件读取问题都是网上copy类似代码，却不能很好的理解代码执行流程，或者理解了也很快就忘记了，因为这个记忆点并不深。所以现在打算简单的梳理下文件的读取操作。</p><p>        开始之前，我们需要思考下几个问题：1.先要搞清楚”流向”，我们把我们的程序作为参照物，我们的程序是要读取文件还是写入文件？2.是哪个文件？(即文件所在的位置)3.根据文件的类型，我们该选用什么类型的流？通过思考这几个问题，使得我们对于文件的读取流程就会很清晰了。</p><ol><li><p>假设我们程序需要读取D盘根目录下的<code>zzf.txt</code>文本文件,通过使用File构建一个对象file,并告诉我们的程序文件位于<code>D:\\zzf.txt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zzf.txt&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>告诉程序文件的位置之后，我们就需要构建一个流了。让文件数据通过流，流向程序。构建流的时候我们又需要考虑了，是输入流还是输出流，显然我们在流的章节中说道，数据是流向程序，所以我们要选用输入流。选用输入流之后还要思考,是要字节流还是字符流呢?这个问题我们要确定文件类型，显然我们这里是文本类型的，对于文本前面也提到了最好使用字符流，防止文本里面有中文字符。所以综合来说我们选用<strong>字符输入流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*try后面加括号是Java7中的技术，这样的好处是：把流定义在try()里,try,catch或者finally结束的时候，会自</span><br><span class="hljs-comment">*动关闭流。这样就不要像以前一样，需要自己写代码关闭了。</span><br><span class="hljs-comment">* 1.首先我们要使用上面生成的文件对象file，用来构建一个输入字符流fis。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file)) &#123;<br><span class="hljs-comment">//2.因为我们选用的是字符流，所以我们新建一个字符数组用来保存流中的数据，数组长度就是文件的长度</span><br>    <span class="hljs-type">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) file.length()];<br><span class="hljs-comment">//3.使用read方法把流中的数据全部保存到content字符数组中。</span><br>    fis.read(content);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过上面的步骤，我们就完成了把D盘目录下的<code>zzf.txt</code>文件内容保存到了<code>content</code>数组中，接下来我们可以   对这个数组进行很多操作，比如将数据写入一个txt文件等等。</p></li><li><p>继续完善我们的操作，我们把刚才读取的文件数据重新写入到一个新的文件中。根据步骤2中关于选择流的思考，这里我们同样需要思考，流的选择。在了解步骤2的基础下，我们可以快速的得出，我们是需要一个<strong>字符输出流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zzf.txt&quot;</span>);<br><span class="hljs-comment">//这里我们告诉程序，我们的文件是D盘根目录下的zz.txt文件</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zz.txt&quot;</span>);<br><span class="hljs-comment">//通过file1对象构建字符输出流</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file1)) &#123;<br>            <span class="hljs-type">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) file.length()];<br>            fis.read(content);<br><span class="hljs-comment">//将从zzf.txt文件中读取保存的数据content，写入到新文件zz.txt中</span><br>            fileWriter.write(content);<br><br>     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>这样我们就简单的实现了一个文件的读取。有人或许会问，你前面说的节点流和处理流你咋没     用到呢？其实回去看第一部分,再仔细分析的话我们这个字符输入输出流就是一个节点流,所       以我们可以把效率提高一点,在这个基础上我们使用缓存流。</p></li><li><p>加上缓存流，提高效率。前面也说了处理流是在节点流上进行二次开发和封装的，所以用到处理流肯定就需要节点流。就像通过文件对象构建流一样，处理流通过节点流来进行构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zzf.txt&quot;</span>);<br>     <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zz.txt&quot;</span>);<br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file1)) &#123;<br>         <span class="hljs-type">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) file.length()];<br>         <span class="hljs-comment">//使用节点流FileReader对象构建处理流BufferedReader</span><br>         <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fis);<br>         <span class="hljs-comment">//读取文件数据</span><br>         bufferedReader.read(content);<br><span class="hljs-comment">//使用节点流FileWriter对象构建处理流BufferedWriter</span><br>         <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fileWriter);<br>         <span class="hljs-comment">//写入文件数据</span><br>         bufferedWriter.write(content);<br>         <span class="hljs-comment">//有的时候，需要立即把数据写入到文件，而不是等缓存满了才写出去,这时候就需要用到flush</span><br>         bufferedWriter.flush();<br><br>     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>注意事项:</strong></p><ol><li>我们使用流的时候一般都是需要手动关闭的，上面的代码都没有写出关闭的代码，是因为我们把流的构建这一步写进了<code>try()</code>里面，所以不需要手动关闭代码，自己写的话，要么和我代码一样，要么就在流使用完之后就写一行代码关闭流。</li><li>还有一个大家可能没有考虑到的情况，我们刚才使用了缓冲流之后，如果手动关闭的话是不是需要关闭两个流呢？实际上，我们只需要关闭节点流就行了，因为处理流是在节点流的基础上构建的，我们关闭了节点流，处理流就失去了节点流，就会自动销毁。</li><li>最后说一个关于缓存流写入的问题，因为缓存流是有缓存空间的，只有缓存空间满了，缓存空间的数据才会写入到文件中。通过查看源代码发现默认设置的缓存空间是8kb。因此，当你使用缓存流读取文件的时候，如果文件大小小于8kb,没有使用flush方法的话，要写入的文件就没有数据，因为数据都在缓存区中。我们使用flush方法就可以将缓存区的数据强制写入到文件中，无论缓冲区的数据大小。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie</title>
    <link href="/2021/03/17/Cookie/"/>
    <url>/2021/03/17/Cookie/</url>
    
    <content type="html"><![CDATA[<p>不知道大家是否想过这样一个问题，比如说我们登陆淘宝之后，点击订单，点击购物车，这些都是自己的信息。通过前面的学习，我们也知道 HTTP 协议是无状态的，我们与淘宝的服务器之间，只是通过一串串字节在交流。我们发送请求，就是发给服务器一串字节流，服务器收到后作出响应，也返回一串字节流。当我们点击「购物车」，点击「订单」他怎么知道是「我」在查看购物车信息，而不是张三在查看购物车呢？</p><p>我们想到一种笨拙的解决办法：当我们点击购物车的时候，系统让你登陆账号密码，登陆之后就能正确访问你的信息了。当我们点击其他信息时，比如「订单」，系统也让你输入账号密码，这样订单信息也能正确访问了。这种方法是一种解决办法，但是给用户带来的体验很不好。cookie 就是用来维持登陆状态的东西。</p><p><strong>Cookie 是什么</strong> </p><p>简单来说就是一串字符串数据，用来区分和辨别不同用户。可以理解为「身份证」，通过身份证这一串数据，我们就能知道是谁在访问服务器。当然这一字符串可能还会包含，Cookie 的过期时间，以及一些安全协议等等。</p><p><strong>Cookie 如何维持状态</strong>当我们第一次登陆一个网站的时候，我们填写好自己的账号密码信息，向服务器发送登陆请求。服务器根据你传过来的账号密码进行判断，倘若账号密码正确，服务器就会返回登陆成功的信息，并且在返回的 response header 中使用 <code>Set-Cookie</code>  参数，设置一段随机字符串 Cookie。</p><p>当我们有了 Cookie 之后，我们发出去的所有请求，浏览器都会帮我们把 Cookie 字符串带上，服务器就根据 Cookie 信息来辨别用户，返回正确的用户信息。</p><p><strong>使用 Java 代码获取 Cookie 信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Crawler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">COOKIE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://47.91.156.35:8000/auth/login&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://47.91.156.35:8000/auth&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">loginAndGetResponse</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(COOKIE_URL);<br>        httpPost.addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>        httpPost.addHeader(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;</span>);<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, username);<br>        map.put(<span class="hljs-string">&quot;password&quot;</span>, password);<br><br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(JSON.toJSONString(map));<br>        httpPost.setEntity(entity);<br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">loginResponse</span> <span class="hljs-operator">=</span> httpclient.execute(httpPost);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getMessageByCookie(loginResponse.getFirstHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>).getValue());<br>        loginResponse.close();<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getMessageByCookie</span><span class="hljs-params">(String cookie)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(MESSAGE_URL);<br>        httpGet.addHeader(<span class="hljs-string">&quot;Cookie&quot;</span>, cookie);<br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br><br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity1</span> <span class="hljs-operator">=</span> response.getEntity();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> entity1.getContent();<br>        <span class="hljs-comment">// 设置解析编码为UTF-8</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> IOUtils.toString(is, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        EntityUtils.consume(entity1);<br>        response.close();<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用给定的用户名 username 和密码 password 进行模拟登录，然后获取服务器返回的 <code>Cookie</code>的值，并把获取到的 Cookie 带到下一次的请求中去访问个人信息。</p><p>首先新建一个 HttpPost 对象，添加所需的头部信息。 <code>Content-type</code> 告诉服务器我们要给服务器发送的数据类型。 <code>User-Agent</code> 让我们模拟浏览器的方式去访问，避免被服务器屏蔽请求。</p><p>使用 Map 对象将我们得账号密码存储起来，接着使用 JSON 工具转化为字符串，放到请求体中，执行 POST 请求，把返回的头部信息 <code>Set-Cookie</code> 的值拿到。</p><p>使用 <code>getMessageByCookie</code> 方法，把获取到的 Cookie 值当做参数传入。方法中发送了一个 HttpGet 请求，把Cookie加到请求头中，发送到服务器，并把返回的 body 数据转化为字符串，返回去。</p><p>这样就是一次使用获取 Cookie ，并使用 Cookie 的简单访问。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cookie</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection</title>
    <link href="/2021/03/15/Collection/"/>
    <url>/2021/03/15/Collection/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Collection"><a href="#什么是-Collection" class="headerlink" title="什么是 Collection"></a>什么是 Collection</h1><p><code>Collection</code> 是 Java 世界中最重要的类库，是这个类库的顶级接口。它的实现有 Set，List。而 Set 的实现又有 <strong>HashSet</strong>，TreeSet……。List 的实现有 <strong>ArrayList</strong>，LinkedList ……。也就是说我们日常使用的集合类都基本是 <code>Collection</code> 接口的实现。</p><h1 id="Collction-常用方法"><a href="#Collction-常用方法" class="headerlink" title="Collction 常用方法"></a>Collction 常用方法</h1><p><strong>C：</strong>new ArrayList()  &#x2F; new LinkedList() &#x2F; new HashSer() &#x2F;…<br><strong>R：</strong>size() &#x2F; isEmpty() &#x2F; contains() &#x2F; for() &#x2F;stream<br><strong>U：</strong>add() &#x2F; addAll() &#x2F; retainAll()<br><strong>D：</strong>clear() &#x2F; remove() &#x2F; removeAll()</p><ul><li>其中 <strong>contains()</strong> 判断 collection 是否包含某一元素</li><li><strong>retainAll()</strong> 表示<strong>当前集合只保留与指定集合的公共元素</strong>，比如下面的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCollection</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    collection1.add(<span class="hljs-number">1</span>);<br>    collection1.add(<span class="hljs-number">2</span>);<br>    collection1.add(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    collection2.add(<span class="hljs-number">2</span>);<br>    collection2.add(<span class="hljs-number">3</span>);<br>    collection2.add(<span class="hljs-number">3</span>);<br><br>    collection2.retainAll(collection1);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 <strong>collection2</strong> 进行 <strong>retainAll()</strong> 操作之后得到的结果就是与** collection1** 相同的元素，即：2，3。</p><ul><li><strong>removeAll() <strong>正好与</strong> retinAll() 相反，</strong>表示**移除当前集合移除与指定集合相同的元素，比如下面代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCollection</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>     collection1.add(<span class="hljs-number">1</span>);<br>     collection1.add(<span class="hljs-number">2</span>);<br>     collection1.add(<span class="hljs-number">3</span>);<br><br>     <span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>     collection2.add(<span class="hljs-number">2</span>);<br>     collection2.add(<span class="hljs-number">3</span>);<br>     collection2.add(<span class="hljs-number">4</span>);<br><br>     collection2.removeAll(collection1);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>collection2</strong> 进行 <strong>removeAll() <strong>操作之后，</strong>collection2</strong> 中的元素为：4。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 是<strong>有序且元素可重复</strong>的集合</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>ArrayList 底层是个数组实现</strong>，具有动态扩容的特点。说到数组，我们印象中的数组都是有容量限制的，都有一个固定大小，那 ArrayList 的动态扩容是怎么实现的呢？</p><p><strong>ArrayList 动态扩容原理</strong>：当 ArrayList 满了的时候，会自动扩容。ArrayList 会创建一个新的更大的空间的 List ，把原来满了的 List 的数据，复制到新的 List 中，并把原来满的 List 丢弃。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>LinkedList 底层是链表实现</strong>，LinkedList 在日常使用中很少使用到。</p><h2 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h2><p>ArrayList 是 Java 世界中，最常用的实现。既然是最常用的实现，为什么我们还需要 LinkedList? 既然有两种实现方式，那么两者的的区别和优缺点又是什么？</p><p>通过两者的底层实现可以发现他们各自的优势和区别。</p><p>因为 <code>ArrayList</code> 底层是数组实现，根据数组这一数据结构的特点，可以知道，数组用于查询，速度非常快。但是，数组做增删的操作就很比较慢。</p><p>而 <code>LinkedList</code> 的底层是链表实现，根据链表这一数据结构的特点，也很容易知道，链表的增删速度非常快，而对于查询来说就比较慢。</p><p>因此，综上所诉。对于查询需求较多的，我们可以使用 <code>ArrayList</code> 的实现，对于增删需求较多的，就使用 <code>LinkedList</code></p><h2 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h2><p>我们经常往 ArrayList 中添加元素，在们看来 ArrayList 好像是一个无限容量的空间一样，可以一直往里面丢东西。实际上是 ArrayList 的扩容机制在搞鬼，每当容量不足的时候，他就会在背后帮我们自动扩容，而我们是感知不到这个过程的，扩容机制给我们造成了无限容量的假象。</p><p>我们直接查看 ArrayList 的 add 方法源代码，如下。</p><p><img src="/../picture/Collection/7f8d3ac4-c857-44f1-8059-0f25f5d926df.png" alt="image.png"><br>可以发现在添加元素前，使用了 ensureCapacityInternal 方法，来确保可以添加。我们可以在 ensureCapacityInternal 的实现方法中找到 grow 方法，这个方法就是 ArrayList 扩容的秘密。</p><p><img src="/../picture/Collection/5b73daa1-eb23-4706-b5a4-67b333140334.png" alt="image.png"><br>可以看到代码中的 newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1)，表示的扩容后，新容量等于旧容量加上旧容量右移一位。右移可以理解为除以 n^2，此处就是旧容量除以1的2次方，相加之后新容量就是旧容量的1.5倍。<strong>ArrayList 扩容机制简述就是：创建一个更大的空间，空间容量为原来容量的1.5倍，然后把所有元素拷贝过去，完成扩容。</strong></p><p>说到这里还有个问题没有解决，既然 ArrayList 容量是有限的，那么<strong>我们直接 new 一个 ArrayList 的初始容量是多少呢？</strong>其实源代码已经给出答案了。</p><p><img src="/../picture/Collection/dd0e6e82-2b84-4a18-a78d-b61ffa2ad050.png" alt="image.png"><br>构造方法注释中标明，初始化容量是10。但我用 debug 调试的时候，发现初始容量并不是我们 new 的时候就创建好了，而是当我们往里面添加第一个元素时，触发了 ArrayList 的扩容机制，扩容成一个容量是10的新空间，再把我们要添加的元素放进新空间中。这属于懒加载机制，当我们需要添加元素时，才真正开辟空间。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 是<strong>无序且元素不可重复</strong>的集合。在 java 世界中，判断两个元素是否相同使用 <code>equals</code>  方法。</p><h2 id="简单的-Set-实现"><a href="#简单的-Set-实现" class="headerlink" title="简单的 Set 实现"></a>简单的 Set 实现</h2><p>我们可以顺着 List 的特性，以及 Collection 的 Contains() 方法来简单实现一个 Set。因为 Set 不包含重复元素，而且 Contains 方法就是判断元素是否重复。因此，只要往 List 中添加元素时，进行 Contains 判断，元素不重复就往 List 中添加，这样就能得到一个不包含重复元素的 List，也就是一个手写的简单 Set 实现。</p><h2 id="Java-世界的高效-Set-实现-HashSet"><a href="#Java-世界的高效-Set-实现-HashSet" class="headerlink" title="Java 世界的高效 Set 实现 HashSet"></a>Java 世界的高效 Set 实现 HashSet</h2><p>虽然我们手写的 Set 也能用，但是相比 Java 中其它的 Set 实现，性能差距不知差了多少。Java 世界中最高效的 Set 实现当属于 <code>HashSet</code> 。</p><h3 id="一、HashSet-实现简述"><a href="#一、HashSet-实现简述" class="headerlink" title="一、HashSet 实现简述"></a>一、HashSet 实现简述</h3><p>HashSet 之所以高效是因为他的背后是 HashBucket，即：哈希桶。每个哈希桶对应一个 hashCode。因此，每次往 HashSet 中添加元素的时候，首先通过 hash 运算，计算出它的 hashCode，再与哈希桶的 hashCode 进行比对，相同就把元素加入该哈希桶中。</p><h3 id="二、hashCode"><a href="#二、hashCode" class="headerlink" title="二、hashCode"></a>二、hashCode</h3><p>在了解 HashCode 之前，先了解下 <strong>Hash 运算</strong>。Hash 运算就是把我们数据变成一个哈希值，是一个单向映射操作。例如：假设 Hash 运算把名字变成姓氏，于是就是有「张三」-&gt;「张」、「李四」-&gt; 「李」，以此类推。Java 世界中的 Hash 运算有它<strong>自己的一套运算规则</strong>，我们只需要知道经过 Hash 运算会返回一个 int 值就行了。</p><p>hashCode 是数据通过 Hash 运算得到的值。我们可以通过 hashCode 来初步判断是否同一元素。</p><p>在 Java 世界中对象返回的 HashCode 都遵守以下约定：</p><ul><li><strong>同一个对象得到的 hashCode 相等</strong></li><li><strong>两个对象 <code>equals</code> 为 true，hashcode 相等</strong></li><li><strong>两个对象不等，hashcode 可能相等</strong></li></ul><h2 id="判断对象是否相等"><a href="#判断对象是否相等" class="headerlink" title="判断对象是否相等"></a>判断对象是否相等</h2><p>假设存在一个 Person 对象，它有 name 属性。现在我们要使得名字相同的对象为同一对象，应该怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面提到过判断是否重复我们可以使用 equals 方法，因此我们可以该方法来解决。假如我们初始化 person1，person2，他们的名字都是「张三」。然后我们再调用 equals 方法判断 <code>person1.equals(perons2)</code> ，结果返回的却是 false，为什么？</p><p>在我们看来，名字相同的人就是同一个对象，可是计算机却不是这么认为的，我们查看 Object 的 equals 方法发现，它比较的实际上是内存地址。因为是两个对象，所以他们指向的内存地址不同。尽管内存中的值相等，也没用。</p><p>因此，我们就需要重写 equals，hashCode 方法来达到相同名字为同一对象的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name.hashCode();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) obj;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(person.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 equals 中比较两个对象的名字是否相等，相等返回 true。同时遵守「两个对象 <code>equals</code> 为 true，hashcode 相等」的约定，所以我们再 hashCode 方法中根据 name 来返回 HashCode，当 name 相同时就会返回相等的 HahsCode。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 前世今生</title>
    <link href="/2021/03/11/HashMap%20%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <url>/2021/03/11/HashMap%20%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>要了解 HashMap 首先要先了解哈希表这种数据结构。哈希表是根据关键码值进行访问的数据结构。我们可以类比成现实生活中的电话本，如图所示。<br><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/9f0909d6-6a84-4b32-bdc3-fc840bdea650.png" alt="未命名绘图.png"><br>假设这个人交际能力特别强，他保存了很多人的电话，这个电话本就会很厚，当你想要查找某个人的电话时，就会非常费时。因此我们可以根据姓的首字母，分类排序，把张三放到 Z 里面，李四放到 L 里面，以此类推。通过这种方法，我们得找人效率就会大大提高。</p><p>我们已经按照刚才的方法分好类了，可以看到 Z 分类下面有多个名字，我们把这样一组称作<strong>哈希桶，</strong>把 Z 叫做<strong>哈希值，</strong>整个电话本就是一个<strong>哈希表，</strong>我们还把一个哈希值对应多个数据，这种现象叫做<strong>哈希碰撞。</strong><br><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/844b1fe2-e394-408f-844a-70aaae894537.png" alt="image.png"></p><p>使用哈希表的好处就是 O(1) 的平均查找，插入和删除时间。致命缺陷就是哈希值的碰撞（哈希碰撞）。在 Java 世界中对于 哈希表的实现就是 <strong>HashMap</strong>。</p><h2 id="Java-7中的-HashMap"><a href="#Java-7中的-HashMap" class="headerlink" title="Java 7中的 HashMap"></a>Java 7中的 HashMap</h2><p><strong>经典的哈希表实现：数组 + 链表，</strong>其中链表采用<strong>头插法（每次有新元素都放到第一位）</strong></p><h3 id="HashMap-构造方法"><a href="#HashMap-构造方法" class="headerlink" title="HashMap 构造方法"></a>HashMap 构造方法</h3><p>查看 HashMap 源代码，它默认的初始大小是 <code>1 &lt;&lt; 4 </code> ，表示位运算，等价于 1 * 2^4 即等于16，因此默认大小就是16。且注释中规定容量必须是2的幂。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/cbc5cd9a-5515-4432-8e2d-009399f03b07.png" alt="image.png"><br>源代码中定义了默认的 <code>DEFAULT_LOAD_FACTOR</code> （负载系数）是 0.75</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/33561655-26c8-42db-8bc5-cd58b28182b1.png" alt="image.png"><br>默认的构造函数，把默认的初始容量，以及默认的负载系数当参数传递给重载的构造函数。<strong>注意事项</strong>：当我们调用 HashMap 的构造函数时，哈希桶并没有开辟出来，只有第一次往里面 put 元素进去的时候，空间才会开辟出来，这样避免了空间浪费。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/97b7180f-0e42-461d-9e0a-be42e49e50dd.png" alt="image.png"><br><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/61f58587-73d5-4448-9fff-b9592330c383.png" alt="image.png"></p><h3 id="HashMap-put-方法"><a href="#HashMap-put-方法" class="headerlink" title="HashMap put 方法"></a>HashMap put 方法</h3><p><strong>inflateTable 方法</strong></p><p>put 方法首先是一个判断，判断表是否是一个空表，如果是就调用 <code>inflateTable</code> 方法，把 threshold 参数传进去。因为使用 HashMap 构造方法时，以及将初始化容量赋值给 threshold，所以他的值就是容量的值。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/9a9c2b27-f7df-4bad-ac91-137539e78dec.png" alt="image.png"><br>执行 <code>inflateTable</code> 方法，我们可以看到该方法对于我们传来的容量值进行了一个向上取2次幂的操作。前面注释规定容量必须为2次幂，当我们自定义容量不为2次幂时，他就帮我们向上转为2次幂。例如：我们定义初始容量为17，他就会帮我们转化成32；初始容量定为5，帮我们转成8，这样就达到了容量必须为2次幂的要求。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/4c056e17-e2f0-4412-b312-286bf845742b.png" alt="image.png"></p><p><strong>hash 方法</strong></p><p>hash 方法把我们输入的 key 值，通过他特定的算法，返回一个 int 值。既然我们知道了元素对应的 hash 值，那么我们应该如何设计一个映射，把元素放到它对应的哈希桶里呢？就像「张三」对应 “Z” 这个桶一样。</p><p>数据结构课程中提到过<a href="https://baike.baidu.com/item/%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/10739384?fr=aladdin">取模运算</a>，我们把 hash 值通过取模运算得到的结果，跟哈希桶编号进行比对，一致就放在该哈希桶里。但是这样做存在两个缺点：由于 hash 值可能得到负数，负数取模运算还是负数，而哈希桶编号是正数。因此遇到 hash 是负数的情况，需要转化成正数；其次，使用取模运算较慢。</p><p>让我们看看源代码中 <code>indexFor</code> 方法，是如何设计其中的映射关系的。</p><p><strong>indexFor 方法</strong> </p><p>我们可以在 put 方法中找到这一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br></code></pre></td></tr></table></figure><p>其中把 hash 值和表的长度（表的长度为哈希桶个数，即为初始容量大小）当做参数，调用 indexFor 方法计算出该元素对应哈希桶的编号。</p><p>我们点进去查看具体的方法实现</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5dd68aec-3c81-4527-91d8-8fc3ac1d7acf.png" alt="image.png"><br>如图所示，他把 hash 值 length - 1 进行了<strong>按位与运算</strong>，得到的结果就是索引坐标。它这样做的目的在于提高效率，与运算比我们刚才说的取模运算要快很多。</p><p><strong>为什么容量必须是2的幂呢？</strong>我们前面一直说到容量必须是2的幂，是因为方便这里进行与运算。2的正数次幂的二进制值首位是1其它全部都是0，例如：2^3 &#x3D; 1000，2^4 &#x3D; 10000。因此当他们再减1时，得到的值都会变成1，例如：2^3 -1 &#x3D; 111，2^4 -1 &#x3D; 1111。使用这种都是1的数与 hash 值进行与运算，得到的坐标就与 hash 值有关了。假设我们初始容量是 2^4，减1之后与 hash 值进行按位与运算得到的坐标如下。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/89bb8103-15da-48af-9562-e9c28389b990.png" alt="QQ图片20210310211257_看图王_看图王.jpg"><br>假如我们不用2次幂来设定容量，我们设定容量为7，与 hash 进行与运算得到的坐标如下。你可能会想，这样不是也可以得到坐标吗？这样可以得到没错，但是会发现有些桶永远是空着的。如下图所示，当我们的 hash 值无论为多少，和110进行与运算后，最后一位一定是0，因此必然得不到101，001，011坐标，所以哈希桶坐标为5，1，3的桶永远都是空着的。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/36c09fd7-7821-4941-96b2-0289ef6bb055.png" alt="QQ图片20210310212221_看图王.jpg"></p><p><strong>addEntry 方法</strong> </p><p>接着 put 方法往下看，addEntry 方法往指定坐标的哈希桶里面添加元素。具体的实现方法如下</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/06ecc0c9-a6fc-49da-aea2-053f3a014339.png" alt="image.png"><br>可以看到，添加元素前前。进行了一个判断，当哈希桶中的元素 size 大于等于 threshold（初始化容量 * 负载系数，即默认的为 16*0.75 &#x3D; 12），并且指定的桶不能为空时，执行 resize 操作，新的容量是原来容量的2倍。</p><h3 id="HashMap-扩容操作"><a href="#HashMap-扩容操作" class="headerlink" title="HashMap 扩容操作"></a>HashMap 扩容操作</h3><p>以下是 resize 方法的具体实现<br><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/8f2d9003-c2fb-4b5e-b296-f838b51900a9.png" alt="image.png"><br>扩容的时候容量为原来的2倍，然后把原来所有的元素全部迁移到新的中去。元素的迁移过程使用了 transfer 方法</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/6532fd0a-4f7b-4d61-ad23-afa4e8517beb.png" alt="image.png"><br>transfer 方法遍历旧表中每一个桶里面的元素，重新进行 hash 运算，得到新的值，再把该元素放到新表中，对应的哈希桶中。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>在多线程环境中，java7中 HashMap 的实现容易成环，形成死锁，详见<a href="https://coolshell.cn/articles/9606.html">文章</a>。</li><li>可以通过精心构造的 HTTP 请求，使得所有元素都落入到同一个桶中，引发 DOS。</li></ul><h2 id="Java-8中的-HashMap"><a href="#Java-8中的-HashMap" class="headerlink" title="Java 8中的 HashMap"></a>Java 8中的 HashMap</h2><p><strong>实现：数组 + 链表&#x2F;红黑树，</strong>其中链表采用<strong>尾插法（每次有新元素都放到最后一位）</strong></p><h3 id="链表转为红黑树"><a href="#链表转为红黑树" class="headerlink" title="链表转为红黑树"></a>链表转为红黑树</h3><p>java 8中使用了新的数据结构，红黑树。但并不全是红黑树，原来的链表也是存在的。java 8中给链表中的元素设定了一个阈值，大于等于这个阈值就会转化成红黑树，如下图所示。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5290d35d-3571-4bf1-bf6e-4747f2405511.png" alt="image.png"><br>java 8 设定这个树形化的阈值 <code>TREEIFY_THRESHOLD</code> 为8，当链表中元素个数大于等于8时，就会转化为红黑树。 </p><p><strong>那么为什么要数量大于等于8时，才转化为红黑树呢？</strong>这个在源代码中也有解释，下图截取自 java 8的源代码注释。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/841cce86-ee23-43cf-9a79-b8b53fd24c69.png" alt="image.png"><br>通过图中的解释可以知道，我们的 hash 值是遵循<a href="https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/1442110?fr=aladdin">泊松分布</a>的。每个桶中有0个元素的概率是 0.60653066，以此类推，可以看到桶中有8个元素的概率是 0.00000006，超过8的概率小于十万分之一，这个概率已经非常小了。因此树形化阈值才会设定为8。</p><h3 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h3><p>java 8在原来 HashMap 扩容的基础上改进了一点，原来的 HashMap 扩容之后不保证顺序，java 8则保持了扩容之前与之后的元素插入顺序一致，这样降低了线程出现问题的概率，但还是没有彻底解决线程安全问题。在多线程环境下请使用 <strong>ConcurrentHashMap。</strong></p><p>java 7中旧表中的元素要重新进行 hash 运算得到 hash 值，再把它放到新表中，而 java 8对这一方法进行了优化。</p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/d6b6b55c-a0d7-4ab5-b969-c1117d960eba.png" alt="image.png"><br>假设图左边的初始容量为16，扩容之后诚意2得到的容量为32。 <code>1001001......11011</code> 这个哈希值，计算出它对应的坐标，因此与16 - 1的二进制，进行与运算，得到1011。而扩容到32时，按照原来的方法重新计算坐标得到 11011。从中我们可以发现，扩容之后，hash 值由原来的4位参与运算，变成了5位，我们把新增加的那一位称作<strong>高位</strong>，其他不变的称作<strong>低位。</strong>对应图中的高位就是标红的1，低位就是1011。进而我们也可以知道，扩容之后元素对应的坐标他的低位是不会变的，<strong>新坐标就取决于高位的值。</strong></p><p><img src="/../picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/49cbfaf9-6121-4e26-9d7a-099817a264f3.png" alt="image.png"><br>如图，高位为1时，原来的坐标 1011对应十进制是11，扩容之后新坐标 11011对应十进制是27，坐标发生了改变。高位为0时，原来的坐标还是1011，新坐标也是1011，新坐标与原来坐标相等。因此可以总结规律：<strong>高位为0，扩容之后新旧坐标相等；高位为1，新坐标 &#x3D; 1 + 旧坐标。</strong></p><p>java 8中 HashMap 就是根据这一规律进行扩容，这样计算新坐标比 java7重新进行坐标运算要快上不少。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/03/04/Git/"/>
    <url>/2021/03/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p>了解一门新的技术或者工具都要问这几个问题：它是什么？它有什么用？</p><p><code>Git</code> 是世界上最先进的<code>分布式</code>版本控制系统。这里又有两个小问题：什么是「分布式」？「版本控制」又是什么？</p><p>首先讲一下「版本控制」。什么是版本控制呢，只要玩过游戏就能很好的理解，「版本控制」就像游戏的「存档」一样。一般我们打 boss 前都会存档，我们可能存在多个存档，每次想回到哪个时间点都能回去。我们遇到很难打的 boss ，可以借号给朋友，让朋友帮你过，朋友打完也可以存档，这样你玩的时候已经通关了。这就是「多人协作」的好处，同样 Git 也是支持多人协作的。相比游戏「存档」，Git 还可以清楚的知道每个存档你做了什么事，比如：你在存档 A 过了新手村，存档 B 击杀了 boss。游戏就不同了，「存档」和「事件」的对应关系，需要自己去记忆，存档多了就会很不方便。 </p><h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><p>git add</p><p>git commit</p><p>git status</p><p>git diff</p><p>git log –pretty&#x3D;oneline</p><p>git reset –hard head^</p><p>git reflog</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>远程仓库熟悉的有 <code>GitHub</code>，<code>Gitee</code>。我们可以把我们的本地仓库推送到远程仓库上去，接下来都以 GitHub 仓库举例，练习。</p><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><p>由于本地的 Git仓库和 GitHub 的传输是通过 SSH 加密的，我们需要做一些简单设置。在用户主目录下，先检查电脑是否有 <code>.ssh</code> 文件夹，如果有，在看下有没有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 这两个文件。如果有，就跳到第二步。</p><p>一， 打开 <code>Git Bash</code>，输入如下命令命令，创建 SSH Key，记得把邮箱换成自己的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<br></code></pre></td></tr></table></figure><p>过程中出现提示，一直回车即可。成功的话，就可以在用户主目录下看到 <code>.ssh</code> 文件夹，以及该文件夹下的 <code>id_rsa</code>，<code>id_rsa.pub</code> 两个文件。</p><p>二，在 GitHub 添加 SSH Key。把刚才的 id_rsa.pub 文件里的内容复制到 GitHub 要添加 SSH Key 的地方，完成添加即可。GitHub 添加 SSH Key 的位置自行搜索。</p><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>使用如下命令关联远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote add origin 仓库地址<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 前后端基础架构原理</title>
    <link href="/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>当我们打开浏览器去访问一个网站时，发生了什么？在了解整个过程之前，我们应该先了解一些基本概念</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>首先我们需要明确一点的是，当我们访问一个网站的时候，实际上是在与一个主机进行交互。就像去商店购物一样，只要你不差钱，商店有的，它都能提供给你。</p><h3 id="主机（Host）"><a href="#主机（Host）" class="headerlink" title="主机（Host）"></a>主机（Host）</h3><p>主机简单来说就是一台电脑，只不过它的作用更多，可以响应浏览器发送的请求。我们平时所用的电脑也可以充当一台服务器，只不过需要一些专业的操作，才能把它变成主机。</p><p>那么问题来了，世界上有很多台主机，我们在浏览器输入 <a href="http://www.taobao.com/">www.taobao.com</a> 的时候，它是怎么帮我们找到淘宝的主机的？</p><h3 id="IP-与域名"><a href="#IP-与域名" class="headerlink" title="IP 与域名"></a>IP 与域名</h3><p>每个 IP 对应一个主机，因此只要我们知道 IP 地址就可以正确地找到对应的主机了。说到这里可能还有个疑问，我们明明输入的是一个网址，也没有看见 ip 地址啊，他怎么知道我访问的是那一台主机？这个就要说到 DNS 的功劳了。首先用 ip 去找对应的主机是没问题的，我们输入的网址本质上就对应一个 ip，只是我们没有察觉。DNS 就是把输入的网址，找到对应的 ip ，然后返回给我们。这样我们就本能的以为，只要输入网址就能找到对应的网站了，这是 DNS 给我们的错觉。</p><p>DNS 是个网络上的服务，他包含了域名和 ip 地址的映射关系。windows 本机上有个 hosts 文件，可以自己添加和修改网址和 ip 的对应关系，假如我们把 <a href="http://www.taobao.com/">www.taobao.com</a> 对应的 ip 改成 127.0.0.1，这样在浏览器再次输入<a href="http://www.taobao.com/">www.taobao.com</a> 就找不到原本的淘宝网站了，而是映射到本机。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>现在请假设一个场景：你有一台电脑，电脑连了一根网线，同时电脑上开了好几个程序，像 QQ、淘宝、微信。你有没想过，一根网线传的数据，他怎么知道哪个是 QQ 要的数据，哪个是淘宝返回的数据呢？</p><p>区分不同应用的数据，我们就用到了<strong>端口</strong>，不同应用他所对应的端口不一样的。网线中传输的数据，每个数据包都有对应的端口信息，就像一列火车一样，每个人的目的地不一样，有的在广州下车，有的在深圳下车，目的地不一样。数据也是这样，根据端口到达不同的应用中去。</p><p>我们可以经常看到网址前面有 http 或 https，他们都对应着不同的端口号。HTTPS 协议的默认端⼝是443，HTTP协议的默认端口是80。别看我们访问网站的时候没有看到端口号，其实浏览器已经在后面偷偷帮我们补上了。</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>当我们向远程的服务器发起请求时，TCP 协议就开辟了一条双车道的「高速公路」，不过在这条路上跑的是数据。同时数据也是一个一个的字节，所以也叫字节流，<strong>TCP是基于流的协议</strong>。由于是双车道，所以我们可以和服务器同时接受和发送数据，这叫做<strong>全双工协议，</strong>tcp就是全双工协议。半双工协议就是类似生活中的「对讲机」，只有对方说完，我们才能说话。</p><p><strong>TCP 协议本质上就是规定字节流如何发送和接收</strong></p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>Http 是在 TCP 协议之上的一层协议。Http 定义了文本之外的东西如何被传输。我们把发送给服务器的字节流叫做 <strong>HTTP Request</strong>，比如我们访问豆瓣首页。我们就会向服务器发送如下字节流。</p><p><strong><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/a46104e5-ab13-4c06-8d67-fc25533364f0.png" alt="image.png"></strong><br>服务器收到请求之后就会返回一个 <strong>HTTP Response <strong>字节流，除了 Headers 之外，还返回了</strong> HTTP Response Body（响应体）</strong>，response body 可以是文本，也可以是及二进制数据，包括图片、声音、下载的文件等。</p><p><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/d1b5fc66-e420-4974-a253-2d14fc46da93.png" alt="image.png"><br>刚才访问的豆瓣网站，就返回了一个 response body，一个 html 文件。我们得浏览器收到这个 html 文件，就会根据他的结构，标签去解析和展示他。我们看到的页面就是浏览器解析之后的样子。</p><p><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/b594a1c8-ea35-46ee-9093-5ff9fe6ae319.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 包冲突解决过程</title>
    <link href="/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>记录一次 maven 包冲突解决过程，项目地址<a href="https://github.com/hcsp/resolve-package-conflict">链接</a>。</p><h2 id="查看错误方法"><a href="#查看错误方法" class="headerlink" title="查看错误方法"></a>查看错误方法</h2><p>首先要将项目克隆到本地，然后运行，找到出错的位置，以及出错的信息。<br> <img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb20e3c-d218-44f4-a995-61be864a19e4.png" alt="image.png"><br>如图所示，错误的位置在 MainTest.java 文件第六行，错误信息 <code>NoSuchMethod</code> ，表示没有找到这个方法。根据位置提示，一层一层往下找，发现原来是 A.java 这个类中调用的 <code>getJsonpFunction</code> 方法找不到</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb93ac6-bf86-4f27-8f3f-5b0e0f6978ce.png" alt="image.png"></p><h2 id="查看包冲突"><a href="#查看包冲突" class="headerlink" title="查看包冲突"></a>查看包冲突</h2><p>通过使用 maven helper 插件查看包的依赖树。如图所示，spring-web:5.1.8.RELEASE 版本和 spring-web:4.3.6.RELEASE 版本冲突了。图上的 4.3.6 版本为红色，可知，maven 使用的是 5.1.8 版本。我们根据 maven 解决包冲突的就近原则来看，5.1.8 离项目的距离为1，4.3.6 的距离为2，因此保留5.1.8版本，再次证实了这一点。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/bcd7d3b1-5625-4466-9bff-4d7fa1cf4a7c.png" alt="image.png"></p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>既然知道了是 spring-web 这个包的问题。我们就访问 maven 仓库，找到对应的版本，访问他的 github 主页。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/529dcfcc-07f4-4315-b0bc-e1fc3b11c480.png" alt="image.png"><br>找到了 github 仓库，进入报错的那个类，通过切换 tags 来切换不同版本对应的源代码，两者进行比较。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/cb13c43d-19fe-41db-9552-443f008f598a.png" alt="image.png"><br>对比发现在5.1.8版本 org.springframework.http.converter.json.MappingJacksonValue 中不存在 <code>getJsonpFunction</code>  这个方法。而 4.3.6 中却有。因此可以断定，我们项目本该使用 4.3.6 版本，而 maven 帮我们剔除了 4.3.6 版本，保留了 5.1.8 版本，导致找不到 <code>getJsonFunction</code> 而报错。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/a26925af-9758-4767-8e5a-107165edd81b.png" alt="image.png"></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>知道了冲突的原因，我们就只需要把 5.1.8 版本的依赖注释掉就行，这样 maven 就会帮我们加载 4.3.6 版本的包了。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/4efcceb9-a459-4eb2-bda3-58ab8f6dda90.png" alt="image.png"><br>同时也可以将 5.1.8 版本的依赖改成 4.3.6 版本，解决冲突。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 与命令行</title>
    <link href="/2021/03/01/Java%20%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2021/03/01/Java%20%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>在日常写 Java 程序的工作中，运行，debug 等等操作，本质上都是在进行命令行操作。我们在 IDE 上点击运行，Java 程序就会运行，实际上 IDE 在背后帮我们进行了命令拼接。</p><p>我们可以在 IDEA 中编写一个简单的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> zzf;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zzf</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/2/28/028 21:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 zzf 包下面有个 Main.java 类，里面有个 main 方法输出了 “Hello World”。在 IDEA 中点击了运行按钮之后，控制台会有一串命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">D:\java\jdk\bin\java.exe -javaagent:D:\software\Idea\ideaIU-2019.2.3.win\lib\idea_rt.jar=56956:D:\software\Idea\ideaIU-2019.2.3.win\bin -Dfile.encoding=UTF-8 -classpath D:\Java\jdk\jre\lib\charsets.jar;D:\Java\jdk\jre\lib\deploy.jar;D:\Java\jdk\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk\jre\lib\ext\cldrdata.jar;D:\Java\jdk\jre\lib\ext\dnsns.jar;D:\Java\jdk\jre\lib\ext\jaccess.jar;D:\Java\jdk\jre\lib\ext\jfxrt.jar;D:\Java\jdk\jre\lib\ext\localedata.jar;D:\Java\jdk\jre\lib\ext\nashorn.jar;D:\Java\jdk\jre\lib\ext\sunec.jar;D:\Java\jdk\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk\jre\lib\ext\sunmscapi.jar;D:\Java\jdk\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk\jre\lib\ext\zipfs.jar;D:\Java\jdk\jre\lib\javaws.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\lib\jfxswt.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\management-agent.jar;D:\Java\jdk\jre\lib\plugin.jar;D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\idea-work\testDemo\out\production\testDemo zzf.Main<br></code></pre></td></tr></table></figure><p>当我们把该命令复制到 CMD 窗口运行的时候，同样控制台会打印 “Hello World”</p><h2 id="Java-执行过程"><a href="#Java-执行过程" class="headerlink" title="Java 执行过程"></a>Java 执行过程</h2><p>我们平时写的源代码（.java 文件），需要编译成字节码（.class 文件），然后再给到 jvm 去解释执行。jvm 只认识字节码，多个 class 文件可以打包成 jar 包来执行。</p><h3 id="args-参数"><a href="#args-参数" class="headerlink" title="args 参数"></a>args 参数</h3><p>我们写 Java 程序，main 方法里面都有一个 args 参数，实际上这个参数是可以从命令行获取的。编写以下程序获取打印 args 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>System.out.println(java.util.Arrays.toString(args));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令编辑和运行该程序</p><p><img src="/../picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/cb5a1ca0-47b2-4f27-adf4-23b88ff755c8.png" alt="image.png"><br>可以看到使用 <code>java Main</code> 运行时，打印为空字符串，而在后面添加 <code>1 2 3</code> 三个参数时，打印 <code>[1,2,3]</code> 。</p><p><code>java Main 1 2 3</code> 表示，调用 java 这个可执行程序，然后把 <code>Main 1 2 3</code> 这四个参数传递个 java。java 把 Main 这个类名拿出来，并且运行这个类，后面的参数 <code>1 2 3</code> 当做这个类的参数，传递给这个类的 main 方法。</p><h3 id="jvm-中的系统属性和环境变量"><a href="#jvm-中的系统属性和环境变量" class="headerlink" title="jvm 中的系统属性和环境变量"></a>jvm 中的系统属性和环境变量</h3><p>系统属性和环境变量是完全不同的东西，系统属性只在 jvm 中有效，不像环境变量可以继承属性。</p><p>我们可以在代码中使用 <strong>System.getenv()</strong> 来获取当前环境变量，使用 <strong>System.getProperty()</strong> 获取系统属性。我们可以编写如下代码（其中 java.version 是 jvm 自带的系统属性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>    <span class="hljs-comment">// 打印 args 参数</span><br>System.out.println(<span class="hljs-string">&quot;args: &quot;</span> +java.util.Arrays.toString(args));<br>    <span class="hljs-comment">// 打印名为 zzf 的环境变量</span><br>System.out.println(<span class="hljs-string">&quot;env: &quot;</span> +System.getenv(<span class="hljs-string">&quot;zzf&quot;</span>));<br>    <span class="hljs-comment">// 打印名为 zzf 的系统属性</span><br>System.out.println(<span class="hljs-string">&quot;System Property: &quot;</span> +System.getProperty(<span class="hljs-string">&quot;zzf&quot;</span>));<br>    <span class="hljs-comment">// 打印名为 java.version 的系统属性</span><br>System.out.println(<span class="hljs-string">&quot;Java version: &quot;</span> +System.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先使用 <code>export zzf=helo</code> 给当前环境添加环境变量 zzf，值为 hello，然后运行。</p><p><img src="/../picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/f9e53a89-e89f-4f30-ae14-bf89b7712e10.png" alt="image.png"><br>可以发现系统属性 zzf 并没有，打印为 null。而由于 jvm 存在系统属性 java.version，所以正确打印出版本号。要传入系统属性给 jvm 我们需要使用 <strong>-D</strong> 参数，如图所示。</p><p><img src="/../picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/38903da7-6c08-4b00-bbe3-39cc1fb23f9a.png" alt="image.png"></p><h3 id="java-代码中的包"><a href="#java-代码中的包" class="headerlink" title="java 代码中的包"></a>java 代码中的包</h3><p>假设有如下代码 zzf.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">zzf</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">0</span>]));<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">1</span>]));<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">2</span>]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码引用了第三方的包 <code>org.apache.commons.lang3.StringUtils</code> ，当我们使用 javac 编译的时候会报错，找不到这个包。因此，就需要指定这个包的目录，假设 <code>commons-lang3-3.9.jar</code> 文件和 zzf.java 文件在同一目录下，我们就可以使用 -classpath（简写 -cp），指定文件的位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -cp commons-lang3-3.9.jar zzf.java<br></code></pre></td></tr></table></figure><p>这样就可以编译通过。但是在运行 java 程序的时候，需要同时指定引用的包的位置，还需要指定 zzf.class 文件位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ./commons-lang3-3.9.jar:. zzf 1 2 3<br></code></pre></td></tr></table></figure><p> 该命令指定了第三方包的位置，以及 zzf.class 文件的位置。由于 zzf.class 文件是在当前目录，所以用 “.” 来表示。在 Linux 中多个目录用 “:” 隔开，Windows 使用 “;” 隔开。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到这个命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">D:\java\jdk\bin\java.exe -javaagent:D:\software\Idea\ideaIU-2019.2.3.win\lib\idea_rt.jar=56956:D:\software\Idea\ideaIU-2019.2.3.win\bin -Dfile.encoding=UTF-8 -classpath D:\Java\jdk\jre\lib\charsets.jar;D:\Java\jdk\jre\lib\deploy.jar;D:\Java\jdk\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk\jre\lib\ext\cldrdata.jar;D:\Java\jdk\jre\lib\ext\dnsns.jar;D:\Java\jdk\jre\lib\ext\jaccess.jar;D:\Java\jdk\jre\lib\ext\jfxrt.jar;D:\Java\jdk\jre\lib\ext\localedata.jar;D:\Java\jdk\jre\lib\ext\nashorn.jar;D:\Java\jdk\jre\lib\ext\sunec.jar;D:\Java\jdk\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk\jre\lib\ext\sunmscapi.jar;D:\Java\jdk\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk\jre\lib\ext\zipfs.jar;D:\Java\jdk\jre\lib\javaws.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\lib\jfxswt.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\management-agent.jar;D:\Java\jdk\jre\lib\plugin.jar;D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\idea-work\testDemo\out\production\testDemo zzf.Main<br></code></pre></td></tr></table></figure><p>先不管 <code>-javaagent</code> ，从 <code>-Dfile.encoding=UTF-8</code> 给 jvm 设置一个系统属性 file.encoding&#x3D;UTF-8，然后使用 <code>-classpath</code> 指定引用的包路径，要运行的文件的位置。最后只剩需要执行的文件名称 <code>zzf.Main</code> 。把上述这些都交给 <code>D:\java\jdk\bin\java.exe</code> 该可执行程序执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
