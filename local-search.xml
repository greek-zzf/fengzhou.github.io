<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是数字花园</title>
    <link href="/2024/09/25/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/"/>
    <url>/2024/09/25/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</url>
    
    <content type="html"><![CDATA[<p>知识在脑海中是类似网状结构组成的，想一想日常思考问题，通常是由一个点，发散到与它关联的多个点。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/202409251644501.png"></p><p>例如：想到动物，脑海中便会浮现具体「鸡」「鸭」「鱼」等。它们都与「动物」存在连接，这个整体构成了脑海中关于「动物」的知识体系。</p><p>数字花园，就是我们的大脑。大脑中的知识体系，对应的就是笔记和笔记之间的连接🔗，所以数字花园也称作「第二大脑」🧠。</p><p>看一下 👀 我们的大脑是如何学习新知识的。现在学习了一个新动物「猴子🐒」，于是大脑中会新建一个「猴子」点，然后会把他与「动物」关联起来。关于「猴子」，我们又学习到它的「习性」，和「体型」，于是脑海中有多了两个信息点，与「猴子」连起来，「猴子」就补充到原有的知识体系中了。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/202409251653207.png"></p><p>回到数字花园中🌹，每一个信息点对应一个笔记，信息点之间的连接叫「双向链接 🔗」。当学习一个新的知识，就建立一条笔记，如果有关联的笔记，就会用「双向链接 🔗」关联起来。没有关联的笔记，就放入花园中，等到后续学习到了有关联的知识，就建立笔记，然后关联。</p><p><strong>问题 1：建笔记，只记录摘抄的消息，构建出来的数字花园，是可行的吗？</strong></p><p>不可行，这样做只是徒有其表。因为大脑处理信息会进行思考，然后加入自己的理解，从而形成大脑的知识。因为有思考的过程，所以吸收的知识也会更容易被记住。</p><p>因此在数字花园中，我们应该建立有思考过程的笔记。摘抄后，在笔记中加入自己的思考与感悟，然后与已有的笔记建立连接🔗，如果存在的话。</p><p><strong>问题 2：建立的笔记与花园中没有关联，怎么处理？</strong></p><p>花园也会有未经打理的花，时间一长就会枯萎🥀荒废，需要定期清除。数字花园也一样，需要定期回顾，整理散落的且存在时间长的笔记。整理的过程要么是与现有笔记关联，要么就删除。</p><p><strong>综上，经营数字花园关键的点是</strong></p><ul><li><strong>建立笔记📒，并写下自己的思考🤔。</strong></li><li><strong>寻找关联，建立连接🔗。</strong></li><li><strong>定期回顾，将没有连接的笔记，重新连接或者删除。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字花园</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于决策的思考</title>
    <link href="/2024/09/21/%E5%85%B3%E4%BA%8E%E5%86%B3%E7%AD%96%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2024/09/21/%E5%85%B3%E4%BA%8E%E5%86%B3%E7%AD%96%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="决策的感悟"><a href="#决策的感悟" class="headerlink" title="决策的感悟"></a>决策的感悟</h2><p>看完<a href="https://xiaobot.net/post/9a9e2f32-1e0c-46c7-83a1-baa5bbc8c704">产品沉思录 - 第7期</a>的「松节油：雕塑与积木」的部分，有一些感慨。</p><blockquote><p> 决策系统不稳定有什么问题呢？其实就是一个简单的数学问题：</p><ul><li>任何决策都是概率，所以大多数时候都不是 100%</li><li>因为不是 100% ，所以决策次数越多，成功概率就越低（90% vs 90% × 90%）</li><li>就算有几个好的决策，有一两个不靠谱的决策就完了（比如：90% × 1% ×90%）</li><li>最好的方式，就是少做决策，并且确保决策的胜率尽量在一个可知的范围内（比如：73% × 76% vs 90% × 1% ×90%）</li></ul></blockquote><p>把决策看作是个概率问题，就可以做一些尝试去增加决策的成功率，或者降低决策的风险。增加单次决策的成功率，减少决策次数。</p><p><strong>增加成功率</strong></p><ul><li>根据以往的决策经验，去做下一次决策。</li><li>因此需要记录以往的决策过程，并复盘。</li><li>归纳总结出有用的经验，形成自己的决策框架。</li></ul><p><strong>降低决策风险</strong></p><ul><li>尽可能少的做决策</li><li>保持决策是在一个可控的范围，成功率可以预测。</li></ul><h2 id="对我的启发"><a href="#对我的启发" class="headerlink" title="对我的启发"></a>对我的启发</h2><p>我发现自己确实很多时候都是做临时决策，而且往往都是当下状态的感受决定了决策的方向。这样做决策会给我带来一些问题。</p><ul><li>不可控。面对同一个决策，我不同的情绪，可能会做出截然不同的选择。</li><li>没有决策经验参考。做决策的时候，往往都是临时起意，也没有总结和记录决策的习惯。当遇到决策时，没有东西可参考，每次决策的过程都是新的。</li><li>会恐惧，焦虑。面对突然面临的决策，会焦虑恐惧。出于一种较负面的状态下去做决策，结果往往也会很好。不好的结果会更进一步，恐惧和焦虑，形成负面循环。</li></ul><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><ul><li>开始记录每一次决策过程，记录决策的要素如下(暂定)：<ul><li>当时面临的问题</li><li>参与到决策的人</li><li>决策考虑到的因素</li><li>决策后的结果（成效：成功，失败，一般般 ）</li><li>决策之后的代价（当前决策的代价）</li><li>换决策承担的代价</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
    </categories>
    
    
    <tags>
      
      <tag>决策</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🎬《姥姥的外孙》</title>
    <link href="/2024/08/25/%E3%80%8A%E5%A7%A5%E5%A7%A5%E7%9A%84%E5%A4%96%E5%AD%99%E3%80%8B/"/>
    <url>/2024/08/25/%E3%80%8A%E5%A7%A5%E5%A7%A5%E7%9A%84%E5%A4%96%E5%AD%99%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>上周看了一部非常好看的🤩泰国电影《姥姥的外孙》，这应该是我近几年看过最好的电影🎬。电影中关于爱的表达，有许多「隐蔽」的细节，让我这个电影爱好者十分着迷🥰。</p><h2 id="帅哥外孙"><a href="#帅哥外孙" class="headerlink" title="帅哥外孙"></a>帅哥外孙</h2><p>帅哥外孙，外孙着实有点帅，我一男的看了都…… 咳咳，来～ 来说说我观察到的细节。</p><ul><li><p>外孙的生物钟。电影中：外孙离开姥姥，回家住的第一个晚上，半夜自动醒来，时间是在 4 点 40 多分。之前的剧情中知道，外孙要帮姥姥卖粥，并且姥姥卖粥要 5 点起床。但电影并没有外孙和姥姥早起卖粥的镜头，而这个 5 点前自然醒的生物钟，已经说明一切。</p></li><li><p>姥姥的衣服的最后一粒纽扣。</p><ul><li>电影中有一个场景：外孙帮姥姥洗系衣服的最后一粒扣子，遭到拒绝。外孙开玩笑说到：姥姥这是要展露性感啊。姥姥回到：扣子系上太紧了，不舒服。</li><li>在敬老院时：外孙看到躺在床上，衣服扣子扣满的姥姥。上前和姥姥聊天、聊天间隙，顺手把最后一粒扣子解开了。奶奶回外孙：我这是要展露性感呢。</li></ul></li><li><p>外孙的潮州话。电影中外孙没有说过一句潮州话，但是到电影的后半段，外孙已经用潮汕话温柔地给姥姥唱歌，这一幕我真哭了，哭的就是这个细节。</p></li><li><p>撒纸花。电影中有一幕：姥姥对外孙说：我死后你要是乱给我撒纸花，我会爬出来吓你。但外孙就没有听姥姥生前的话，随意的撒纸花，外孙想姥姥了。</p></li></ul><h2 id="姥姥"><a href="#姥姥" class="headerlink" title="姥姥"></a>姥姥</h2><p>姥姥这个角色，塑造的很细腻，真的就像我奶奶一般，把我的注意力牢牢焊死在电影中。</p><ul><li><p>观音前的摄像头，这是一个隐蔽的细节。姥姥很信观音，敬畏神明，在电影中有体现。因此观音的神台是绝对不允许有贡品外的东西。但是，当得知外孙是出于对自己的关心，便默许了该行为。</p></li><li><p>石榴花。外孙家门前的石榴树还没有开花，在姥姥住进去后，开花了🌼。在姥姥生命结束时，花谢了。</p></li><li><p>姥姥对子女和外孙的各种无私，真诚，隐蔽的爱。</p><ul><li>记得外孙相处的点滴。外孙小时候考过一次 100 分，在得知外婆要去给自己存钱的情况下，外孙不经意间说了要存 100w 留给自己。姥姥一直记得，在结尾的时候真的给外孙存下100w。</li><li>姥姥每次见大儿子，穿的是大儿子买的的拖鞋，尽管鞋磨破脚，但坚持要穿。</li><li>伴随着外孙出生种下的石榴树，每一个石榴都套了袋子。即使二儿子想摘个吃，姥姥也不愿意，都为了留给自己的外孙。</li></ul></li><li><p>姥姥的钱罐。电影中姥姥钱罐子里的 20w 泰铢被二儿子拿走了，我认为这是姥姥对二儿子隐蔽的爱。我的依据如下：</p><ul><li><p>细节一：电影中姥姥每个月都去银行存钱，并且姥姥也不富裕。因此姥姥的钱罐子有 20多万泰铢放着，是不大合逻辑的。但导演编剧肯定不会犯这种低级错误，所以我合理的猜测，20w 泰铢就是为了帮助「二儿子」的，二儿子找自己要钱时，方便自己拿钱救济他。</p></li><li><p>细节二：钱罐子放的地方很显眼。一个贫穷的老人，会把钱藏的很好的，不会随意放在橱窗里。但电影中却是如此，只能为了方便「二儿子」拿钱。</p></li><li><p>细节三：「二儿子」去橱窗拿吃的，发现钱罐子里的钱才拿走的。姥姥是知道吃的放哪的，如果不想给二儿子发现罐子里的钱，在得知二儿子要去找东西吃，是不会任由他自己去找的。</p></li><li><p>细节四：二儿子跟姥姥撒娇要钱，演员表现得显然不是第一次，奶奶并没有直接拒绝，而是默许了。</p></li></ul></li><li><p>姥姥对二儿子的爱。姥姥得知二儿子拿光 20w 泰铢，表现惊讶。在之前有过的细节中，这个惊讶在我看来关心的不是钱丢了，而是意识到二儿子这次遇到大麻烦了，因为钱全部拿走了。后续姥姥没有责怪过二儿子，而且最后房子也是给的二儿子。</p></li><li><p>姥姥面对死亡的反差。姥姥在得知自己患癌症后，并没有什么反应，还很轻松地与老朋友交流癌症病情，给观众展示的一直都是坚强的小老太太形象。但在得知化疗中止后，姥姥心中知道自己的病治不好了。在一天夜里，姥姥侧卧在床头，第一次在观众面前展示了她的「脆弱」。姥姥在撕心裂肺地呼喊着她的爸爸妈妈，爷爷奶奶，和他们诉说自己面对死亡时，内心的脆弱害怕。姥姥的形象一下变得更立体了，我也突然意识到姥姥也是「人」，她也会害怕死亡，她也需要关心需要宠爱。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023 年终总结及个人复盘</title>
    <link href="/2023/12/29/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%A4%8D%E7%9B%98/"/>
    <url>/2023/12/29/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>不知不觉工作已经 3 年了，想要好好总结复盘一下今年的一些情况。今年的生活特别有记忆点，不再像过去的时间一样枯燥单调麻木，今年是一个全新的体验。</p><h2 id="身体的一些小状况-1-4-月"><a href="#身体的一些小状况-1-4-月" class="headerlink" title="身体的一些小状况 1~ 4 月"></a>身体的一些小状况 1~ 4 月</h2><p>年初刚到公司换了部门。</p><p>1 ~ 4 月如果过去的两年别无二致，机械麻木的工作，蜗居在自己的安乐窝中 ，享受着奶头乐。但不变的，依然关注着 IT 前沿的技术信息，以及未来的一些发展，开始了解 AI，学习使用 ChatGPT，并自己捣鼓一些小玩意，密切关注着 AI 发展。技术上取得的一些小成就，帮公司搭了一套 GPT 服务，在公司做过一次 AI 使用的分享。</p><p>1 ~ 4 月技术方面成长还算凑合，但身体出了一些状况，体验查出自己有肾结石，经历了人生中第一次手术，住院，jj 插尿管的酸爽（想起来都疼）。为了不让自己害怕，看了大量的肾结石相关的科普视频，结石的产生以及现有的手术方案，各种方案的优缺点等等，让我从新认识到自己的身体处于一个什么样的状态，所以如果有关于结石方面的问题，可以来问我哈哈哈，希望大家不要有哈哈。</p><h2 id="开始内耗-5-8-月"><a href="#开始内耗-5-8-月" class="headerlink" title="开始内耗 5 ~ 8 月"></a>开始内耗 5 ~ 8 月</h2><p>5 ~ 8 月，中间断断续续看过一些技术书籍，也特意花时间学了 <code>Obsidian</code> 使用、<code>卡片笔记法</code>、<code>ACCESS 知识管理</code>，现在回想起来，这是今年投入时间最多也非常值得的事情。中间学了 100 多天的英语，自我感觉语感提升，后面认识的以为猎头也是因为英语，哈哈哈，可惜后面没有继续坚持。这个时候想要润，想要出国的想法达到了顶峰。</p><p>日子还是那么浑浑噩噩的过着，但我是乐在其中，靠着王者荣耀，各种短视频麻痹着自己，享受着自以为是的快乐。人一旦闲下来就容易胡思乱想，想的多了发展成了内耗，自己的心态出现了问题，每天都在不切实际的幻想，幻想着自己成为技术大牛后，如何如何，每天都靠美好的幻想麻痹着自己，却少有行动，只是为了让自己内心满足，真是可怜。</p><p>发现自己的状态不对，就开始看一些心里学的书籍《不再害羞》《被讨厌的勇气》，看哲学相关的视频，《人生的意义》《如何克服虚无主义》。每次看的时候都能给到我冲击和能量，但是结束之后一切好像恢复如初。我开始怀疑书上说的知识，开始把他当做麻醉人的鸡汤文章。</p><p>跌落谷底，触底反弹。</p><h2 id="改变！！刻不容缓！！9-10-月"><a href="#改变！！刻不容缓！！9-10-月" class="headerlink" title="改变！！刻不容缓！！9 ~ 10 月"></a>改变！！刻不容缓！！9 ~ 10 月</h2><p>经历了内耗的折磨，寻找解决方法无果，9 月 9 号晚上与好朋友微信语音聊到凌晨 2 点，探讨人生哲学，那天晚上就下定决心第二天一定要出门走走，改变自己内耗的状态。</p><p>或许是上天真的想让我改变了，我永远不会忘记这一天 2023 年 9 月 10 号，待在深圳快 3 年的我，选择了去户外感受世界，选择了离家最近的海边。那天天气格外的好，中午的大太阳，在一阵小雨之后，格外清爽，我换了一身好看的衣服，带着我的帆布包，耳机，踏出了房门。大口呼吸着新鲜空气，耳机音量调的很大，音乐响起的那一刻，我的眼泪刷地一下就出来，那一刻是我感觉特别幸福。这是一种从未有过的感觉，可能是因为自我感动，自艾自怜，但是那种感觉真的太棒了，只是去到户外就能给我这么大的能量，哇生活真美好！！！ </p><p>从这天开始后，我就打算每周都去一个没有去过的地方，于是我去了深圳湾公园、海上世界、南头古城、中山公园、四海公园、大大小小的书店、各式各样的咖啡厅、深圳美术馆、会展中心等等。</p><p>之后的生活仿佛开了挂一般，开启了一系列的连锁反应。我开始愿意尝试新鲜事物，开始愿意主动去和别人交流（尽管这对一个曾经社恐的人士很难）。在国庆期间与之好久没联系的朋友重新联络，通过他的介绍认识了很多创业者，开始大量社交，每次都会给到我很强的能量，我开始有信心和勇气去做自己舒适圈外的事情。</p><p>后面的时间都在一点点的突破自己的舒适圈，并每天记录一些突破舒适圈的行为。例如换穿搭风格、戴墨镜出门、参加公司活动、参加兰海老师分享会、主动与陌生人交流，发自己的丑照等等。这些积累让我开始想要追求更难的挑战，机缘巧合下我报名了公司年会的主持（这因应该是近几年我做的最大的尝试了），哇真是个巨大的进步，我爱死自己了。</p><p>在这些尝试中，我已经没有时间去胡思乱想，自然也没有内耗了，我开始愿意去尝试自己从未接触过的东西，我结交了一些好友，结束了长达 20 多年的单身状态。</p><h2 id="稳步前进-11-12-月"><a href="#稳步前进-11-12-月" class="headerlink" title="稳步前进 11 ~ 12 月"></a>稳步前进 11 ~ 12 月</h2><p>这两个月已经很少关注 IT 行业的事情了，慢慢地发现自己开始对设计，服装、穿搭、潮流文化感兴趣，开始关注该行业的信息，后面的时间准备开始投入更多的时间在该领域，未来会发展成什么样子也不知道，只要自己喜欢就好。</p><p>这一两个月我更多地关注自身的心态，情绪认知，看待事物的方式等等。可能自我感觉不明显，但是身边人的一些反馈，让我意识到，哦原来我是在变化的。</p><p>12月份公司经历了一波裁员，熟悉的同事大多数都走了，自己的心态受到了些影响，沉浸在分别的情绪当中，或许这就是自己改变之后的需要承受的东西。我也不知道自己会不会是下一个，但是没关系，事情发生了就去面对就好了，这是未来的自己告诉我，我需要经历这些。</p><h2 id="2023-一些完成的目标"><a href="#2023-一些完成的目标" class="headerlink" title="2023 一些完成的目标"></a>2023 一些完成的目标</h2><p>看过的电影</p><ul><li>《涉过愤怒的海》</li><li>《名侦探柯南-黑铁的渔影》</li><li>《好像也没有那么热血沸腾》</li><li>《惊奇队长2》</li><li>《惊奇队长2》</li><li>《涉过愤怒的海》</li><li>《河边的错误》</li><li>《灌篮高手》</li><li>《误杀2》</li><li>《保你平安》</li><li>《巴霍巴利王》</li><li>《巴霍巴利王2》</li><li>《饮食男女》</li><li>《心迷宫》</li><li>《蜘蛛侠：纵横宇宙》</li><li>《杰伊比姆》</li></ul><p>综艺  </p><ul><li>《圆桌派第三季》</li><li>《圆桌派第二季》</li><li>《圆桌派第一季》</li></ul><p>剧集</p><ul><li>《请回答1988》 </li><li>《武林外传》 心中第一神剧，没有之一，不记得几刷了。</li><li>《少年谢尔顿4》</li><li>《时光代理人》</li><li>《我是大哥大》</li><li>《鹊刀门》</li><li>《凸变英雄2》</li><li>《模仿犯》</li><li>《灌篮高手》 不记得几刷了，每次看完都热血沸腾</li><li>《星期三》</li></ul><p>书籍</p><ul><li>《人性的弱点》还没有读完</li><li>《谁动了我的奶酪》</li><li>《谁动了我的奶酪2》</li><li>《活着》</li><li>《在细雨中呼喊》</li><li>《被讨厌的勇气》</li><li>《不再害羞》</li></ul><h2 id="2024"><a href="#2024" class="headerlink" title="2024"></a>2024</h2><p>2023年就要过去了，最近常听的一个播客节目「无人知晓」，特别喜欢孟岩，这里想引用他说的一句话作为我新的一年开始：</p><p><strong>愿新年的阳光打在你的脸上，愿你拥有无限的热情、勇气和平静，让万物穿过自己。</strong></p>]]></content>
    
    
    <categories>
      
      <category>年终总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>需要马上执行的事情</title>
    <link href="/2023/11/15/%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B/"/>
    <url>/2023/11/15/%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<p>做一个富有责任感的男人。</p>]]></content>
    
    
    <categories>
      
      <category>生活类 blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1028</title>
    <link href="/2023/10/29/1028/"/>
    <url>/2023/10/29/1028/</url>
    
    <content type="html"><![CDATA[<h2 id="我只记得那晚的月亮，从朦朦胧胧中抽离出来，成为那晚最亮的光。"><a href="#我只记得那晚的月亮，从朦朦胧胧中抽离出来，成为那晚最亮的光。" class="headerlink" title="我只记得那晚的月亮，从朦朦胧胧中抽离出来，成为那晚最亮的光。"></a>我只记得那晚的月亮，从朦朦胧胧中抽离出来，成为那晚最亮的光。</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=191179&auto=1&height=66"></iframe>]]></content>
    
    
    <categories>
      
      <category>生活类 blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>改变身份认同</title>
    <link href="/2023/10/21/%E6%94%B9%E5%8F%98%E8%BA%AB%E4%BB%BD%E8%AE%A4%E5%90%8C/"/>
    <url>/2023/10/21/%E6%94%B9%E5%8F%98%E8%BA%AB%E4%BB%BD%E8%AE%A4%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="工作三年的感悟"><a href="#工作三年的感悟" class="headerlink" title="工作三年的感悟"></a>工作三年的感悟</h2><p>不知不觉，已经出来工作三年了。三年来我也有过很多思考，像：技术能有什么大的突破、优秀的程序员都在干嘛、我以后的生活会更好吗？我以后怎么找到远程工作等等。</p><p>我发现自己的精力都是在思考：作为程序员的我是如何规划自己的未来的。别人常说有职业规划是好事情，但在我身上我却发现这种规划成了束缚自我的枷锁，我更少的关注生活，更少的社交，更少的有突破舒适圈的行为。</p><p>一直到最后我惊奇的发现，我好像什么事情都没有做成，还让自己陷入了内耗深渊。</p><p>最近一两个月来，为了不让自己过多内耗，不让自己受原生家庭自卑的影响，阅读和收藏了一些经典的心里学书籍《不再害羞》《被讨厌的勇气》《当下的力量》，看过油管和 B 站大大小小数百个让你变得更好的自己的视频，所有的点最后都会指向「勇气」。</p><p>「勇气」？当我看《被讨厌的勇气》最后几章的时，作者就提到了勇气，当时就在想可能又是一部理论书籍，因为道理我都懂但真要付诸实践还是算了。这些道理像麻醉剂一样，麻痹着我，我以为只要理解了这些就会变得更好。</p><p>直到一个月前，我开始走出去，我才找到了我的生活。丰富的生活占据着我的精力，平日里莫名紧绷的神经在那一次得到了释放，出来后第一次感受到生活的美好。</p><p>在 10 月 5 号参加的[[Spaces&#x2F;Resources&#x2F;博客&#x2F;生活类&#x2F;财富流 - 个人觉察|财富流]]游戏让我有了更多的感悟和思考。一个思考的点就是「身份认同」，我了解完之后发现了这个东西其实一直在影响着我，只是我一直没有察觉到。</p><h2 id="什么是身份认同"><a href="#什么是身份认同" class="headerlink" title="什么是身份认同"></a>什么是身份认同</h2><p>维基百科中是这样定义：</p><blockquote><p><strong>身份认同</strong>（英语：self-identity），又称为<strong>自我认同</strong>，是<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E7%90%86%E5%AD%A6" title="心理学">心理学</a>和<a href="https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%AD%A6" title="社会学">社会学</a>的一个概念，指一个人对于自我特性的表现，以及与某一群体之间所共有观念（国籍或者文化）的表现。身份认同的类型大致可分为：拒绝、漂流、搜寻、保卫和坚定。身份与鉴定不同，身份是自我的标签，而鉴定是指一个分类的过程。身份是在心理学上构成一个人（自我身份）或群体（特定的社会类别或社会群体）的特质，信念，个性，相貌和&#x2F;或表达。身份认同会因历史、文化和政治而改变。对身份进行分类可以是正面的或具有破坏性的</p></blockquote><p>我们每个人都有很多身份，像「儿子」「程序员」「司机」「老板」等等，把自己置身一个场景中，你就会开始诠释这个身份。</p><p>例如：当你在工作中，你会是一个程序员，你就会做你认为程序员该做的事情，学技术，改bug 等等。在家庭中，你是一个儿子，你就会做儿子这个身份该做的事情。</p><p>发现了吗？身份认同在影响着你的行为，甚至让你产成行为依赖，你会慢慢开始理解不了别人做的身份以外的尝试，慢慢你会发展成讥讽，嫉妒等心里。</p><p>所以此时此刻，你需要好好想一想，身份认同给你带来了什么？好的一面是什么？坏的一面又是什么？</p><h2 id="身份认同会给你带来什么"><a href="#身份认同会给你带来什么" class="headerlink" title="身份认同会给你带来什么"></a>身份认同会给你带来什么</h2><p>身份认同在我身上的体现就是，我强烈的认同自己程序员的身份。</p><p>我发现，我做任何事情都喜欢用「程序员」的思维去思考问题，用程序员思维思考没有问题，相反，还能帮我挖掘事情的底层逻辑。</p><p>但是，我发现自己好像只会用「程序员思维」去思考问题，所以看任何事情只有一个角度，这还不是要命的。更要命的是，我没有意识到自己一直以来只使用一种方式来思考，仿佛全世界只剩下这种思考方式。我还曾固执的以为程序员思维是高于其他思维方式的，因此也会拒绝或者是不屑使用其他方式思考，最终一直被「程序员」这个身份裹挟着前进。</p><p>当然，身份认同不是一件坏事，他能让我们有认同感并在该身份下做自我诠释。问题在于不断的在特定身份做自我诠释，你会熟悉这个身份并且越来越依赖这个身份，若你没有独立思考的能力的话，你只会越陷越深。当你不再拥有这个身份时，你会发现自己失去了前进的动力，不知所措。</p><p>因此我们需要身份认同，但也不能太依赖他，需要经常脱离已有的身份，尝试一些新的身份，扮演一些新的角色，这些会带给你很新的思考。世界不能只有一种声音，同样也不能只有一种思考。</p><p>身份认同让我诠释了「程序员」这个职业，帮助我在现在的工作中能够游刃有余。</p><p>但相反的，强烈的认同让我觉得程序员就应该缺少社交、就应该不爱说话、就应该不擅长与人打交道、就应该不太擅长表达和演讲。「就应该」3 个字是多么可怕，让我理所当然的认为自己所做的事情是对的，却毫无察觉到，我已经离「拥有优秀品质的人」这个目标越来越远了。</p><h2 id="如何去改变自己的身份认同"><a href="#如何去改变自己的身份认同" class="headerlink" title="如何去改变自己的身份认同"></a>如何去改变自己的身份认同</h2><p>在做改变之前，你必须得先意识到自己的身份认同，以及想要做改变的决心。身份认同可能会让你产生强烈的依赖，会成为你逃避或害怕改变的枷锁，当你需要跳脱当前身份时，你往往会退缩，然后给自己找借口安慰自己，更进一步强化自己不愿改变身份的意愿。最终自己囚禁在自己编织的茧房里面，越缠越紧。</p><p>我一直都是以「程序员」这个身份自居，甚至会有点引以为傲，对其他行业的事情不太关心，甚至有的时候会有一些鄙视。我也不太清楚自己为什么会有这种行为，我好像很认同自己程序员的身份，后来发现强烈的身份认同是导致我自傲的原因，我决定要改变这种情况。</p><p>说到改变，无一例外都是不舒服甚至是痛苦的过程。理论其实大家都知道，只是真要付诸行动，会发现怯懦无比。因此寻求改变也不能急于求成，需要通过完成一个一个的小挑战，突破一次又一次突破舒适圈，等你积累到战胜困难的自信，在向下一个更大的困难去发起挑战，此时改变已在你的身上悄无声息的发生了。</p><p>小的挑战可以是很多日常的行为，例如：</p><ul><li>经常换早餐店吃早餐</li><li>与陌生人打一个招呼</li><li>换一种穿搭风格</li><li>一个人去图书馆看书</li></ul><p>以上这些都是一些有一点难度，需要打破你原有的舒适圈，但是又不会让你想要放弃。当你积少成多，你也就有了脱离当前身份的勇气，走出去最大的收获在于「走出去」，So just do it。</p><h2 id="身份认同带来的思考"><a href="#身份认同带来的思考" class="headerlink" title="身份认同带来的思考"></a>身份认同带来的思考</h2><p>安于现状和不断地做重复的事情，就是在编织自己的茧房。世界是多元的，人也应该是丰富的。</p><p>我希望程序员的你，万一不幸被裁，你会像多啦 A 梦一样，从口袋里拿出一个新的赚钱的技能，来应对这个多变的社会。</p><h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>Related</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E5%90%8C#:~:text=%E8%BA%AB%E4%BB%BD%E8%AE%A4%E5%90%8C%EF%BC%88%E8%8B%B1%E8%AF%AD%EF%BC%9Aself%2D,%E6%8C%87%E4%B8%80%E4%B8%AA%E5%88%86%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">身份认同 - 维基百科，自由的百科全书</a></p>]]></content>
    
    
    <categories>
      
      <category>生活类 blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>财富流 - 个人觉察</title>
    <link href="/2023/10/07/%E8%B4%A2%E5%AF%8C%E6%B5%81%20-%20%E4%B8%AA%E4%BA%BA%E8%A7%89%E5%AF%9F/"/>
    <url>/2023/10/07/%E8%B4%A2%E5%AF%8C%E6%B5%81%20-%20%E4%B8%AA%E4%BA%BA%E8%A7%89%E5%AF%9F/</url>
    
    <content type="html"><![CDATA[<p>我没有想到一款「游戏」能让我有非常不一样的体验。</p><h2 id="接触之前"><a href="#接触之前" class="headerlink" title="接触之前"></a>接触之前</h2><p>我像大多数人一样，初听这个名字会以为这仅仅是一个教你如何积累财富的「骗局」。</p><p>我为什么会认为是「骗局」？因为我觉的这是成功人士，为了教你成功，创建的一款游戏仅此而已。我认为每个人的成功都不可复制的，所以他们给出成功经验更像是一种安慰穷人的做法，让你以为你可以成功。</p><p>正式因为持有这样的「偏见」，我一开始才会有一些抵触甚至是讨厌。但迫于朋友的邀请，以及自己想要突破舒适圈的渴望，还是如约的参加这个游戏。</p><blockquote><p>写下这些的时候，又引发了我的思考🤔？</p><ul><li>为什么我会对自己不熟悉的领域有偏见？</li><li>我的偏见是怎么来的？</li><li>为什么有的时候我愿意为自己的偏见买单？</li><li>这些偏见阻碍了我什么？</li></ul></blockquote><h2 id="游戏前期的体验"><a href="#游戏前期的体验" class="headerlink" title="游戏前期的体验"></a>游戏前期的体验</h2><p>来都来了是吧，该做的事情还是要做。听完游戏介绍和规则后随机抽取自己的角色（抽到了医生），开始了游戏。</p><p>游戏有两个目标</p><ul><li>出圈：从平民的圈子跳出来成为富人圈（被动收入和精力达到角色要求即可）</li><li>终极梦想：实现自己所追求的梦想。（钱 + 精力）</li></ul><p>游戏的终极目标实现自己的梦想（万人演讲、环球旅行等），从平民的圈子跳出来成为富人也是可以的，因为跳出来之后，富人想要去实现自己的梦想会很简单，大多都是时间和精力问题。</p><p>游戏是分为三个人生阶段的：20 ~ 30（青年）、30 ~ 50（中年）、50 ~ 60（老年）。每个时期能做的事情有限制，每个人都是拿着自己的薪水和初始的精力，以及少许银行存款开始自己的游戏，游戏中的设定和规则都是贴近真实生活的。 </p><p>一开始还在熟悉规则，以及处于一个陌生的圈子中，触发了我的社恐 buff，表现的会比较拘束一点，遇到不懂的地方,也是大多数去问我旁边的审计（朋友）。</p><blockquote><p>写到「触发我的社恐 buff」的时候，我又发现自己将自己定义成了一个「社恐人士」，虽然我之前确实有社恐，但是我好想一直都喜欢给自己贴上这个标签，哪怕别人都不这么觉得。所以标签有的时候是你意识不到的，你想摘却看不见。</p></blockquote><p>在游戏的青年时期和中年时期，经历了人生低谷「失业」、也迎来了自己的高光「结婚」、「生娃」。但是对于「出圈」这个目标还是差的很远，因为自己的「被动收入」为 0，而恰巧自己的角色对被动收入的要求更高。但是值得庆幸的是，自己累积了一些收入、以及有足够的精力去做足够多的事情，还与其他玩家建立了合作关系，有了一定的人脉基础，只是自己还从未使用过。</p><p>在前中期复盘的时候发现了自己的问题：虽然与其他玩家建立了人脉，但是缺少合作，以及开口的勇气，导致机会从自己手上流失，自己却没有察觉到。到了自己老年的时候，就需要善用已经存在的资源，否则单靠自己去实现破圈的目标是非常难的。</p><p>不过好在前中期已经也有积累，现在只需要主动出击便可以将机会利用起来，帮助自己破圈。</p><h2 id="游戏后期的体验"><a href="#游戏后期的体验" class="headerlink" title="游戏后期的体验"></a>游戏后期的体验</h2><p>游戏后期，到了自己的老年时期了。直到这个时候我才真正的有目标感，想要为了破圈去做一些努力，向建立关系的玩家进行借贷，以及通过自己的努力去争取那最后的破圈机会。都说厚积薄发，我成为全场剩余的平民中最适合出圈的人，我拿到了最后出圈的机会，顺利出圈。</p><p>在富人圈中与其他富人合作，开启了一场豪赌，最后直接赢得两个亿，此时终极目标已经显的没有那么重要了，追逐的过程已经证明了一切。</p><p>游戏结束后，每个玩家都开始了对自己游戏的复盘。</p><h2 id="我的复盘"><a href="#我的复盘" class="headerlink" title="我的复盘"></a>我的复盘</h2><p>「人脉」：我知道需要达到破圈的目的是避免不了与他人合作的，因此「人脉」在游戏一开始我遇到能够成就别人的机会就会积极的给到别人，从而建立起人脉关系。</p><p>「自信」：虽然我早早的与他人建立了关系，但是却一直没有使用过，因为自己缺乏一些自信，不太敢与他人开口这也就导致别人不清楚你的情况，即使他能够帮助你，但你不开口她就永远不知道。收获了一个经典句子：开口就有 50% 的机会。</p><p>「厚积薄发」：当你像我一样，前中期没有把握好机会的话，不要放弃不要怨天尤人，做好自己的积累与提升，这样机会来的时候才能把握住。只需要从自己身上做一些突破，便可以使用积累的资源实现破圈。</p><p>「放平心态」：不以物喜，不以己悲，酸甜苦辣咸才是人生百味，只品尝一个味道就太单调了。生活就是这样可以很丰富也可以很平淡，选择固然重要，面对选择之后带来的不确定性更重要。</p><h2 id="我的收获，以及引申的思考"><a href="#我的收获，以及引申的思考" class="headerlink" title="我的收获，以及引申的思考"></a>我的收获，以及引申的思考</h2><p>在我总结了自己复盘之后，在场的玩家也给了我很多可能性，让我开始思考一些事情。</p><p>教练通过他的上帝视角给与我的建议: </p><ul><li>你意识到自己是有价值的，变得越来越自信，机会也随之多了起来</li><li>你意识到自己是一切问题的根源，于是不再抱怨，开始负担起责任，机会也越来越多</li></ul><p>收获到一些其他小伙伴的建议：</p><ul><li>身份认同</li><li>场的概念</li><li>机会的给与</li><li>敢于试错</li></ul><p>上面的建议，有些有意识到的，有些则是来没有了解的，但是建议好像都没有转成实践。因此虽然我懂得一些道理，但还是在原地踏步，就像油箱里面装满了油，但是你却不启动发动机，尽管不会离目的地越来越远，却也永远达不到目标。</p><p>写到最后，再再一次引发了我的思考，除了旁观者清外，为什么别人能够发现你的问题，并且给出恰到好处的建议。而当我去评价别人的时候，好像觉得别人很完美了，但其他人评价他的时候我也非常认同这个评价。</p><p>简而言之，就是发现不了问题，或者意识不到问题所在。说起来会觉得有点可笑，认知不够连存在的问题都会看不到。因此提升自己的认知很有必要，他会让你意识到什么是问题，以及如何处理这些问题。</p><p>最后的最后，也是非常感谢邀请我参加活动的小伙伴，没有他的邀请我也不会参加这个活动，也不会带给我这么多的思考了。</p>]]></content>
    
    
    <categories>
      
      <category>生活类 blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.824 分布式系统 - Introduction</title>
    <link href="/2023/09/15/6.824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-Introduction/"/>
    <url>/2023/09/15/6.824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式系统基础架构"><a href="#分布式系统基础架构" class="headerlink" title="分布式系统基础架构"></a>分布式系统基础架构</h2><ul><li>存储</li><li>计算</li><li>通信（关于通信的详细内容可观看 6.829 计算机网络）</li></ul><h2 id="实现分布式所需的工具"><a href="#实现分布式所需的工具" class="headerlink" title="实现分布式所需的工具"></a>实现分布式所需的工具</h2><ul><li>RPC (Remote procedure call)</li><li>线程</li><li>并发控制</li></ul><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li>分布式系统的扩展，带来便利。<ul><li>高性能</li><li>高容错</li></ul></li><li>扩展带来的几个问题<ul><li>容错性（Fault Tolerance）</li><li>可用性 （Availability）</li><li>可恢复（Recoverability）</li></ul></li><li>解决容错的手段<ul><li>避免写入非易失性存储（Non-Volatile Storage）</li><li>使用复制，来增加容错（Replicated）</li></ul></li></ul><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h2><p>使用一个 key value 例子说明 <code>强一致性</code>(Strong Consistency) 和 <code>弱一致性</code>(Weak Consistency)</p><h2 id="Google-的-MapReduce"><a href="#Google-的-MapReduce" class="headerlink" title="Google 的 MapReduce"></a>Google 的 MapReduce</h2>]]></content>
    
    
    <categories>
      
      <category>6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式，6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI 工具使用分享</title>
    <link href="/2023/09/15/AI%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%88%86%E4%BA%AB/"/>
    <url>/2023/09/15/AI%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="获得工具"><a href="#获得工具" class="headerlink" title="获得工具"></a>获得工具</h2><p>国外的一些 AI 聊天产品，无一例外访问都需要一些手段，使用成本较高。</p><ul><li>ChatGPT</li><li>Google 的 bard</li><li>Claude ai</li><li>Bing Chat</li></ul><h2 id="正常使用"><a href="#正常使用" class="headerlink" title="正常使用"></a>正常使用</h2><p>像和一个知识渊博的人在对话一样，无需顾忌他能否听懂你的问题，无需顾及之前和他谈过的内容，他就像一个真人一样，帮你解答一切。</p><h2 id="优化使用"><a href="#优化使用" class="headerlink" title="优化使用"></a>优化使用</h2><p>想要和提高和 AI 谈话的效率，有两个做法，一个是<strong>提升 AI 的理解能力</strong>，另一个是<strong>提升自己文字表达能力</strong>。</p><h3 id="提升-AI-理解能力"><a href="#提升-AI-理解能力" class="headerlink" title="提升 AI 理解能力"></a>提升 AI 理解能力</h3><p>业界使用最多的就是使用 <code>prompt</code>，给 AI 赋予一个角色，让 AI 在给定的角色中发挥作用，这样能够让 AI 的回复限定在角色中，让 AI 回复相关性和满意度更高。</p><ul><li>使用现成的高质量 prompt<ul><li><a href="https://www.aishort.top/">AiShort (ChatGPT Shortcut) - 简单易用的 ChatGPT 快捷指令表，让生产力倍增！标签筛选、关键词搜索和一键复制 Prompts | AiShort(ChatGPT Shortcut)-Tag filtering, keyword search, and one-click copy prompts</a></li><li><a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh">GitHub - PlexPt&#x2F;awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。</a></li></ul></li><li>自己定义 prompt 并使用相关手段进行优化<ul><li><a href="https://promptperfect.jina.ai/prompts">PromptPerfect - Elevate Your Prompts to Perfection. Prompt Engineering, Optimizing, Debugging and Hosting.</a></li><li><a href="https://hero.page/blog/chatgpt-and-midjourney-prompt-generator?ref=theresanaiforthat">ChatGPT &amp; Midjourney Prompt Generator | Hero</a></li></ul></li></ul><h3 id="提升自己的知识水平"><a href="#提升自己的知识水平" class="headerlink" title="提升自己的知识水平"></a>提升自己的知识水平</h3><p>Q：为什么需要提升自己才能用好 AI？</p><p>A：你的提问水平决定了 AI 的回答水平。提问的水平越高，AI 就更能理解你的意图。有的时候你无法准确描述一个问题，是因为你对这方面的基础不够。</p><p><strong>场景</strong>：需要将字符串 <code>Hello World</code>变成 <code>dlroW olleH</code>。</p><p>学过一些知识的应该都知道这个操作叫做 <code>回文</code>，我们可以像 AI 提问：在 xx 语言中如何实现回文？</p><p>但是前提是你知道这个操作的专业术语，倘若你是一个小白你会如何去问这个问题？想让 AI 理解你的意图，你可能需要花更多的时间和更多的精力。</p><h2 id="一些-AI-工具"><a href="#一些-AI-工具" class="headerlink" title="一些 AI 工具"></a>一些 AI 工具</h2><ul><li><a href="https://ai.dreamthere.cn/">AI工具导航</a></li><li>编码<ul><li>代码智能补全工具 <a href="https://github.com/features/copilot">Copilot</a></li><li>通过编写注释即可自动帮你实现代码，或者根据已有的上下文推导出代码的实现</li><li>通过定义良好的方法名，自动实现方法逻辑</li></ul></li><li>项目生成<ul><li><a href="https://github.com/geekan/MetaGPT">MetaGPT</a> 一句话生成一个项目，输出用户故事 &#x2F; 竞品分析 &#x2F; 需求 &#x2F; 数据结构 &#x2F; APIs &#x2F; 文件等</li></ul></li><li>代码翻译，将 A 语言 转成 B 语言<ul><li><a href="https://aicodeconvert.com/">AI Code Converter | AI Code Translator | AI Code Generator</a></li></ul></li><li>翻译<ul><li><a href="https://immersivetranslate.com/">沉浸式翻译 - 支持多平台以及 openai</a></li></ul></li><li>ppt<ul><li><a href="https://gamma.app/">Gamma</a></li><li><a href="https://tome.app/">tome AI</a></li></ul></li></ul><h2 id="其他的替代品"><a href="#其他的替代品" class="headerlink" title="其他的替代品"></a>其他的替代品</h2><h3 id="技术人员"><a href="#技术人员" class="headerlink" title="技术人员"></a>技术人员</h3><ul><li>注册国外的 AI 账号</li><li>使用开源项目搭建自己的 gpt<ul><li><code>pandora</code> github 开源项目，目前已经被封了</li><li><a href="https://github.com/zhayujie/chatgpt-on-wechat">Chatgpt-on-wechat 支持多种 ai 模型</a> </li><li><a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web: 一键拥有你自己的跨平台 ChatGPT 应用。</a></li></ul></li></ul><p>使用开源项目部署自己的 AI 服务，成本低，但需要懂一些技术。</p><h3 id="非技术人员"><a href="#非技术人员" class="headerlink" title="非技术人员"></a>非技术人员</h3><ul><li><a href="https://poe.com/login">Poe</a>目前技术人员使用人数最多的平台，整合多个 AI 资源，部分收费。</li><li><a href="https://chat-shared2.zhile.io/shared.html?v=2">GPT Shared Chat 一个共享的 ChatGPT 使用平台</a> 共享的 gpt 平台，不适合放一些敏感数据</li><li><a href="https://chat.zhile.io/auth/login?v=5">需要自备账号</a></li></ul><h2 id="AI-First"><a href="#AI-First" class="headerlink" title="AI First"></a>AI First</h2><p>当我要在公司分享这篇文章的时候，我忘记了写 PPT，于是我打开 PPT 制作软件，刚准备创建第一张 PPT 时才猛然想起，为什么不用 AI 帮我生成？</p><p>这件事引起了我的思考，我在想我为什么没有第一时间想到去用 AI，而还是按部就班的去做这一件事，AI 已经有很多优秀的产品出现，但是好像和我的工作生活基本没有交集，难道这些 AI 工具不是为我服务的？</p><p>AI 当然是为每一个人服务的，但我们并没有跳脱出原来僵化的思维，仅仅是在做某件事情觉得困难才去找一些相关的工具。因此我觉的有必要做每件事的时候思考一下，AI 能帮我做什么，我觉得这样 AI 才能真正帮助你。</p><h2 id="授人与渔"><a href="#授人与渔" class="headerlink" title="授人与渔"></a>授人与渔</h2><p>了解程序员行业最新动态的途径，包括但不限于 AI。</p><ul><li><a href="https://news.ycombinator.com/">Hacker News</a></li><li><a href="https://ruanyifeng.com/blog/">阮一峰的网络日志</a></li><li><a href="https://v2ex.com/">V2EX</a></li><li><a href="https://github.com/trending">Trending repositories on GitHub today · GitHub</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程</title>
    <link href="/2023/09/12/%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%83%91/"/>
    <url>/2023/09/12/%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%83%91/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-线程，操作系统线程，Java-线程"><a href="#CPU-线程，操作系统线程，Java-线程" class="headerlink" title="CPU 线程，操作系统线程，Java 线程"></a>CPU 线程，操作系统线程，Java 线程</h2><h3 id="CPU-线程"><a href="#CPU-线程" class="headerlink" title="CPU 线程"></a>CPU 线程</h3><p>CPU 线程是属于硬件的范畴，他在硬件实现上就支持多线程。每个 CPU 都具有多个核心，并且每个核心都可以处理一个线程。</p><p>但核心和线程的数量并不是 1:1 的，取决于 CPU 具体的架构实现。大多数服务器级别的处理器每个核心都支持多个线程，你经常能听到 8 核心 16 线程诸如此类的说法。</p><p>CPU 的核心就像人的嘴巴，处理的线程就是人的手。手去拿食物（任务），嘴巴开始吃拿到的食物，假如你吃的比手拿的快，理论上你可增加手的数量，即支持更多的线程。</p><p>但实际上，这个是有瓶颈的。当嘴巴还没吃完食物，手上已经拿到食物并等待，这个时候手就只能等嘴巴吃完食物。因此，每个核心处理的线程数量并不是越多越好。</p><p>目前每个 CPU 核心处理的最佳线程数量是 2 个，就像人一样，一张嘴和两只手。</p><h3 id="操作系统线程"><a href="#操作系统线程" class="headerlink" title="操作系统线程"></a>操作系统线程</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">维基百科</a></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>停止使用 JWT 作为 Session</title>
    <link href="/2023/07/29/%E5%81%9C%E6%AD%A2%E4%BD%BF%E7%94%A8%20JWT%20%E4%BD%9C%E4%B8%BA%20Session/"/>
    <url>/2023/07/29/%E5%81%9C%E6%AD%A2%E4%BD%BF%E7%94%A8%20JWT%20%E4%BD%9C%E4%B8%BA%20Session/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自国外的文章</p></blockquote><h1 id="停止使用-JWT-作为-Session"><a href="#停止使用-JWT-作为-Session" class="headerlink" title="停止使用 JWT 作为 Session"></a>停止使用 JWT 作为 Session</h1><p>最近，我看到越来越多的人推荐使用 JWT（JSON Web Tokens）来管理 web 程序中用户的 session。这是一个非常糟糕的主意，我将在这篇文章中解释原因。</p><p>为了防止一些歧义，我首先定义一些术语：</p><p><strong>[[Web 中的 Session#Client-Side Session |无状态]] JWT</strong>：一个包含 session data 的 JWT 令牌，数据直接编码到令牌中。</p><p><strong>[[Web 中的 Session#Server-Side Session |有状态]] JWT</strong>：一个只包含 session 引用或 ID 的 JWT 令牌，session data 存储在服务器端。 </p><p>Session token &#x2F; cookie：一个标准的（可选签名的）会话 ID，就像网络框架已经使用了很长时间，session data 存储在服务器端。</p><p>清楚地说：这篇文章并非不让你使用 JWT，只是说它不适合作为 Session 机制，使用它有风险。在其他领域，对它们确实存在有效的用途。在文章的最后，我将简单介绍。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人错误地比较”cookies 与 JWT”，这种比较完全没有意义，好比拿苹果与橙子相比。cookies 是一种存储机制，而 JWT 是经过加密签名的 token。</p><p>它们并非对立关系，相反，它们可以一起使用也可以独立使用。正确的比较应该是 「Session 与 JWT」和「cookies 与本地存储」。</p><p>在这篇文章中，我将比较 session 和 JWT token，并在需要的地方涉及 「cookies 与本地存储」的比较。</p><h2 id="大家谈论的-JWT-优势"><a href="#大家谈论的-JWT-优势" class="headerlink" title="大家谈论的 JWT 优势"></a>大家谈论的 JWT 优势</h2><p>当人们推荐 JWT 时，他们通常会跟你说如下优势：</p><ul><li>更易于（水平）扩展 </li><li>更易于使用</li><li>更灵活</li><li>更安全</li><li>内置过期功能</li><li>不需要用户 “Accept Cookie”</li><li>防止跨站请求伪造（CSRF）</li><li>在移动设备上使用效果好</li><li>禁止 cookie 的场景很适用</li></ul><p>我将对这些优势一一剖析解答，它们为什么是错误或误导性的。下面的一些解释可能有点含糊，主要是因为这些优势本身就很模糊。</p><h3 id="更易于（水平）扩展"><a href="#更易于（水平）扩展" class="headerlink" title="更易于（水平）扩展"></a>更易于（水平）扩展</h3><p>这是唯一一个从技术上说的过去优势，但只有在无状态 JWT token 的情况下才适用。然而实际上，几乎没有人真正需要这种扩展性。有许多更简单的扩展方法，除非你的操作范围达到 Reddit 的大小，你不需要 <code>无状态会话</code>。</p><p>扩展有状态会话的一些例子：</p><ol><li>当你在一个服务器上运行多个后台进程：在该服务器上使用 Redis 存储 Session 数据。</li><li>当你在多个服务器上运行：使用一个专门存储 Session 数据的 Redis 服务器</li><li>当你在多个服务器上，在多个集群中运行：粘连 Session</li></ol><p>这些场景，现有软件都提供很好地支持，你开发的应用程序很大概率只能达到第二种情况。</p><p>也许你在想，你应该为你的应用程序以后做好准备，以防超越了那个界限。然而在实践中，切换 Session 机制是相当简单的，唯一的成本就是在你过渡的时候将每个用户注销一次，需要将所有用户一次性注销登录。从一开始就实施 JWT 并不值得，特别是考虑到我稍后将要讲到的缺点。</p><h3 id="更易于使用"><a href="#更易于使用" class="headerlink" title="更易于使用"></a>更易于使用</h3><p>并非如此，你将不得不自己处理 session 管理，在客户端和服务器端都要进行，而标准的 session 和 cookies 搭配是开箱即用的。在任何方面，JWT 都不会更易用。</p><h3 id="更灵活"><a href="#更灵活" class="headerlink" title="更灵活"></a>更灵活</h3><p>我还没有看到有人真正解释 JWT 是如何更灵活的。几乎每一个主要的会话实现都允许你存储任意的 session data，这与 JWT 的工作方式没有任何区别。就我所知，这只是被当作一个热门词汇使用的。如果你有异议，随时可以向我提供例子。</p><h3 id="更安全"><a href="#更安全" class="headerlink" title="更安全"></a>更安全</h3><p>很多人认为 JWT 令牌「更安全」，是因为使用了加密技术。虽然签名的 cookies 比未签名的 cookies 更安全，但这并不是 JWT 所独有的，好的 Session 实现也会使用签名的 cookies。</p><p>JWT 使用加密技术并不会神奇地使某个东西更安全，它必须有一个特定的目标，且对于那个特定的目标，它是一种有效的解决方案。事实上，错误的使用加密技术可能会变得更不安全。</p><p>另一个我经常听到的「更安全」的论点是「他们不是作为 cookie 发送出去的」。这完全没有道理，cookie 只是一个 HTTP 头，使用 cookies 并没有什么不安全。实际上，cookies 对防止恶意客户端代码特别有效，这是我稍后要讲的。</p><p>如果你担心有人截取你的会话 cookie，你应该使用 TLS，如果你不使用 TLS，任何类型的会话实现都会被截取，包括 JWT。</p><h3 id="内置过期功能"><a href="#内置过期功能" class="headerlink" title="内置过期功能"></a>内置过期功能</h3><p>这并没有什么意义的，也不是一个有用的特性。服务器端一样可以很好地实现过期功能，许很多实现方式就是如此。实际上，服务端过期是更好的选择，它允许应用程序清理不需要的 Session 数据，这是「有状态的 JWT token」过期机制是无法做到的。</p><h3 id="无需用户同意-Cookie-策略"><a href="#无需用户同意-Cookie-策略" class="headerlink" title="无需用户同意 Cookie 策略"></a>无需用户同意 Cookie 策略</h3><p>这是完全错误的。没有所谓的 “cookie 策略”，关于 cookie 的各种规定实际上覆盖了任何并非严格必要的持久性标识符。你能想到的任何会话机制都包含在这其中。</p><p>总的来说：</p><p>如果你出于功能性目的（比如，让用户保持登录状态）正在使用 Session 或 JWT，那么无论你如何存储该会话，你都不需要向用户请求同意。 如果你出于其他目的（比如，分析或跟踪）正在使用会话或令牌，那么无论你如何存储该会话，你都需要向用户请求同意。</p><h3 id="防止跨站请求伪造（CSRF）"><a href="#防止跨站请求伪造（CSRF）" class="headerlink" title="防止跨站请求伪造（CSRF）"></a>防止跨站请求伪造（CSRF）</h3><p>事实并非如此。存储 JWT 大致有两种方式：</p><p>在 cookie 中：容易受到 CSRF 攻击，仍然需要防护。 在其他地方，比如 Local Storage：现在你不再容易受到 CSRF 攻击，但你的应用程序或网站现在需要 JavaScript 才能工作，并且你把自己暴露给了一个完全不同的，可能更糟糕的漏洞类型。下面有更多关于这点的内容。 唯一正确的 CSRF 缓解措施是使用 CSRF 令牌。这里的会话机制并不相关。</p><h3 id="对移动设备上支持更好"><a href="#对移动设备上支持更好" class="headerlink" title="对移动设备上支持更好"></a>对移动设备上支持更好</h3><p>无稽之谈。现有的每一款移动浏览器都支持 cookies，因此也支持会话。每个主要的移动开发框架和任何权威的 HTTP 库也是如此。所以这根本就不是问题。</p><h3 id="对那些阻止-cookies-的用户也起作用"><a href="#对那些阻止-cookies-的用户也起作用" class="headerlink" title="对那些阻止 cookies 的用户也起作用"></a>对那些阻止 cookies 的用户也起作用</h3><p>不太可能。用户不仅仅是阻止 cookies，他们通常会阻止所有持久化的方式。那包括 Local Storage 和任何其他可以让你持久化会话的存储机制（无论是否使用 JWT）。你是否使用 JWT 在这里根本不重要，这是一个完全不同的问题，试图在没有 cookies 的情况下让认证工作，基本上是徒劳的。</p><p>除此之外，那些阻止所有 cookies 的用户通常明白，这将会破坏他们的认证功能，他们会为他们关心的网站单独解锁 cookies。作为一个网络开发者，你无需解决这个问题；一个更好的解决方案是告诉你的用户为什么你的网站需要 cookies 才能工作。</p><h2 id="JWT-缺点"><a href="#JWT-缺点" class="headerlink" title="JWT 缺点"></a>JWT 缺点</h2><p>既然我已经讨论了所有常见的观点和它们为何错误，你可能会想“哦，这没什么大不了的，即使 JWT 对我没有帮助，我仍然可以使用他”，但你错了。使用 JWT 作为会话机制确实有很多缺点，其中一些是严重的安全问题。</p><h3 id="JWT-令牌空间占用较大"><a href="#JWT-令牌空间占用较大" class="headerlink" title="JWT 令牌空间占用较大"></a>JWT 令牌空间占用较大</h3><p>特别是当使用无状态的 JWT 令牌时，所有的数据都直接编码进令牌中，你将很快超过 cookie 或 URL 的大小限制。你可能决定将它们存储在 Local Storage 中，然而……</p><h3 id="安全性更差"><a href="#安全性更差" class="headerlink" title="安全性更差"></a>安全性更差</h3><p>当你将 JWT 存储在 cookie 中时，它与任何其他会话标识符没有什么区别。但当你把你的 JWT 存储在其他地方时，你现在就容易受到新一类攻击的威胁，在这篇文章（特别是”存储会话”部分）中有所描述：</p><blockquote><p>我们从上次停止的地方开始：回到本地存储 (Local Storage)，这是一个伟大的 HTML5 新增功能，可以在浏览器和 cookie 中添加键&#x2F;值存储。那么我们应该在本地存储中存储 JWT 吗？考虑到这些令牌可能达到的大小，这样做似乎有点道理。cookies 通常在大约 4k 的存储空间上达到上限。对于大型的令牌，cookie 可能不适合，本地存储会是显而易见的解决方案。然而，本地存储并没有提供 cookie 所提供的任何安全机制。</p><p>与 cookies 不同，本地存储并不会在每一个请求中发送你的数据存储内容。从本地存储中检索数据的唯一方式就是使用 JavaScript，这意味着任何经过内容安全策略检查的攻击者提供的 JavaScript 都可以访问和提取它。而且，JavaScript 也不关心或跟踪数据是否通过 HTTPS 发送。在 JavaScript 看来，这只是数据，浏览器会对其进行操作，就像对待其他任何数据一样。</p><p>Cookie 开发工程师为了保护 Cookie 内容做了巨大努力，而我们现在正尝试忽视他们给我们的技巧。在我看来，这似乎有点倒退。</p></blockquote><p>简而言之，无论你是否使用 JWT，都必须使用 cookie。</p><h3 id="无法使单个-JWT-令牌失效"><a href="#无法使单个-JWT-令牌失效" class="headerlink" title="无法使单个 JWT 令牌失效"></a>无法使单个 JWT 令牌失效</h3><p>还有更多的安全问题。与会话不同，会话可以在任何时候被服务器无效化，但是无状态的 JWT 令牌无法被单个无效化。设计上，它们将一直有效，直到它们过期，不论发生了什么。这意味着你不能，例如，在检测到攻击者后使攻击者的会话无效。当用户更改密码时，你也不能使旧的会话无效。</p><p>你基本上是无能为力的，你不能”杀死”一个会话，除非建立复杂的(并且有状态的!)基础设施来明确地检测和驳回它们，这已经违背使用无状态 JWT 令牌的全部意图。</p><h3 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h3><p>这个问题与上述问题有些相关，而且是另一个存在的安全问题。就像缓存一样，无状态令牌中的数据最终会「过期」，并非数据库中的最新数据。</p><p>这意味着一个令牌包含一些过时的信息，如某人在其个人资料中更改的旧网站 URL - 但更严重的是，这也可能意味着某人有一个具有管理员角色的令牌，尽管你刚刚撤销了他们的管理员角色。因为你也无法让令牌失效，自然无法撤回他们的管理员访问权限，除非关闭整个系统。</p><h3 id="实现的经验不足或者根本不存在"><a href="#实现的经验不足或者根本不存在" class="headerlink" title="实现的经验不足或者根本不存在"></a>实现的经验不足或者根本不存在</h3><p>你可能认为所有这些问题只与无状态 JWT 令牌有关，你可能大部分是对的。然而，使用有状态的令牌基本上等同于一个常规的 Session…但没有经过严格测试。</p><p>现有的会话实现（例如 Express 的 express-session）已在生产环境中运行了很多，很多年，因此它们的安全性得到了很大的提高。当你使用 JWT 令牌作为会话 cookie 的临时替代品时，你无法获得这些好处 - 你将不得不自行实现（并且在过程中很可能引入漏洞），或者使用一个没有经过实际检验的第三方实现。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>无状态的 JWT 令牌不能过期或更新，而且根据你存储它们的地方，会引入大小问题或安全性问题。有状态的 JWT 令牌在功能上与会话 cookie 相同，但没有经过严格测试和好的实现或客户端支持。</p><p>除非你在开发一个类似 Reddit 规模的应用，否则没有理由把 JWT 令牌作为会话机制。只使用 Session 就好。</p><h3 id="那么……JWT-到底有什么用呢？"><a href="#那么……JWT-到底有什么用呢？" class="headerlink" title="那么……JWT 到底有什么用呢？"></a>那么……JWT 到底有什么用呢？</h3><p>在这篇文章的开头，我说过 JWT 有其良好的应用场景，但它们作为会话机制是不合适的。这仍然是正确的；JWT 特别有效的使用场景通常是那些把它们作为 <code>一次性授权令牌</code> 的场景。</p><p>从 JSON Web Token 的规范中：</p><blockquote><p>JSON Web Token (JWT)是一种紧凑的、URL 安全的，用于在两方之间传输待传输声明的方式。[…]这使得这些声明可以通过数字签名或使用消息认证码（MAC）的完整性保护和&#x2F;或加密。</p></blockquote><p>在这种情境下，”声明”可以被理解为”命令”，一次性授权，或者你可以将其描述为如下的任何其他场景：</p><blockquote><p>你好，服务器 B，服务器 A 告诉我我可以&lt;在此处填写声明&gt;，这是这里的（加密的）证据。</p></blockquote><p>例如，你可能在运营一个文件托管服务，用户需要验证身份才能下载他们的文件，但文件本身是由一个单独的、无状态的“下载服务器”提供的。在这种情况下，你可能希望你的应用程序服务器（服务器 A）发布单次使用的”下载令牌”，然后客户端可以使用这个令牌从下载服务器（服务器 B）下载文件。</p><p>以这种方式使用 JWT 时，有一些特定的属性：</p><ul><li>令牌的生命周期很短。它们只需要在几分钟内有效，以允许客户端开始下载。</li><li>令牌只预计使用一次。应用服务器将对每次下载发出新的令牌，所以任何一个令牌只用于请求文件一次，然后就被丢弃。根本没有持久的状态。</li><li>应用服务器仍然使用会话。只有下载服务器使用令牌来授权单个下载，因为它不需要持久的状态。</li></ul><p>如你所见，在这里，将会话和 JWT 令牌结合起来是完全合理的 - 它们各自有自己的目的，有时你需要两者。只是不要使用 JWT 来处理持久的，生命周期长的数据。</p>]]></content>
    
    
    <categories>
      
      <category>国外翻译文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>Session</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肠胃镜的经验分享</title>
    <link href="/2023/07/29/%E8%82%A0%E8%83%83%E9%95%9C%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <url>/2023/07/29/%E8%82%A0%E8%83%83%E9%95%9C%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="肠胃镜的经验分享"><a href="#肠胃镜的经验分享" class="headerlink" title="肠胃镜的经验分享"></a>肠胃镜的经验分享</h1><p>外卖，重口味，压力，情绪，工作都是你得肠胃病的诱因，年轻人的身体越来越扛不住了。2022 年 5 月 3 号晚，照常点了一份重庆红烧牛肉面，又点了一些煌上煌的零嘴，快吃完时突感不适。</p><p>咽喉仿佛被卡住，一直想打嗝却打不出，胃胀气难受，一晚上都在折腾，之后一直都没有好。中途看过一两次中医，一次在老家一个岁数大的中医，另一次是深圳市三甲医院的中医（医学博士），喝了很长一段时间的中药，钱也花了不少，服药期间好一些，断药后症状依然还在。</p><p>至此，对中医产生了极大的怀疑。一直到 2023 年的 3 月份去深圳市第二人民医院做了肠胃镜，拿了报告，医生开了一点药，这才好了。</p><p>如果长时间胃部感到不适，且整天担心自己的胃病，强烈建议去做一个肠胃镜，肠胃镜不但能治你的胃病，也能治你的心病。</p><h2 id="肠胃镜预约流程"><a href="#肠胃镜预约流程" class="headerlink" title="肠胃镜预约流程"></a>肠胃镜预约流程</h2><p>本人是在「深圳市第二人名医院」就诊的。</p><p>挂号基本上都是通过小程序或者公众号，微信上搜医院的名称就有。</p><p>首先，需要去挂「消化内科」的号，已经决定接做肠胃镜，就找一个最便宜的医生挂号，让医生给你开个肠胃镜检查的单子，就可以了。</p><p>开的单子包含：胃镜单、肠镜单、麻醉药品、清肠药物、除泡剂。不同医院给的可能会有不同。</p><p>由于人多，预约肠胃镜的时间可能需要 7 ~ 10 天，不绝对，取决于你就诊的医院。若预约的是无痛肠胃镜，医生可能还会让你做一个麻醉评估，遵循医嘱就好了。</p><p><strong>选择正常的还是无痛的？</strong></p><p>看个人体质，建议无痛。我也是看过很多人分享肠胃镜的体验，才做无痛的，真的就是和睡觉一样，没一点感觉。据说肠镜往菊花灌气时会非常痛苦。</p><p><strong>肠镜要一起做吗？</strong></p><p>建议还是一起，除非你能判断或者医生帮你判断不需要做肠镜。如果是无痛的，肠胃镜一起做更方便，只需一次麻醉即可。当然肠镜的费用也要加进去。</p><h2 id="无痛肠胃镜体验"><a href="#无痛肠胃镜体验" class="headerlink" title="无痛肠胃镜体验"></a>无痛肠胃镜体验</h2><p>约好之后，医生会告诉你如何用药。一般是在检查的前一晚用药，需要服用「泻药」，泻药不难喝（因人而异），味道像菠萝味的脉动，难受的点是需要大量饮水。喝玩泻药之后，半小时感觉就来了，之后会连上好几次，另外建议备一些湿厕纸，保护好菊花。</p><p>清肠准备妥当之后，去医院准备。在做之前，医生还会给你一个服用一个麻药，很小一瓶但是巨难喝，麻药作用在你的喉咙，做胃镜的时候身体不会有异物感。</p><p>进入肠胃镜室，让你侧躺在床上，医生给你打麻药，感觉有一股凉嗖嗖的液体进入，随着 1.2 次深呼吸你就进入昏迷状态。</p><p>等醒来的时候，已经在等待室了。整个感觉像睡了一个很舒服的觉，刚醒的时候医护还会让你多坐一会，醒醒麻药，清醒之后就可以走了，整个过程都是无感的，并且身体上也不会有明显的不适。</p><p><strong>活检和息肉</strong></p><p>肠胃镜过程中医生发现有 <code>息肉</code> 或者 <code>糜烂处</code> ，都会做一些处理。当然这个是在做之前需要签一个同意书的，若不同意医生也不会处理。息肉一般都是直接切除，以防息肉变大引起癌变。糜烂处也是需要取一点肉去做活检，检查该部分病变的情况。</p><p>过程听起来很吓人，都但是实际上一点感觉都没有，本人就取过活检，无不适感。取了活检还需要等待活检报告，方便医生判断病情。</p><p>总之，无痛体验真的很爽。我是上午做完的肠胃镜，当天下午就可以去上班，只是迫于自己太懒，就打了一下午游戏。</p><h2 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h2><p>本人深圳一档社保，总费用大概 1700 多，包含：药品费，多次的挂号费，肠镜，胃镜，麻醉费，取活检费用（肠胃健康则无该项费用）。</p><p>最终个人自付 230 多，其中取活检的费用是 220 多，因为本人在昏迷状态，所以活检费用是朋友帮忙交的，没有走医保。所以实际上医保基本报销完了，力度还是挺大的。 </p><p>完。</p>]]></content>
    
    
    <categories>
      
      <category>生活类 blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>肠胃镜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 中的 Session 到底是什么?</title>
    <link href="/2023/07/04/Web%20%E4%B8%AD%E7%9A%84%20Session/"/>
    <url>/2023/07/04/Web%20%E4%B8%AD%E7%9A%84%20Session/</url>
    
    <content type="html"><![CDATA[<blockquote><p>博客参考：<a href="https://blog.by24.cn/archives/about-session.html#comment-10457">https://blog.by24.cn/archives/about-session.html#comment-10457</a><br>推荐阅读：<a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/</a></p></blockquote><p>在 Web 开发中，会使用一些技术来维持用户登录状态。此时，你会立刻想到 Session，但如果要你解释为什么能维持登录状态，你也只能说：大概是 SessionId 之类的，巴拉巴拉。</p><p>是的，之前别人这么问我，我估计也是扯这些东西。你要问为什么是这些东西，那我只能跟你说八股上是这样写的。</p><p>大部分人从八股中了解 Session 知识，但这些还不足以让你对它有清晰的认知。</p><p>不信我问你几个问题，SessionId 是什么？SessionData 是什么？面试官常问的 Session 和 Cookie 的关系？Sever-Side Session 和 Client-Side Session 是什么？Java 常用的 Web 容器 Tomcat 是如何处理 Session 的?</p><p>如果你无法清楚的解释上面的问题，那么这篇文章非常适合你。</p><h2 id="登录状态与-Session"><a href="#登录状态与-Session" class="headerlink" title="登录状态与 Session"></a>登录状态与 Session</h2><p>Session 翻译成「会话」，他表示的是一次「谈话」，谈话期间双方可以任意通信。</p><p>在 Web 开发领域，Session 做的就是维持用户登录状态。那么它是怎么做的呢？</p><p>回想一下登录的场景，输入账号密码登录后，Cookie 中会多一个 SessionId 信息，该 SessionId 是你的身份证，后续的请求 Cookie 都会包含该 SessionId，这样服务就知道你是「你」。</p><p>那么问题来了，服务端是如何根据你的 SessionId 来判断你是「你」的？</p><p>当然是登录的时候，把<strong>你的信息</strong>给「存」了起来，用 SessionId 把你的信息关联起来。流程如图：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Web%E4%B8%AD%E7%9A%84Session/image-20230704154258027.png" alt="image-20230704154258027"></p><p>用户渣渣丰登录时，服务查找 “zzf” 用户信息，将用户信息存到 <code>Session存储中心</code>，然后返回 SessionId。渣渣丰后续的请求都不用再登录了，带上 <code>SessionId=10010</code>，服务器去 Session 存储中心查 id 为 <code>10010</code> 的数据，便能直接获取用户信息。若找不到，则表示用户未登录，走登录流程即可。</p><p>返回给客户端的 id 称作 <code>SessionId</code>，SessionId 关联的数据就是 <code>SessionData</code>。Session 这个模糊的概念就可以简单的理解为：<strong>SessionId</strong> + <strong>SessionData</strong>。</p><h2 id="两种-Session-存储策略"><a href="#两种-Session-存储策略" class="headerlink" title="两种 Session 存储策略"></a>两种 Session 存储策略</h2><h3 id="Server-Side-Session"><a href="#Server-Side-Session" class="headerlink" title="Server-Side Session"></a>Server-Side Session</h3><p>上面的登录过程中，SessionData 是存储在服务端的，称作 <code>Server-Side Session,</code>，这也是大多数网站使用的存储策略。他的特点是客户端传输只需要传 SessionId，在没有理解 Session 前，就很容易把 SessionId 当成 Session 本身，而无视了 SessionData 的存在，这正是很多人理解不了 Session 的原因。</p><p>对于还未登录的新用户，去访问系统的其他请求，此时用户并未携带 SessionId。服务器会处理当前请求，新增一条 Session 数据，其中 SessionData 为空，然后返回 SessionId，并提示用户登录。</p><h3 id="Client-Side-Session"><a href="#Client-Side-Session" class="headerlink" title="Client-Side Session"></a>Client-Side Session</h3><p>与 <code>Server-Side Session</code> 相反，<code>Client-Side Session</code> SessionData 是在客户端（浏览器）存储的。每次向服务器发起请求，都要带上 SessionData 信息。</p><p>因此，这种情况都压根不存在 SessionId 这个概念，很多人也很容易因此搞混，不清楚 Session 究竟存在哪里。</p><p>对于新用户来说，本地没有任何信息，服务器便会初始化一个空的 SessionData 返回。后续的通信中，SessionData 才会被填充有意义的数据。</p><p>这种做法，很明显有个巨大漏洞：用户直接修改本地的 SessionData 数据，冒充管理员怎么办？</p><p>因此，使用 Client-Side Session 需要使用<strong>加密或者签名</strong>等机制，来保证数据安全，确保 SessionData 数据都是由服务端生成的。</p><h2 id="Session-和-Cookie-关系"><a href="#Session-和-Cookie-关系" class="headerlink" title="Session 和 Cookie 关系"></a>Session 和 Cookie 关系</h2><p>严格来说，Session 和 Cookie 其实没有半毛钱关系，只是 Cookie 常用做 Session 的载体，因此很多人也被弄得迷迷糊糊。</p><p>还记得上面客户端「带」信息（SessionId &#x2F; SessionData）的过程吗，信息传给服务端需要一个载体，这个载体可以是任何服务器能接收的东西，例如放在 URL 中，我们也完全可以把 Session 信息放到 Header 中，事实上也有很多网站是这么做的，比如一些禁止使用 Cookie 的网站。</p><p>大多数人选择使用 Cookie，自然是有他优势所在。服务端可以设置 Cookie 中的信息，且禁止客户端修改，这样能防止 Cookie 信息被篡改。由于 Cookie 中的信息在通信中，双方都能接收，因此 Cookie 是很适合存 Session 信息。</p><p>总之，Cookie 只是一个用户存储和传输 Session 信息的工具，仅此而已。</p><h2 id="Web-容器对-Session-的支持"><a href="#Web-容器对-Session-的支持" class="headerlink" title="Web 容器对 Session 的支持"></a>Web 容器对 Session 的支持</h2><p>在 Java 开发中，经常使用到 <code>Tomcat</code> 容器，他提供了对 Session 的支持。 Tomcat 也是属于 <code>Server-Side Session</code>，查看 Cookie 可以发现他使用 <code>JESSIONID</code> 字段存储 SessionId，SessionData 则存储在服务端的内存中。</p><p>Tomcat 默认使用 <a href="http://www.docjar.com/docs/api/org/apache/catalina/session/StandardManager.html">StandardManager</a> 来管理 SessionData，查看源代码可以发现，Tomcat 容器在退出时将 Session 数据持久化到磁盘中，启动时从磁盘中加载 Session。</p><p>对于 Tomcat 来说，他的「Session 存储中心」就是内存，但 Session 也支持其他方式的存储，例如 MySQL、Redis，甚至可以直接存成文本文件。<code>Spring Session</code> 就对 Session 做了全方位的支持，使得 Session 更易用。</p><h2 id="Session-和-JWT"><a href="#Session-和-JWT" class="headerlink" title="Session 和 JWT"></a>Session 和 JWT</h2><p>Session 和 JWT 本身就并非对立面，甚至是「一家」的。JWT 是一种生成 Token 的方式，他通过签名保证 Token 信息不被篡改。</p><p>使用 JWT 的时候，也是登录时候拿到一个 token，后续所有请求都带上 token。你可能会说，哎这不是 Server-Side Session 的方式吗？</p><p>并非如此，服务端并没有保存任何信息。相反用户的信息 (token) 是被客户端持有的，只不过该信息并非明文，需要服务端解密才能查看。</p><p>因此，JWT 实际上就是 <code>Client-Side Session</code>，比直接传输 SessionData，他将传输内容变得更安全精简，只需一串字符即可。服务端只需要按照既定的规则验证签名，解析用户信息即可，也不用额外存储任何信息。</p><p>总而言之，Session 更像是一套用于维持客户端和服务端通信的方案，而 JWT 则是具体实现。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS 与信鸽</title>
    <link href="/2023/03/05/HTTPS%20%E4%B8%8E%E4%BF%A1%E9%B8%BD/"/>
    <url>/2023/03/05/HTTPS%20%E4%B8%8E%E4%BF%A1%E9%B8%BD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自国外的技术文章，原文<a href="https://baida.dev/articles/https-explained-with-carrier-pigeons">链接</a>。</p></blockquote><p>密码学是一门很复杂的学科，全是数学证明。除非你要开发加密相关的系统，不然没有必要了深解的太深入。</p><p>如果你想通过这篇文章，来创建下一代 HTTPS 协议，这是远远不够的。若你有了觉悟，泡杯茶，然后开始学习鸽子通信。</p><h2 id="Alice-Bob-and-…-pigeons"><a href="#Alice-Bob-and-…-pigeons" class="headerlink" title="Alice, Bob and … pigeons"></a>Alice, Bob and … pigeons</h2><p>作者声明：关于 Alice 和 Bob 等名称未做本土化翻译处理，目的是让读者能够在脑海中将密码学和前面的名称联系起来。</p><p>你在网上的做的任何操作（阅读文章，逛淘宝，分享宠物照片），本质上是向服务器发送消息，和接收服务器发来的消息。</p><p>这似乎有点抽象，我们假设消息都使用信鸽传输。这个比喻可能有点随意，但是 HTTPS 的原理就和信鸽一样，只不过比信鸽传输消息更快。</p><p>我们使用 Alice、Bob 和 Mallory 来代指服务器、客户端和黑客。如果你不是第一次学加密相关的知识，那么你应该对这些名称很熟悉，因为它们在技术文献中被广泛使用（译者注：技术文献中出现 Alice、Bob，就像高中英语作文中的「李华」一样）。</p><h2 id="第一次简单的交流"><a href="#第一次简单的交流" class="headerlink" title="第一次简单的交流"></a>第一次简单的交流</h2><p>Alice 向 Bob 发送消息，她需要把写好的信绑在鸽腿上。Bob 收到 Alice 的信，一次简单的交流就完成了。</p><p>假如鸽子飞行过程中，被一个叫 Mallory 的坏逼抓住并篡改了信息呢？Bob 是不可能知道消息被篡改了。</p><p>这就是  HTTP 的工作原理。很可怕吧？我不会通过 HTTP 来发送我的私密数据，你也不应该。</p><h2 id="加密交流"><a href="#加密交流" class="headerlink" title="加密交流"></a>加密交流</h2><p>Alice 和 Bob 很聪明，他们协商用密码写信。他们将在字母表中将每个字母移动3个位置。例如 D → A，E → B，F → C。纯文本消息 “ secret message” 应该是 “pbzobq jbppxdb”。</p><p>现在 Mallory 抓住了鸽子，但由于他不知道密码，因此并不理解信的内容，他也不能把消息篡改成有意义的东西。但是 Bob 可以反推出消息内容，在 A →D，B → E，C → F 的地方解密消息。密码文本 “pbzobq jbppxdb” 将被解密回 “secret message”。</p><p>成功了！</p><p>这就是所谓的<strong>对称密钥加密</strong>，即如果你知道如何加密消息，你也知道如何解密它。</p><p>上面描述的加密方法通常被称为凯撒密码。在现实生活中，我们使用更复杂的加密方法，但主要思想是一样的。</p><h2 id="如何商定加密方法"><a href="#如何商定加密方法" class="headerlink" title="如何商定加密方法"></a>如何商定加密方法</h2><p>如果除了发送方和接收方之外没有人知道使用了什么密钥，那么对称加密是非常安全的。在凯撒密码中，密钥是我们移动每个字母的数量的偏移量。在上面的示例中，我们使用了 3 的偏移量，但也可以使用 4 或 12。</p><p>问题是，如果 Alice 和 Bob 在开始用鸽子发送消息之前没有见面，他们就没有办法安全地商定一个密钥。如果他们把钥匙放进信封里 Mallory 就会拦截信息并找到钥匙。然后通过钥匙获取消息内容，再篡改消息，发给 Bob。</p><p>这就是一个典型的<strong>中间人攻击</strong>例子，唯一避免方法是改变现在的加密方式。</p><h2 id="信鸽带盒子"><a href="#信鸽带盒子" class="headerlink" title="信鸽带盒子"></a>信鸽带盒子</h2><p>所以 Alice 和 Bob 想出了一个更好的办法。 当 Bob 想向 Alice 发送消息，应该遵从以下原则：</p><ul><li>Bob 放飞一只鸽子给到 Alice。</li><li>Alice 在鸽子腿上绑一个盒子和一个打开的锁，然后自己留着钥匙。</li><li>Bob 把消息放到盒子里，并用锁锁住盒子，发给 Alice。</li><li>Alice 收到盒子，用钥匙打开盒子，读到 Bob 发的消息。</li></ul><p>由于 Mallory 没有钥匙，就算抓到了鸽子，也无法打开盒子篡改消息。Alice 向 Bob 发送消息也遵循相同的原则。</p><p>Alice 和 Bob 通信使用了非对称密钥加密。顾名思义，它是非对称，即使你可以加密一条消息（锁上盒子） ，你也不能解开它（打开盒子）。在技术语言中，盒子被称为<strong>公钥</strong>，打开它的钥匙被称为<strong>私钥</strong>。</p><h2 id="盒子值的相信吗？"><a href="#盒子值的相信吗？" class="headerlink" title="盒子值的相信吗？"></a>盒子值的相信吗？</h2><p>如果足够细心，你可能已经注意到通信过程仍有一个问题。因为 Mallory 可以拦截鸽子，并把盒子换成自己的，当 Bob 收到那个打开的盒子时，他无法确定是 Alice 的盒子，还是 Mallory 的。</p><p>Alice 决定在盒子上签名，当 Bob 收到盒子并检查签名，就知道是 Alice 发来的。</p><p>有人可能在想，Bob 一开始是怎么认出爱丽丝的签名的？好问题，Alice 和 Bob 当然知道这个问题，所以他们决定，让 Ted 代替 Alice 签名。</p><p>Ted 是谁？Ted 是一个非常有名，且值得信赖的人。Ted 会给每个合法的人签名，大家都相信他。</p><p>Ted 会先确定要签名的人是 Alice，才会给 Alice 盒子签名。Mallory 无法让 Ted 签 Alice 的盒子，Bob 会知道盒子不是 Alice 的，因为 Ted 只有在验证了身份之后，才会在盒子上签名。</p><p>Ted 在技术术语中被称为证书颁发机构，您正在阅读本文的浏览器附带了各种证书颁发机构的签名。</p><p>因此，当你访问一个网站时，你会相信它的输入框，因为你相信 Ted，并且 Ted 告诉你这个输入框是合法的。</p><h2 id="盒子太笨重了"><a href="#盒子太笨重了" class="headerlink" title="盒子太笨重了"></a>盒子太笨重了</h2><p>现在 Alice 和 Bob 可以安全可靠的交流了，但同时他们也意识到鸽子带着盒子传消息比只带信封慢很多。</p><p>他们协商一个对称加密秘钥（还记得上面的凯撒密码吗?），并把它放进盒子里。另一方收到消息后，就知道对方要用什么加密方法，加密接下来的消息。</p><p>在现实世界中没有一直绑盒子的鸽子，使用非对称加密技术加密消息比使用对称加密技术加密消息要慢，所以我们只使用它来交换对称加密密钥。</p><p>现在你知道 HTTPS 是如何工作的了，你的咖啡也应该准备好了，尽情享受吧。</p>]]></content>
    
    
    <categories>
      
      <category>国外翻译文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 线程模型</title>
    <link href="/2023/02/14/Java%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/02/14/Java%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h3><p>Java 虚拟机规范并没有对 Java 线程的实现进行约束，因此 Java 线程的具体实现由 Java 虚拟机决定。Java 在早期的虚拟机上也使用过用户线程实现，但目前的主流 Java 虚拟机线程模型普遍都使用操作系统原生模型实现。HotSpot 就是将一个 Java 线程映射到一个操作系统原生线程，接下来讲解都是基于 HotSpot 虚拟机的线程实现。关于 Java 新的 <code>Project Loom</code>，读者可自行了解。</p><p>不同操作系统的线程概念也不相同，比如 Linux 中线程被当做一个 <code>轻量级进程</code>。每个操作系统线程操作的 API 都不一样，但是 JVM 实现了这一切，为我们屏蔽了这些细节。对于开发者来说，只需要使用 <code>new Thread()</code> 就可以得到一个线程。</p><p>这种直接把线程映射到操作系统的操作，使得线程的管理全权交给操作系统，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都取决于操作系统。</p><h2 id="系统线程调度与-Java-线程调度"><a href="#系统线程调度与-Java-线程调度" class="headerlink" title="系统线程调度与 Java 线程调度"></a>系统线程调度与 Java 线程调度</h2><p>首先，需要简单的介绍一下什么是系统调度。线程调度是指系统为线程分配处理器使用权的过程，线程并不是一直占着处理器的，而是交替使用的。要以什么样的策略去交替使用线程，使得每个线程都能够得到有效执行，就是线程调度方式。</p><p>正如上面提到的那样，Java 线程的管理权都交给了操作系统，Java 中的线程调度实际上就是操作系统中的线程调度。因此，这里需要介绍一下操作系统的线程调度方式。</p><p>线程调度的方式有两种：<code>协同式线程调度</code>和<code>抢占式线程调度</code>。</p><p><code>协同式线程调度</code>：线程的执行时间交由线程本身控制，当线程执行完自己的工作，会主动通知系统切换到下一个线程上去。它的实现简单，切换操作对与线程是可知的。但是执行时间不可控，倘若一直占有处理器，那么程序就会一直阻塞。</p><p><code>抢占式线程调度</code>：线程执行时间由系统分配。线程的切换不由线程本身决定，在 Java 中有 <code>Thread::yield()</code> 方法让出执行时间，但无法主动获取执行时间。因此，每个线程的执行时间是可控的，不会因为一个线程导致整个系统阻塞的问题。</p><p>Java 使用的是<code>抢占式线程调度</code>。尽管无法控制线程的执行时间，但有时还是希望对某些线程多一些执行时间，另外的少一些，这时可以使用线程优先级。</p><p>Java 中有 10 个级别的优先级，从 1 ~ 10。两个线程同时处于 <code>Ready</code> 状态，优先级越高的线程越容易被系统选择执行。但使用线程优先级这种方式，并不稳定。由于操作系统也拥有线程优先级，且和 Java 提供的线程优先级并非一一对应，尽管在 Java 中使用不同的优先级，但在操作系统中看来还是同一优先级。</p><p>例如：Java 中给线程 A 设置优先级为 6，给线程 B 设置为 7 ，映射到 Windows 中的优先级是<code>THREAD_PRIORITY_ABOVE_NORMAL</code>，两个线程在系统中都是相同的优先级，调度不会发生改变。</p><p>除此之外，在Windows 中存在「优先级推进器」的功能，当一个线程执行的特别频繁时，系统可能会越级去给它分配时间。因此程序不能完全依赖线程优先级，它并不「靠谱」。</p><h2 id="Java-线程的生命周期"><a href="#Java-线程的生命周期" class="headerlink" title="Java 线程的生命周期"></a>Java 线程的生命周期</h2><p>Java 线程中有 6 总状态，在任意一个时间点，线程只会处于其中一种状态。JDK 源码的 <code>Thread</code> 类中的内部类 <code>State</code>，介绍了这 6 总状态：</p><ul><li>新建（New）：尚未启动的线程。例：刚 New 出来的线程。</li><li>运行（Running）：在 Java 虚拟机中执行的线程，线程处于运行状态。</li><li>阻塞（Blocked）：线程等待监视器锁（monitor lock），所处的状态。</li><li>无限期等待（Waitting）：处于该状态的线程，不会被处理器分配执行时间。只有被其他线程唤醒之后，才会执行。</li><li>限期等待（Timed Waitting）：与无限期不同的是，一定时间内没有被唤醒，他会自动唤醒。</li><li>结束（Terminated）：已终止的线程状态，线程已结束执行。</li></ul><p><strong>阻塞与等待状态的区别</strong></p><p>拿去医院看病举例。医生科室门口挤满了人，但每次只能有一个人就诊，谁先挤进去谁先就诊，后面的人只能等就诊人出来，这时等待就诊的人处于<strong>「阻塞」</strong>状态。医院改变就诊方式，只有叫到号的人才能就诊，没有叫到号的人只能一直等，此时等待就诊的人处于<strong>「等待」</strong>状态。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>Java 使用 Thread 来表示线程，线程相关的操作 Thread 类都有提供对应的 API。但是想要访问每个线程的局部变量，却需要通过 <code>ThreadLocal</code> 。 </p><p>那么为什么线程局部变量要通过 ThreadLocal 来访问？</p><p>直接使用 Thread 中的局部变量好像也没什么问题，可以在线程启动的时候给他的变量赋值，结束时 JVM 会把线程和变量一起销毁。这种方式当然可行，但是却忽略了线程池管理线程的情况。线程池为了复用线程，不会在线程执行结束后立即销毁，而是在需要时被重复利用，直到线程池关闭。正因为如此，线程局部变量会存在上一次的信息，很容易出出现线程安全，内存泄露问题。</p><p>当然，每次使用会线程，进行一个手动清理变量的操作，线程复用就不会有什么问题。但麻烦点就在于清理，手动管理非常麻烦。ThreadLocal 每次使用完也需要进行清理操作，只需要调用 <code>remove</code> 方法即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文讲解了 Java 线程，但是作者心中存在很多疑问：CPU 线程、操作系统线程和 Java 线程之间是什么关系？他们之间是如何协作的？协程又是什么，与线程相比解决了什么问题？Python、Kotlin 是假协程？不同协程实现之间存在什么区别？</p><p>对于上面的问题，已经在收集资料开始写了，下一篇博客《线程解惑》正在路上。</p><p>参考资料：</p><ul><li>《深入理解 Java 虚拟机》第三版</li><li>《Java 并发编程实战》</li><li>ChatGPT</li><li>V2EX</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java 线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-年终总结</title>
    <link href="/2022/12/29/2022-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/29/2022-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊在过去一年的成果，包括生活和工作。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>优化自己的知识渠道。</li><li>学会接纳孤独。</li><li>换了一份很棒的工作。</li><li>继续保持独立思考。</li><li>花了一笔大钱买了 MacBook。</li></ul><h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><p>2022 看的影视作品看的比较少，只看过几部精品</p><ul><li>n 刷了《武林外传》</li><li>《异物志》</li><li>《铁齿铜牙纪晓岚》1 ~ 4 </li><li>木鱼水心 - 《水浒传》</li><li>《怪奇物语》第四季</li><li>《The boys》 第三季</li></ul><h2 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h2><ul><li>给 Vue 的中文文档提交了 <a href="https://github.com/vuejs-translations/docs-zh-cn/pull/611">PR</a>。</li><li>写了一个 Java 版的语雀导出<a href="https://github.com/greek-zzf/yuque-expoter">工具</a>。</li><li>重新优化自己的<a href="https://greek-zzf.github.io/">博客</a>。</li></ul><h2 id="2023-的一些目标"><a href="#2023-的一些目标" class="headerlink" title="2023 的一些目标"></a>2023 的一些目标</h2><ul><li>工作顺利、生活愉快。保持自己的好奇心、做自己想做的事。</li><li>学习 MIT 6.824 课程。</li><li>尝试学习使用 Go 语言。</li><li>产出更高质量的博客。</li></ul>]]></content>
    
    
    <categories>
      
      <category>年终总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="/2022/12/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/12/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="80533d381adab334b5a899428d9e1c3509e963ff307333969b2fa9003432a792">fa23842582e98a4cf3bb0c939f1220ee2b412fb8d52fa325c51adf3935c1d3042fbfb4070209612ff7749c63ba68a2ea567ff18cf9a29ba162893f1ce29db52442b4f6c6b361c8c29fc70d09ecff15718112d97b04a63cda42427ef8a267dd89721f15f8cdcc13555d506fe8c136eadb3ed39a717781792ff427d9a229e2bfad10f9555c1ffabe08e401fe7f684a6ce9f4ba5a367121570c6eb972d5cac402ed76a3fda13eca9c509421f430ced5376711da98832e14bfe7119bdd83c4a1179deb1f3960a66611b85972957e8c3d64101caa19d6743aed00873ad845bfcd7dacdbefdbc78dc8fb19830d6ea76431c271c68af7abc292ea0c36d08beed9c8d8127b596a642a04a74c814f6f5805085c19659c786c2f105b895b244444132784dfdaaf7c6af326a021d305e83a2fa4980636e0710297eb3066bb1dc2dfd203ef8b72aa71b704b3c426e065a2019049c029169b56eb2164d4255ec1b09fd86b365af9b8604405af9b09f016810c93ec07f56dce1aa492eb6e68b05482ebae688f07685c69ed7e8f6949e074655d35a58bbddd5368841c42ef231202d14c74fa8d72b6c04c1dabcc50071958bd06f35f9d01b4522430e7954f767cad697b5e3171af109ee148c4f9923e2ffba99cebbd92f9436e21c1471f4629a4fb6d99e70bbc5fe39af9287d18e32b26ebcb6e03c57f46e88905b2ce87f42df4eeac7780e97cf523b32d092f695c83bd63fcf2c1f70324f70ded6376c9ff0f201af7f5e703f92b6e677d25ba50801c10f71b29b86fba7bf92ac57e355afbe99bd7ffe4c931caafcf68364006cb837e30ee02fa8e10a1d1f8334dfb30f02357fa7fca2093456ab462bb1c5e897c03079b036174b2b5f08a40d004c6283b7c99d827bfd3b5a6da6d06b9e20377cd1b52a9ecc457cf17188b433ccca93b7f8e043a84ae3e9a4196de316c07797d80fe92130fd0720a1cd1fb26134b5c45070ea579e13b6ef7f39aa0dad6f3bb3aa43c40a0af814a7fef9f90f3df832bd339c9fe0d8ba5039815b5b8e0e9e63ddf4e1a650dc04a60f64db50c2a6b1ecb4416b9a698be2fa54a6cba6b5a0c1194f83fb16f69fd5bbf1ba1adba0086132f4e56ce81cc4b759af03fe0f337c517e7c730180d5190b7fd6dc4ec1a80df80fb3b9bbb91af15f085c46f4b41219fe4f3cdcd09a9f9bb5fcdbbccb71366ab52e02dcaa6569ad3e0cea8d8bfbafb46d25b8f312013d97a4f789aba1d6796cb422f85ade374b18c19ef3f02dc8a0e5db16af7f4af740d8bca7302ec374e7ddd90ff973ad476d1181f76048642c169b1cc832935abf9744b1d72c968c2cccbc7e57ed556401500bb5262fbf2cea9ba90065a04165402b0dedcb67f921ba042cd20b76889c0f9402a4904898e941a581255c000980934d16c3e2645d3e59e2cb9fa8c7e8f9fa23ac238cd2c623d837404ec334cdaa17957f334d9009ed4cc28f8de5ef1a76c66a77d7b3c06008fec9855fb75112f8d92003032aa87be5d6e10a0578567dc25ff41107c8630aabdf41246eee2f15fa14154f5f5149b047082afa9a5b411328320688ebdfc55610447aa3a42bc0d3268c7960e32e8619531babf13e73361fe5c86da38892e75e53a0cf6d362bec34a19b69b64970928b5256ccd337dae8f49ab7f6367dfe35ae888447bdc457224bea04726cc9365c3052602daead7c73bbd0fc2f576db95918063f768141f3013230f386d4165bdb90096bc19e71c80b516449f872731e62008306f54659e72f071ebeb3f6469f5302e43c8b051cb1005bed51f3c8c3bfc96e1671ff23a0b0e76bc75aeefba6a6f809e98f4cd13fbaec114413b389f0b36cdbf9bab2b3f336d89819d4d09f904586c690b5c0209f49746c7806ffa7f88c9987774777499445ad4543147fa55764e58212980f6bcb131e9a15224623c6fd57df2b241896d909fc7f3c1435a3a9c639d4bf93097e6b7f5e79dcf9aa66ad2194c138590ff8b8cfb90d2e393e84beb497dd5fcff7cdff747d0932bfd8cdf5d98ea2d77e2312a727b5012be5c91292c857c0636a007721e8a58a7c6aaafbd7fc6cb613e93f3eb8d1881f86bcf4db50e8cc5d0359c192bf922b2a178fecb89a15341a60a466a069a1fa96407d8266719225e6dd2f558e97256e3340d1a438bfe7cfc8ed6cffdb5656d9471a2614b691dccf11ed9f4ba68aacec7869a5d6d75c9c1880c3bf6a7d3ab05fc3deb5d0213720e8c15da81aea4b13bbbfeff2f207278466ed3e2b2907ba27c5fc33b23e670c9d8b56f357cfee9a14bbfd12ab80e6ae88400431936b68cef4b58a1115ab0f4855cd4f5adf72f83d1495f92fb833c55a801f5d3149e507873cfe5650c37364a056624058537cb64e96b090c0783aa6b6a9fd3c8104cb9e4ae8f95cf123631f249b299d63019db5db32e40825fc27fc81a7318047b97d9fcddb66589c7f76e5e8761e1246af152f694650653f4a5517491681b7c88ce188440a0b342dddd8d57120f318484dbc653b93289204d90946ac087119929529db09639e06a4646c16ac30e629436a2edb21c4924c212eecfcb7bfebdd52c6bf9b3292c62a0e4cffdf66f3d0d4f58a362225b839c69062bfcba13f50ef751b467fcad6bfc0a0fc082f3ce1e4da833dab97cd851ebe3c57c7c79fc7a6daa1026f03dea78230225bb12bf822668a8e8267287b3e656c890df29220281b4098bdb84569e55e8b2831cc4f5be3e05d725d25c878521ed9e4212f31c030c352f7e81c5bc591209f9d8cc3d6315edd2d0bfc6fa671977c71473fbe65650d59e52ac3f80dd716b7332a67a572f697713f5def6853187d6edc0a9daf12c50220b4a1ac8f7b515ac9b997fd1d80c1b5ae47d8e0e8f5b180fb0ef9896cad75a7d40bdc4cc7c9f422a8b864f1d18dea43d567c2a0a3e56d6029e09896529e4f7e55753aa7391fb560549ddfd6022685017bd9b8e9db81d0bb2d8e2cea15bada0a5e978de318aadebacce870546a6bb0488df3601446a6e97018ad39e3ac5ba92e493f62c035927bbd37ef26c91118b61c8cb8caade5747bdf596e5419969f643df2e30d21bb4a3f27593c51b9b06a7083c33a4236b66de0ecc0773ca8e8b31ad46e2eb763b8dce3982a4c191ce1d77c4a21036a0870f003594080e1aa28a54edf16c2e0d58adf489f7eff4308a60b9e246b97f4dfcd0704e56428600f5cdfaa56527c6d067aa53f0d898d5eb026265131286f908757bbf339bbdf832f0f5e5475b49f56d5322a4c6b28223603bb9ed0a168a32ee5031951ee628fac4f35a2db0cb96410009f44e1be0fa65e441c96cc1e2716b78826d0d17be73feedb2b84c432c1494dad42f916156968164106ea6ee817388057838e1c79191de6209aff44b763196569cd767732eac7aabe8329b757e0d9259a69eb89693925150094304fe207a6cbada0e5556a92202c61fee2a953cd714bcd291afbe6a4a4ff5fca31465449864fa24894ea1f51452ab332eedddef1ec76339a8bfbac7a876b45018846edf1c4fe49838a077dac348e89ad3f431208e95e2ddf340270377844b589b89d0921523058ebda54e4a409223f16c00b1f3ee49b32886a3702263e257ae46c0e2173ba4fec80f82f450f5f78e41ca127e2944dbf8bddec11bb288ae917b049eb38f8c55af492af51d2165d112842115c0598828c4e53852c8fcf907ba3cb76ed8277a9571361046dbb26960bf8bb11d276523c7a65b0c78bd9167f68a03ce4082a9cfec50d8ff647158d70c2784528af5f33082ac2a014b6d8bb660f69d733f3c2ceaaa7d613e13c1594633c63c331e9265c7c827b7458f0265a9aec99746cd60d0812d468441ecd4279ad47f24a9e0cb301ca7b65b31d807c0da0d400b4c87455fc585500400c57c35a8fbf6aec0e0e8c3fcff2c78f3710fb8e4c5ef1cb4fd37a1b2c7061de9aa398228f8ebb9249d3b056ebcc77e8f0edd595189aed980c5fe0c1759ff5b03496f0033ed4f66502b358f905bb700d0c6dd326a107d71a072dff382c398a0f82268a47742ee5153a656b33238a27ca48d5e98cfe5ab713dc857d40312fd2a25f43cb3bc661ed4b16bb22db36d727d06f577f03003376e8979ead4ed578c9978e268a3d17d056c8cfab84b1e8c3ef47b67d8c377bec99a2f3e8a22a812f9521cd8e1a551d68e5f96d077ffa493e66a9c11b27c0ec1532024253e1042425cd5a11515a82357707fe589f83b5bedfbdcb4745d38813982ab6b02b8acbcb877d219782a0fd38343495ba9c42a8a7e26e6f238f946786c6580985ebec7d82d1c86fc824ddb74c9e679fd818ebf635c16cf41b02a89066da2d73934030cb4516883fc3e933725fdda78b32359f2ecee9afc3f655de120c361adb1554521713cf8cd057a1c2d8c0eeb613c2287c67f8de38b21146216860ae2830bbb7b372c2ab30615668ae1d8191dd3d2c206afcd2511ed9505b8057ef3bfd0129e2e47887ab9456ee29bcb7ef110e6af4e1c9fa3d5f8a5387c44d2aa900ec86aa14fde16fa8636c30182d4b1ac0c18304f40567333281f9edf97d56fed016efb92ea016b2d9d9c340625d1fe3221344e09f347d7f7217145f956f3352dc723badce7bba8166245c06abf3852e0c7b77a64f62f1bae477e49c75fa775e418983df23522fb381e352aaff3894aab81fc249dd9017c92498084956ad0330449dab8a519d631098a5bbb61819ff812350560740acfa94a74d7abcec1155102de409ed2d7a2ff45d833323ffa5d134083ab7b4fd0ccc6eeb7703159a8c47b37bcc44d71969627946d2843018ad7ec7f5494936e2b91c2d1a050238db5cb8284d52740f47e06fcece93bb93016aee064730640fa5b8763180f236cb4d6c276f97e31c96cd5e0fed32ceb72f9a3616f4dec15bdee1bfa6b72e8e1c5421bce19623d4766b74c5583ee1a8b140ad0e8146d4fa0bad7b79de873e1528429847921d5514474a5373250bcc7eb7c277cceb7b142da160b06e5e1f1fcf495321663d1ec866cde6b78f84c55c4c2f702bbead73a983a6fed5676c351b0fd3c31f11ce3f42299f6c91da189c3020a7c2480e14b5e18b3a99b772d1cd9393e7faaa4e0d9887771c9ab40fa75d56d85a0fcc281efb5fbd2903542a10a8498dbc1837818e3ecc92bee485774061d573ddce34b7950b6055535a5df75cb25a473669b08864e619fa936183342eaca0cef1c3287aab7c07863114720388544ad135a04ab6fff3240f56f6a06ffcba25ed975178997b0a8ba7382e868195466fe8208291f25963b25fdfaa1a0dc15b6d19192d8cf11012954a7d2b8f3ed8b09079bb9f6d4ab9682179d09c5053805f29d3e33bf765f6a914e492070faf0984fd4e8a1ef3dbcb978768cee29141502a9696d0c31110cc35926eacfca26a8fa8b132b6b5725d6af4b5d09123c20bdd34dcc0d484937f90d0c0888e87e5ce587654b6bcbee08389daaa73ed5be43c3e87517a4fe00cc13e2a14b2e77fd6dc9d7dbaefd77219fafdcd041f48d534bcf743e092f647b2182b7508f608eca266ab8e3b74c1986d069e42e145d0f759185d916227fb2e575cbe02f89ad86b9a439de7c3d75c7768f9187c88e5363819b35774248bf4c5be07af4013b936821c9a5c0d729862ccaecb8527f440bc5b951edcd478f69ae9b65f18d8e9db3525b22027d0b7bdc754462b706c878aa2a4e6056e4cce2c36696631ee60f63b4bff7591caf07e0063ed53ccfdb346594e8d5e61b7e4f9108f3c3f74716ce5fea39f67043f0fd0f873a64929920b05e69ae7d1d97186771b9f7623b096b4762906303f339c3835ac9f868339e9f4f921e3ab4cc00183d951a2fc92f361849bb1b3ed81f6ca60ddfda055926b0def2dad6cc04950da916b87608586adaab63a713e25544a4b0964587e92d8965e5e5e6e5f6ee0cec9c173085d3c863b2c3f78e67043d335649c6356a6c6d967360797d1cde2a5517f546ac3dc38858560655e96b38932111f648dca3b330f92a5a355cba7d2ff1512debaafb551813e7f0d3a0e5c7858bdf482ea92dd6ec74fd4ceabb767b39e8941373e597a9717a0698031272b911faf6885162d1b17fb429da2dff706d65f3a3db442ab41d430603820e10935f70e5420f1366bf5616894b40336995e4c2de97126c0c3bd632829a8fdea8c930dc71d8c7c1a27ae8bc2518a37a547e6b4a3a34c3fc6d8250c086cb0b24bb3d752ef5e16a72ab9a1fab4181bf0a1fec8a6f532f1023dc177a3a90c85ebe2625579589048f6f0ed0ff73da6eec197d42ee667c35fb691506652c272690bd704471fd44cad91244c9310eede808884c03480ffa2e461c2ca781ea456ff94a951b7e28b7d2a17e3537f0c6b5979119a53f9a2865d2347f808d082578d8971e3743b1ac5ec7df75d195d403baa066b5e3c6d575167d17c42888ed97a4a7258dc50b2c099cafd0627f5b008ad6ebd47dfa6bc493cbf6a65f0c6de9f235ef9a90b0ff6e3dd3673c2016b7e59e8a0e83bcbb68d4e08345e6d46b1b2fb9080ff7183498bf832abb4239e64e32952962695571fb4f49be1f4e0f7877aad107c2f3cd38cfa8b8640bc9ead001606bb47761372ec4ceb19bafda1f2d1b42d55e27fd5f7610b36790564d3b4da0149afbd6d149e46fa2cf746d69bbd00349f4efd20cbc553ada80924135823e210f168f53130768ca4c18c5b88a6168481e951155db887f27c8c2daa580d35d1dc7e732df43da40b55eaece62b532a5b26864fa9c6cc6894316b0fe7b2bcf013aa5b2e5bd5ce7d378d4a3b895a69b76cb42dc80eacf52f9692b350f4c81ec993ff1697a39ed147a1827ab33655c833bbd6ecce455292d6036b71131d5dbe4dbf141ada4a65c648f9a059659ed19a91618f432390f68b934d3dbfd312b911e9f8ac96380dfe03251c4ef70661090cc69cd38bf3806d5a70e3a502d782b45a8505aa91a0e8a79f315412c006d50e3e066bf9191ab366cd35d054f91bce73393583545ce8ef8f987795049e57ae7be52e2eaa732841f2824f7176de832461aca71eb5561c6da692fa48ad5005635523ae3ab55fa0375e98c4fbc8aeca9e0bd8e5bf6d9e24d66f3e0c04b31ed93ea54d3a32e41f1b6db694fcf86990ccf6992ceae5051d99ecc1d46526fade917e37674e139dc2498ba37b034e81add56e07657b051ed114f586c4d7a47e45ecdb0018397452c238a659734088a2b5667149b3cf918eca304950190f5a78dbe20db9b7e1c885a47578e606fef8e82498337004472347baff34895576379f38333790fdc5f5e824c78a1a02c64675a8404d04a34ae5ec2376af00c9d638f7babf9c03c434e09cd40bcf34ff3d07e49ab51dbd9808013cd60460d5ddc4f0ecca9e6a22962920f733bd0cd7b0dbeba814149e015282778d6dc6d7f2f4fd5bb05deee6a7c62b448977d86e3df02186fc571e2cca78a9c5e93191f6914c513133bc42e6e7002bcfd23bb7c42f38fce7cbaf7ac566e8289f423766b98969eeb5f0239dfd647e9a9125e041059066d431482dfd5f48726188deb7839339adce9361d27a02cf8ad8ed01f802a07b7162dcaa2d8842ab6c8308fe2dc64c3ea3cc6e65ef756043629782212781304fc4dd5370b14e2e80b1721a947ef553b8aa2747aee32067c403d4445262696ebecccc90a2a2aa97c59a8b9ddf11fa88d39842c4b6d546a11e5fad2d02e78353d16876d445ce324dbc453aae622096658562a1ff1ab56e9fd45ff44b6bdea1800856699e1456fd2622d7d548b070b2b69af0505516830eb3cbf8d864a1a08f5a3545b76a57912be52d1e0093b3391241fea7d165e1b6c545f9019e8ab8033e01a931806811ffbd1d52ac1947e80903a2498cf79e33f9b18a93313f1c7ae73cfadcdaacd4fb4e32b8a968a364366c2e8aabad1aebfeb2b726f703ae2fb2d7a83897179589e0c81adf8783c68e692cf1449ae90ae77d4d903c068255e5d898345d0aa38bbff8ce232164ca8cc070cd30dd97a3f0b8d067231ba1dc3ff05923378fed3fb514af92071933dd649c86bdc4c5b07894a36cfa241dbcee727e37d90a49071e561152ee35116c50cd692f76532addab81f34888b4d6f58fdb20f63a8f22301ef3e7c13985102a78951b85d8cc61476ddf50f466050c05ee2428610e40e1d96b2fc3ff1f420f42b31e89b26b9efc2c0ddc533e3703a655e9f0b1d40bf5eea7d892466dbcf4a3b5b40621cc30d5351d9aa78c9d38b16b7963d88ab1f62e4ff0265d0384f4dd9784161d2997af0133e61dff0b3e0ac49ca8b33423d78ef41ec3d2dccc1097c76e7157d1d428a4139e0d900c09fc0042523c1c6514327a58fa46e21ab3bbe918e13a793d186dac55308625b7ac15e4153ddc7ab9886e0eb3913dd1d2f61416f1a37b151a738cbfe682e9893b32ccee77cc35cc04c9cdd53d1ea4cd866d4e6b14cd838c99b6c11e2f4add61422864da6bbfdc1d8707cd61819506775c6efba1cbced0ce0a244e1b01a2a6ba93472ca2f4a824f24eb6fed801f04cb277a588721257078bfff34623aa6730d544c38f58e7473392134b30f14af13632a23deaa31f2126fd47654ba1596e6001de44cfb3ea38e19a0ca586a416d4085068b19c1f29ea31aec13109904f10430339c3bca6ddc5ea4eb5ebd941c836336bbb628ee7c32f2552ee5346907b53aa135e9148f618d6fd75b68c12f380b4ec3d1cb149ff6176f47989b66104d1fab6921c8f86f80ca54ba29689b29a199d0b56a7abfda45100519c5ab47e447cbacf20da52fbfc174770217d48bce966e96260b694165ea592383c360ec63c645d85760b7b06d8326fd6bbbed86691eb47ba86f8cf445a7d668a59a9438d0cc1a8897844918e90557c719c7a1e0c3fc67fba86033cc561dcbe75a91a68709c890d5f99fad472176ab14562991c929ecce527af79960c17f6e90e62bcdddb168a7d661d3a302f1258e898215832dbf7c2e472b0706def87522bef599183ca52db2aeff48cf4e05b8e6057a64fdc2fc6767f79a55f2f08e8992bdefdd37c8b5914bfc3abaa25519b56778912f22d53db31f5bfdf4ef4572cc5277ff5273c1e83cb8c1401a19c878e7e3f147c6740f55204a596faa14aaaabb2a31f0552d88755735cf84789453c319a9c324c4816897cb9e08981fff0786bb89b649fe763e8f27567171ef12fcf2a577f607ea0df52f2e6836ec0933d1bf82b5299d8d355b20285f985fc4931d0d30e455f301638fb1377f11f5a803b4c37413ebd066a400267aa5cd1c8a0ddae4e7f874755c67b17b938a582cfe9747d42d830db02efee406919eb1e3f5130223320b802a5691f45d56f9ad8b75e2d17c8fdbe5f01ebf3c8d8088a789f6a4f3406059abfa01e5bf03efbb427d789c05eb7a13c56fc53977646aeebfa89795612252613124ee151ab682b8ca7187e3568df12a33a9b3c5392fdaa97f40327f8ef59327bde71d7e95c8ba7dfde97e92e030e2f970b3710daf86fb88a0bb58028e90109fe78043f0a7ecdf55fd831e32978f98104a760ebf7145190a23c4eac474de8becfca5139875c30943deacb150a3c06cd1f8832a95dfe68977c0c5e325fe3ab598209eb2ad5c58b00de7f94d03adabaec2f755eda7eade921acc244c99be5afa59d778d51a1a83d9fe3298e787412c09a1e3b371af185d2db2e90b2d315f37418f08e89bc6bdcb7f67dd64b4ccc18d5c5721cbcdc3d29114d49ca034a480665af02b75d7abb1b3d6ac1dd1400fb59d0cabc9552f765e00f7f2989a3fafa174792e40f58edabb988317e1f1d0f34d6884771833228845c0558af0b4fb8d76eb1899334ab21e7328cd043e8c67b12e40e2885ae520d835cfbdd7c192a3ced9eba28c52138910f5d3239b0f1701299ffdb2557eaaa5445e4dbef43cd53bbb494eb83fb7f1ccb36aeb52921c493e1cd70b6204b0fe4711c08bf34656ba16fd22edd1ac620b27c060855991a4f074dfca76f5eba7d68594a2480523a059acf878386a13b1962d2bc587965dee6a57ba1519c18df293ea1221dbcdbff01c23cf080543538b03ce8cc1379c9d3d63abee7b67e304c0330e43cc092afb67c8ce1e6bcff8d1c9deb3af6b3654cdccccd93a5f1995731ffff773b10e67a69404803ff04da3892060895a206c1212b2db562c9e05bf33bcf8bf572b6d1a76602f70f28d952aa97af24ad7cb3fdf869297f1c96787ce3ab5a21967f71a1ea8af1b6e23f0d9255d12924643950c78a366a0f86158dfcf618d772184d245b146dd70afa16d0ad42c943cbd78d0c868c1808cb2f2a58842b31ab9a5978294fa4bb5bebf636cf07b552e43b3669714b60d259b2e7cec4586e23af26f3318791b9f8b6b551ad2085144252157520df56f6db383fcd97d02c2e08f4098e4290c503646af85b3db257f183c5e8241384b85a070f231567ce43848d91e97edae970c27affdcdab101fc3d71120e5d20a78663f7867777f3852d71fcc43d67704a6678759816d413165258da6f11a89e69037911a8344d6f90f26479a426d41843f634e0851f592fdfb6eb741660b83b000e3f43870f3148e8193be5954834b0073e4352be885dc9b8b0bc1746236fc24e970f914fd6a63e229e24d112777c354f97c599c6b476ae3ead81b3946bc5a038d850e3bdb55761d6a85f1c115b3407f63cf03661a72190fd9974ef59210a3b5243c06ccee9b0429a21b447af7c28fe5cf1a3561a37b88d5378f9dc3498b4a5560c0b727aa1011f4d23c31d0538679482f0714afe665d224098f3461f713b83e7d43d954b7dbfcd5febe5e0db07385845b8ed3de9b1dca00ff1dfb7ca1c56e4cb08e28d2e5d99881d80fe51ebe1c92c8600dbfbb005cf830b7af17a5c751f9d7308a3bde185fd96d8a1d741edfdba64002f9f15462b61c4cfb731b34a59ec10010bb14b22f8dba89dce5e42551612b2cd2a422f6ad07f6d1725ac2bb38d9323e5bb0e797d5a185061ddcdc8ce3db079915c4900b0eaed6a4e2e7a4b8bfb6b477f51076b7ee516976f4e0e00f591c09ba186969a5edeaa50762006363c924e7f713def74c07812624d65493012ded93a7fd434a8047aa55808683808732b6a2e21d9f1f5620e94124b0ca2f171d13a41400cf482f222c4c7eb2017f63c0ad5d12232a948e0f5e514dbc51e1d37d6fd51f07e2f0dd4794069827ce50cd650d46a0ea130dd7235382f4a61015cd6db64c21d89ab0ed706e440dbe2570619bc53cf6d6365d0fee280bce51ec1e572686a42efb45779ad11cec395ca487d21967cc11cddb4d556b4a42e5845f885d9529133b344b0fb111869062c428206fe3dafcdf3a50cf5b7bd5fed62fd4bee2006a7fd9e59a11a8c94ac81085b1b6c1bd754e79e04cc6b5da4212ae1f801089dc566ecca2f18f917dfad53c8bb795852dd79d327794b17f951751838e0d727244c58fc6191dbe545398768a4dad4f1bb8864cd7077bc30f0bb137d930759925548f77a8532281acf195d94dd588278833c55fc876a01f075927393e907f5e12ce00b0101b6179bee0b91b8aec1973350c93ec26f722cda96dadad9c1eccaaf2c5bda4ab8c914c2a440fd70bb9225c26f5fa338d6698cb944579819ae46b0d000ff0d2c2eb7ca1ddc6cf6beca5f727cdba8f5a5dc3126a3be9105ac354f6212bcdc9e0fb25e93a8f576c49e7d3eac7d6e0d47632624b27e9d69983fea397bdb871c2de930a527503c6b1eb91d96fa0ecee4ff8c1c0c41e4c31be0a9634693679f677dacbd607f9072e847cb401f1da7e2bf2f8bb0518edf8aa4ea892ff36be5133ad0aebaa166e23f71b30bf86906defe1939a20e7123068ae8e64f5d3abe9c722dadfd4ddd90743dd2d0b4f6c7fbf691727e6143621c2b57c9d2c80fb4c5e4b2305881e0f001bf116ff4fd2a9a439f0dca975f556427039f2d4a160ec2c19dcf71b1ac1b49fbb573270ad686c0c77fed8c53601a760f7c797ffee26a446b2260c7568dca79658c564912dde69b6f6a04a33c000d5b5bead8d0487caca8b75cc5d034882020832facdfe92e600248e2b07e1ff41c05bd3ff4301f4fd2d1d57fbd68e2838eb497996f0a3b320d401af1edec5a1ee5c53c92c7f23f27ef6d7db8c50ed7b6367ba1b517f4d3f646a4994939700eff9eadd6991ca0fff7c642facd616602a92fd8190dca61d3b8ec70147a73116ad68137cd89ea2155a3ddfb6a157197b95cb2492c78792ba4d6886acbb96d1964f4bdca68eb394eaa94e2cf166d92c6247a87a1ad8ca69516382c6d51cad8e1e7ada17d2e2c8e5712e7808d7b181deaeb5cd008e53d5c6b2b4bc4e1b43a9a7d50d42254a0abd65e937093e7d464fcd4aa1df034e27d5e869aeed9e9e74853e64113bdcec71162400753e0584b53335f05fae1bbd9142f9e074896c4117e6f265bbfa6dac7487c0fd78f66b5b99d2190c68ebc097c27338094835e323ed5a3ea9c08402c73b4f6991c168ca29673d00319aab44dc1249f0d07137d57d494e824ebb22fba5b2991689a61394ba5f24ca47d2a0b57c73a1a3b2e1e1339ca81a0b430e92bd3d2c079084e865e6b99e96323be51fca798a80b8b89694dc6b5a665ae34e8fc5047fd0b109d4ede826da170f110134458e46eb4c3a84ee61d3e8163db858397821346098a6e4d40c5082c52df9b54313fbfa665f1640837a2147201bc81cb965c367c4d8f39cb48e5f988c1e993222c2939e1d68d9a04fd7a14d4e6eac137cc02c13e4d2ec6e7121a06f017c7ec047bfffeaf31e08c1fed81811e39e7efc04649bd77fa3d312732232f3add7eeed7b9ef871776c99b54ec1ba7e1508dc46a0c86a73acd18807bc98c9ce80a2a3c850e1bbad692ab1bef7f6683f867ae439d9687026be1ac4b7e5e4700ff5f893b361d64d51a6e7b227618c1f92c92fe95cec6aa02b3e44e41699c91835c2659c220f2f5886d16b571ea5c6dfe67eac944f7146e879f02dc2b7baf5a193fd2e5b5637a6d13873e2bee99928e7b59f075758dd2169e20a16eabc65fdac73f1dd709a65977bbf1565997de06ad80b682087d7ded4dbb8ef863d95a1c9004f7e61106952682da255d2beba1039bf4e2b13c38357c106ff4a2dd2083915c5ac21387b50fc566ecf40768de3277821a68845f66702e5016a03037abec0d717bd85c20dc1e86a969b3aa2442ec39471c8db3871efde43429fc3b8637d2d85a7f1f9cfc162ce257a0869e3f8490905de6b257ad7ee966b574fe40014c88724640c85e768415794c4dce188c3567522b624b5073bcff3dc6a07e71b664fbad901e7f389cf132e321e6507d956ed91ed83c6de8fec234a22ff632f53044756b4216c5e574fd82e19b40c92dedeace0c69cd83b36776f06ac6264fe8cff6679c3f77701c26f2c6700667e63924884cd608b93eeea12303d9fca876e01bd5f0b16176f74550c6fe55c14304e6a437e5c24208042e783d28cdb0edcf6dc813cd169a0cc658f84e42390011499ed9ce05172a2c967431754a6c493db1dcf929ed2b2221714186e89c4c4a3119508be1d7e19497f72f5accc464ac69cb878cecf22d904d058f72eab7612b6659add3f430a047c20ba7442183907ac52dbc7e6e340f56ef28d92e3e4af4b6f8c33f315e2d1f563bfd3837c61eeb20782b51615cdc48b79b55156100aad3ae5f031bdc8001a8dd3136cf7643e75e434b2ad7fa69ea09eeca7f625c1539e72c00a69983c9f1d69f323a6f1dc1a14f8e673505681b0d3d9216ec87521f89d943b76ea307bffc0c7dc874e1dc10dc3ba3de9397d284f100779dfdb025334f893e469672eb8e43a45687b79bfa298a6710ec03038b51ddec14f35bc7d9c2da6376720a6df7b35ec0f8a08b20ac488e9c87957d8fd51354c6f0fca7817e0020b69f7893573cfb0236be5f7559449bb45f124dde391e972ec1fd170a2d00f9bb6f7890023b71605043cd5d0489ca26ff12a56c867ccd639ed45d9fe04d347facb70daae6b17eb6a4554f5e588b7013dbac5192dc180e7404fe9c965b8d9f3fc159f89f8b8ccec2d1ab2f4cef5571134d49afb75d2ecc18ad0dae9c4bacb3b1ff39a2db28fd27fd845d7491fda64021f7625418a0aff12866dae83fba592fca472411d276086785aa6cc900b15d0a126f4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 服务化的几种方式</title>
    <link href="/2022/12/13/Linux%20%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/12/13/Linux%20%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>使用 nohub 命令，例如运行一个 java 项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohub java -jar xxx.jar<br></code></pre></td></tr></table></figure><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p><code>tmux</code> 全程 <code>terminal multiplexer</code> 意思是终端多路复用器。它可以启动一个新的终端进程，可以通过一些命令在当前终端和新终端之间来回切换。</p><p>因此，可以在新的终端进程中运行程序，然后使用命令切回到现有的终端即可。</p><p>tmux 一些常用的命令：</p><p>创建一个新的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux<br></code></pre></td></tr></table></figure><p>回到当前终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用 control + b，再使用 d 即可<br></code></pre></td></tr></table></figure><p>回到新的进程中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux attach<br></code></pre></td></tr></table></figure><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p><code>nohub</code> 和 <code>tmux</code> 的方法，都无法应对程序崩溃的情况，程序崩溃后需要人为重启。将程序执行改为系统服务，即可解决该问题。</p><p>此处使用 Unbuntu 的创建服务的方式举例：</p><p>创建一个配置文件 <code>my-program.service</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description= a service for java # 服务的描述<br>After=netwprk.target<br>StartLimitIntervalSec=0<br>[Service]<br>Type=simple<br>Restart=always # 自动重启<br>RestartSec=1<br>User=root<br>ExecStart=java -jar my-program.jar # 服务启动命令<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>创建完成后，启动服务即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start my-program<br></code></pre></td></tr></table></figure><p>服务配置详细信息，可以参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">这里</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>使用 docker 启动程序，在启动参数上加 <code>-d</code> 参数即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d my-program-image<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 9 语言特性</title>
    <link href="/2022/11/22/java9%20history/"/>
    <url>/2022/11/22/java9%20history/</url>
    
    <content type="html"><![CDATA[<h2 id="接口中允许添加私有方法"><a href="#接口中允许添加私有方法" class="headerlink" title="接口中允许添加私有方法"></a>接口中允许添加私有方法</h2><p>java 8 中添加了 <code>default</code> 方法，但这些方法之间却无法优雅的复用代码。例如：<code>methodA</code> 和 <code>methodB</code> 都需要调用 <code>biFunction</code> 方法，于是只能将 <code>biFunction</code> 方法声明成 <code>default</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Java8Interface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biFunction</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明一个新的 <code>default</code> 方法当然可行，但却不符合接口的原则。将不必要的方法，暴露出去会给调用者带来困扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Java9Interface</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        biFunction(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biFunction</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>允许私有方法后，只需把原来的 <code>default</code> 改成 <code>private</code> 即可。</p><h2 id="try-with-resource-优化"><a href="#try-with-resource-优化" class="headerlink" title="try-with-resource 优化"></a>try-with-resource 优化</h2><p>Java 7 之前关闭资源需要写如下代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> br.readLine();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 7 之后引入了 <code>try-with-resource</code> ，简化了 <code>finally</code> 块的代码，现在只需这样: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...)) &#123;<br>    <span class="hljs-keyword">return</span> br.readLine();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是需要使用的资源一多，代码就会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...)) &#123;<br>    <span class="hljs-keyword">return</span> br1.readLine() + br2.readLine() + br3.readLine();<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-keyword">try</span> (br1; br2; br3) &#123;<br>    <span class="hljs-keyword">return</span> br1.readLine() + br2.readLine() + br3.readLine();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：变量声明在 <code>try</code> 外面，很容易误导用户在 <code>try</code> 语句结束后，仍调用资源，这会导致运行时产生错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(...);<br><span class="hljs-keyword">try</span> (br1) &#123;<br>    System.out.println(br1.readLine());<br>&#125;<br>br1.readLine(); <span class="hljs-comment">// 此时资源已关闭，调用会报错</span><br></code></pre></td></tr></table></figure><h2 id="不再是有效标识符"><a href="#不再是有效标识符" class="headerlink" title="_ 不再是有效标识符"></a><code>_</code> 不再是有效标识符</h2><p>Java 9 之前可以将 <code>_</code> 下划线设置为变量，虽然编译器会警告，但运行不会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">_</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>System.out.println(_);<br></code></pre></td></tr></table></figure><p>Java 9 之后，代码会编译失败，会得到如下提示: </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">java: 从发行版 9 开始, &#x27;_&#x27; 为关键字, 不能用作标识符<br></code></pre></td></tr></table></figure><h2 id="菱形符号"><a href="#菱形符号" class="headerlink" title="菱形符号"></a>菱形符号</h2><p>Java 7 引入了菱形符号 <code>&lt;&gt;</code>，让编译推断构造器参数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 7 之前</span><br>List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br><span class="hljs-comment">// java 7 之后</span><br>List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>自动参数类型推断，简化了代码。但是匿名内部类的参数推断，却不支持。</p><p>这段代码在 Java 7 中，编译器会报错。Java 9 支持匿名内部类的类型推断，代码能正确执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(T content)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(content) &#123;<br>      <span class="hljs-comment">// 实现方法</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java9</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Bisect 快速上手</title>
    <link href="/2022/11/09/Git%20Bisect%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2022/11/09/Git%20Bisect%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>假设你刚接手一个项目，这时线上出现了一个 bug，因为对业务不熟悉加上老板施压，导致 bug 定位过程异常艰难，开始焦头烂额。</p><p>聪明的你转念一想：既然无法准确定位 bug，那不如先找到是哪个提交引入的 bug，这样再去定位 bug 就简单很多了。</p><p>于是你确认了bug 存在的 commit 区间，使用二分查找来找 <code>bug commit</code> ，假设 bug 存在的 commit 区间是（3 ~ 10），你开始了如下过程：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitBisect%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/09b81c4f-3a12-469e-aa3d-2bd9bfcb8fa7.png" alt="find-bug-commit.png"></p><p>你确定了 3 是没有 bug ，10 有 bug，于是使用二分查找，找到 6，判断 6 有 bug。继续缩小范围，最终找到了第一次出现 bug 的 commit 是 4，就能确定 bug 是 4 引入的。</p><p>这个手动查找的过程比较繁琐，而恰好 git 是有命令来支持这个查找行为的，这个命令就是 <code>git bisect</code>。</p><h2 id="bisect-命令参数使用"><a href="#bisect-命令参数使用" class="headerlink" title="bisect 命令参数使用"></a>bisect 命令参数使用</h2><p>将上诉过程使用基本 Git 命令，来表示。</p><ol><li>找到引入 bug 的 commit 范围</li><li>二分查找，并切换到分支</li><li>运行代码，判断是否有 bug 是否存在</li><li>重复 2、3，最终确认第一次引入 bug 的 commit</li></ol><p>现在使用 <code>Git Bisect</code>来实现，步骤和上面都差不多，只不过省去了很多人为的动作。</p><ol><li>告诉 Git 需要开启 <code>bisect</code> 模式</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect start<br></code></pre></td></tr></table></figure><ol start="2"><li>告诉 Git 需要查找的 commit 范围，需要指定一个 good (正常代码) 和一个 bad（存在 bug 的提交）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs git">// 切换到 commit 10，并标记为 bad<br>git checkout 10<br>git bisect bad<br><br>// 切换到 commit 3，并标记为 good<br>git chekcout 3<br>git bisect good<br><br>// 这样 bisect 就确认了 commit 范围<br></code></pre></td></tr></table></figure><ol start="3"><li>步骤 2 执行结束后，Git 会进行二分查找，并自动切换到对应分支。只需要再验证分支是否还存在 bug，存在标记为 bad，反之 good</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">// 根据实际情况标记为 bad 或者 good<br><br>git bisect good <br>或<br>git bisect bad<br></code></pre></td></tr></table></figure><ol start="4"><li>只需重复 3 的过程，最后 bisect 会帮我们找到第一个出现 bug 的 commit。</li></ol><h2 id="In-Action"><a href="#In-Action" class="headerlink" title="In Action"></a>In Action</h2><p>实战 Demo 地址: <a href="https://github.com/greek-zzf/advanced-git">GitHub</a> 或 <a href="https://gitee.com/geek-zzf/git-bisect-practice">Gitee</a>。</p><p>这个项目有多个版本，从 v1.0 到 v9.1，其中我们能确定 v1.0 是没有 bug，v9.1 是有 bug 的，bug 的表现形式是一条输出语句<code>I have a bug!</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m version 9.1!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;I have a bug!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;A bad feature!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>git bisect</code> 查找过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs git"># 切换到任意版本(需要提前确认该版本是否存在 bug)，由于已确认 v9.1 有 bug，切换到 v9.1<br>git checkout v9.1<br><br># 标记 git bisect 开始<br>git bisect start<br><br># 存在 bug，标记为 bad<br>git bisect bad<br><br># 切换到不存在 bug 的分支，标记为 good<br>git checkout v1.0 <br>git bisect good<br><br># 此时 git 已经自动切换到一个新的 commit，标记当前 commit<br>git bisect (good or bad) <br><br># 重复上一步，直到 git，给出如下提示<br>xxxxxx is the first bad commit<br>commit xxxxxx<br><br># git 已经帮我们找到了，第一次出现 bug 的 commit id，此时需要手动结束 bisect 过程<br>git bisect reset<br></code></pre></td></tr></table></figure><p>执行 <code>git bisect reset</code> 后，bisect 过程即结束。</p><p><strong>使用脚本</strong></p><p>bisect 支持使用脚本，使用脚本的目的是帮 git 来判断 bug。git 执行脚本，根据脚本的执行结果，自动帮我们标记 good 或 bad。</p><p>上面的例子，可以根据输出结果包含 <code>bug</code>字样来判断 bug，对应的 shell 脚本命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>javac Product.java<br>OUTPUT=$(java Product)<br><br>if [[ $OUTPUT == *&quot;bug&quot;* ]]; then<br>  exit 1<br>else<br>  exit 0<br>fi<br></code></pre></td></tr></table></figure><p>这个脚本执行 <code>java Product</code>，判断输出结果是否包含 <code>bug</code> 字样，包含则 exit code 为 1，反之为 0；</p><p>有了这个判断脚本之后，上面的查找流程可以大大简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"># 标记开始<br>git bisect start<br><br># 把 v9<span class="hljs-number">.0</span> 标记为 bad，把 v1<span class="hljs-number">.0</span> 标记为 good<br>git checkout v9<span class="hljs-number">.0</span><br>git bisect bad<br>git checkout v1<span class="hljs-number">.0</span><br>git bisect <span class="hljs-title function_">good</span> <span class="hljs-params">(in v1<span class="hljs-number">.0</span>)</span><br>    <br># 执行脚本自动化查找过程<br>git bisect run &lt;脚本名称&gt;<br>    <br># 脚本执行完之后，手动关闭 bisect<br>git bisect reset<br></code></pre></td></tr></table></figure><p>至此，bisect 查找过程结束。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>git bisect</code> 在业务开发方面使用的比较少，但是在开源项目中，使用相对比较频繁。</p><p>对于开源项目，可以使用 <code>git bisect</code> 帮助开发者定位 bug，贡献 issues。</p><p>对于棘手的 bug 定位，<code>git bisect</code> 为我们提供了另外一种解决思路。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操蛋的 Git</title>
    <link href="/2022/10/16/%E6%93%8D%E8%9B%8B%E7%9A%84%20Git/"/>
    <url>/2022/10/16/%E6%93%8D%E8%9B%8B%E7%9A%84%20Git/</url>
    
    <content type="html"><![CDATA[<p>Git 中的一些抓狂经历，平时遇不到，一遇到就很操蛋。</p><blockquote><p>部分参考：<a href="https://ohshitgit.com/zh">Oh Shit, Git</a>  <a href="https://github.com/k88hudson/git-flight-rules">git-flight-rules</a></p></blockquote><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><h3 id="本地分支太多了，老子要删掉。"><a href="#本地分支太多了，老子要删掉。" class="headerlink" title="本地分支太多了，老子要删掉。"></a>本地分支太多了，老子要删掉。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 看一眼本地有哪些分支<br>git branch <br><br># 删掉本地对应分支<br>git branch -d &lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="远程分支有点多余，老子要删掉。"><a href="#远程分支有点多余，老子要删掉。" class="headerlink" title="远程分支有点多余，老子要删掉。"></a>远程分支有点多余，老子要删掉。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 看一眼远程有哪些分支<br>git branch -r<br><br># 删掉远程对应分支<br>git push origin --delete &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="要从远程分支-checkout-一个新分支"><a href="#要从远程分支-checkout-一个新分支" class="headerlink" title="要从远程分支 checkout 一个新分支"></a>要从远程分支 checkout 一个新分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"># 常规写法<br>git checkout -b &lt;本地分支名&gt; &lt;远程分支名&gt;<br><br>或<br><br># 简写<br>git checkout --track &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="老子忘记当前分支是基于哪个分支创建的了"><a href="#老子忘记当前分支是基于哪个分支创建的了" class="headerlink" title="老子忘记当前分支是基于哪个分支创建的了"></a>老子忘记当前分支是基于哪个分支创建的了</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reflog show &lt;分支名&gt;<br></code></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><h3 id="老子提交信息打错了，要把提交信息改一下"><a href="#老子提交信息打错了，要把提交信息改一下" class="headerlink" title="老子提交信息打错了，要把提交信息改一下"></a>老子提交信息打错了，要把提交信息改一下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># 输入命令根据提示修改提交信息<br>git commit --amend<br></code></pre></td></tr></table></figure><h3 id="老子提交之后（还未-push），发现还有东西忘记提交了"><a href="#老子提交之后（还未-push），发现还有东西忘记提交了" class="headerlink" title="老子提交之后（还未 push），发现还有东西忘记提交了"></a>老子提交之后（还未 push），发现还有东西忘记提交了</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 正常 add<br>git add &lt;忘记提交的文件路径&gt;<br><br># 把这次提交合并到最新的一次提交中<br>git commit --amend --no-edit<br></code></pre></td></tr></table></figure><h3 id="靠，点错了。这个文件不应该提交，撤回这次提交（未-push）"><a href="#靠，点错了。这个文件不应该提交，撤回这次提交（未-push）" class="headerlink" title="靠，点错了。这个文件不应该提交，撤回这次提交（未 push）"></a>靠，点错了。这个文件不应该提交，撤回这次提交（未 push）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"># 本质上是让 head 指针指向上一次提交<br>git reset --soft HEAD@&#123;1&#125;<br><br>或<br><br># 让 head 指针指向上一次的 commit <br>git reset --soft &lt;commit id&gt;<br></code></pre></td></tr></table></figure><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><h3 id="我要让当前分支恢复成最初的样子"><a href="#我要让当前分支恢复成最初的样子" class="headerlink" title="我要让当前分支恢复成最初的样子"></a>我要让当前分支恢复成最初的样子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 重置当前分支到的最近的一次提交<br>git reset HEAD --hard<br><br># 重置当前分支到的远程分支的最新一次提交<br>git reset &lt;远程分支名&gt; --hard<br></code></pre></td></tr></table></figure><h3 id="我要把文件移出暂存区"><a href="#我要把文件移出暂存区" class="headerlink" title="我要把文件移出暂存区"></a>我要把文件移出暂存区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset head --mixed <br><br>或<br><br>git reset head<br></code></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><h3 id="靠，merge-错分支了，我要恢复-merge-前的状态"><a href="#靠，merge-错分支了，我要恢复-merge-前的状态" class="headerlink" title="靠，merge 错分支了，我要恢复 merge 前的状态"></a>靠，merge 错分支了，我要恢复 merge 前的状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># ORIG_HEAD 变量保存了 merge 前的 HEAD 变量<br>git reset --hard ORIG_HEAD<br></code></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><blockquote><ul><li><strong>摘樱桃，把一次或多次 commit 应用到当前分支</strong></li></ul></blockquote><h3 id="oh-shit-最新的提交解决了一个历史-bug，其他分支代码也要修改这个-bug。"><a href="#oh-shit-最新的提交解决了一个历史-bug，其他分支代码也要修改这个-bug。" class="headerlink" title="oh shit! 最新的提交解决了一个历史 bug，其他分支代码也要修改这个 bug。"></a>oh shit! 最新的提交解决了一个历史 bug，其他分支代码也要修改这个 bug。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs git"># 应用场景：假设已修复 bug 的分支是 bug-fix，需要修改 bug 的分支是 release-1.0<br><br># 1.切换到需要修改 bug 的分支<br>git checkout release-1.0<br><br># 2.使用 cherry-pick<br>git cherry-pick &lt;bug 修复的 commit id&gt;<br><br>或<br><br>git cherry-pick bug-fix<br></code></pre></td></tr></table></figure><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><blockquote><ul><li><strong>用于撤销历史的某次更改，例如：bug 或者功能</strong></li><li><strong>回滚某次发布</strong></li></ul></blockquote><h3 id="产品加了个没卵用的功能，现在要上线，这个功能还要不要？"><a href="#产品加了个没卵用的功能，现在要上线，这个功能还要不要？" class="headerlink" title="产品加了个没卵用的功能，现在要上线，这个功能还要不要？"></a>产品加了个没卵用的功能，现在要上线，这个功能还要不要？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 不上线该功能：把该功能对应的 commit id 并 revert,之后会产生一个新 revert 提交。<br>git revert &lt;commit id&gt;<br><br># 最终还是决定要上: 只需对 revert 提交进行 revert<br>git revert &lt;revert 提交的 commit id&gt;<br></code></pre></td></tr></table></figure><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><h3 id="我要把改动文件暂存起来，不想提交这些文件"><a href="#我要把改动文件暂存起来，不想提交这些文件" class="headerlink" title="我要把改动文件暂存起来，不想提交这些文件"></a>我要把改动文件暂存起来，不想提交这些文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"># 给改动存储<br>git stash<br><br>或<br><br># 给改动取名并存储<br>git stash save &lt;自定义名称&gt;<br></code></pre></td></tr></table></figure><h3 id="忘记了-stash-中存储了哪些改动"><a href="#忘记了-stash-中存储了哪些改动" class="headerlink" title="忘记了 stash 中存储了哪些改动"></a>忘记了 stash 中存储了哪些改动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># 列举所有的 stash 信息<br>git stash list<br></code></pre></td></tr></table></figure><h3 id="我要取出改动，应用到-feature-分支"><a href="#我要取出改动，应用到-feature-分支" class="headerlink" title="我要取出改动，应用到 feature 分支"></a>我要取出改动，应用到 feature 分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs git"># 切换到 feature 分支，把改动取出应用到 feature 分支并自动删除 stash<br># 命令末尾加 &lt;stash id&gt; 应用指定的 stash <br>git stash pop<br><br>或<br><br># 把改动取出应用到 feature 分支,stash 不会删除<br># 命令末尾加 &lt;stash id&gt; 应用指定的 stash <br>git stash apply<br></code></pre></td></tr></table></figure><h3 id="老子要手动删除-stash-信息"><a href="#老子要手动删除-stash-信息" class="headerlink" title="老子要手动删除 stash 信息"></a>老子要手动删除 stash 信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 删除全部的 stash 信息<br>git stash clear<br><br># 删除指定的 stash 信息<br>git stash drop &lt;stash id&gt;<br></code></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="我去，tag-怎么用啊，老板跟我说打个-tag"><a href="#我去，tag-怎么用啊，老板跟我说打个-tag" class="headerlink" title="我去，tag 怎么用啊，老板跟我说打个 tag"></a>我去，tag 怎么用啊，老板跟我说打个 tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git"># 创建 tag<br>git tag &lt;标签名&gt;<br><br># 将创建的 tag 推到远程仓库<br>git push origin &lt;标签名&gt;<br><br></code></pre></td></tr></table></figure><h3 id="丢，手抖打错了-tag-名称，怎么删了这个-tag-啊"><a href="#丢，手抖打错了-tag-名称，怎么删了这个-tag-啊" class="headerlink" title="丢，手抖打错了 tag 名称，怎么删了这个 tag 啊"></a>丢，手抖打错了 tag 名称，怎么删了这个 tag 啊</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 删除本地 tag<br>git tag -d &lt;标签名&gt;<br><br># 删除远程仓库中的 tag<br>git push --delete origin &lt;标签名&gt;<br></code></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h3 id="嗨，忘记上次提交改了哪些文件"><a href="#嗨，忘记上次提交改了哪些文件" class="headerlink" title="嗨，忘记上次提交改了哪些文件"></a>嗨，忘记上次提交改了哪些文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git"># 查看每次提交文件<br>git log --name-only <br><br>或<br><br># 查看每次提交的文件，以及对文件进行的操作<br>git log --name-status<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 与事务</title>
    <link href="/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事务是让人生厌的八股，也是面试中的常客。网路上关于 Spring 与事务的问题非常多，然而大部分解答都是在「 背答案」，并没有把它的底层逻辑讲清楚，只要问题一经变通，也就无从下手不知所措。</p><p>Spring 使用魔法般的注解 <code>@Transactional</code> 帮我们解决事务的使用问题，给我们带来便利的同时，也屏蔽了底层的细节。屏蔽了底层的细节，也就导致事务相关的使用都是靠着积累的经验，而无法真正理解它。</p><p><strong>说明：</strong>本文仅对 Spring 中事务的原理进行说明，MySQL 中的事务实现不在本文阐述。</p><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>事务这个概念有点抽象，可以把它看做由一堆 SQL 语句组成的操作。</p><p>事务可以保证它里面的 SQL 语句要么全部成功，要么全部失败，不存在第三种中间状态。</p><p>事务还有 ACID 四种特性，陈词滥调这里不想过多阐述，可以自行 Google 了解。</p><h2 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h2><p>首先要说明的是，「 事务」更像是一种约定，数据库可以选择遵守或不遵守该约定。即便是在支持事务的数据库中，它们实现事务的方式也各不相同，MySQL 提供对事务的支持，接下来看看在 MySQL 中要如何使用事务。</p><p>在使用事务之前，需要了解事务相关的一些概念。</p><ul><li>事务（transaction）指一组 SQL 语句，对应的是整个转账流程。</li><li>回滚（rollback）指撤销指定的 SQL 语句</li><li>提交（commit）将未存储的 SQL 语句结果写入到数据库</li><li>保留点（savepoint）指事务处理中设置的临时占位符，用于事务回滚到指定的 SQL 语句。</li></ul><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>假设这样一个场景：用户注册一个账号，默认金额是 0 元，之后充值了 100 元，两个操作都在一个事务内。对应的 SQL 语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL 中标识事务开始</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>上诉操作完成了一个事务的提交，倘若要回滚上诉操作只需要将 <code>COMMIT</code> 替换成 <code>ROLLBACK</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>不知道你发现了没有，提交和回滚都是针对一组 SQL 进行的。用户注册账号成功，但是充值失败，能否让「 充值失败」不影响到用户注册。</p><p>答案是肯定的，上面提到的 <code>SAVEPOINT</code> 就是解决该问题的。</p><p><code>SAVEPOINT</code> 就像游戏存档一样，可以在事务的执行过程中建立多个存档，遇到异常可以随时返回到指定的存档。如下面的语句，「 注册」会成功，而「充值」失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">-- 创建名为 `register_user` 的保留点</span><br><span class="hljs-keyword">SAVEPOINT</span> register_user;<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 回滚到 `register_user` 保留点</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> register_user;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h2 id="传统的-JDBC-管理事务"><a href="#传统的-JDBC-管理事务" class="headerlink" title="传统的 JDBC 管理事务"></a>传统的 JDBC 管理事务</h2><h3 id="提交与回滚操作"><a href="#提交与回滚操作" class="headerlink" title="提交与回滚操作"></a>提交与回滚操作</h3><p>看下这段代码，你是否熟悉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection(); <span class="hljs-comment">// (1)</span><br><br><span class="hljs-keyword">try</span> (connection) &#123;<br>    connection.setAutoCommit(<span class="hljs-literal">false</span>); <span class="hljs-comment">// (2)</span><br>    <span class="hljs-comment">// 执行一些 SQL 代码</span><br>    connection.commit(); <span class="hljs-comment">// (3)</span><br><br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    connection.rollback(); <span class="hljs-comment">// (4)</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取数据库连接，获取的方式有多种，现在大多数都是维护一个数据库连接池，然后从连接池分配一个连接。</li><li>把获取到的数据库连接，关闭自动提交。因为事务要交由代码管理，而不是让数据库默认提交。</li><li>当执行完 SQL 代码之后，开始提交。</li><li>数据库进行 COMMIT 提交出现异常，代码中进行捕获，并执行回滚操作。</li></ol><h3 id="设置隔离级别与保留点（SAVEPOINT）"><a href="#设置隔离级别与保留点（SAVEPOINT）" class="headerlink" title="设置隔离级别与保留点（SAVEPOINT）"></a>设置隔离级别与保留点（SAVEPOINT）</h3><p>在  jdbc 中设置数据库隔离级别和 <code>SAVEPOINT</code> 也是非常简单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">Savepoint</span> <span class="hljs-keyword">savePoint</span> <span class="hljs-operator">=</span> connection.setSavepoint(); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">2</span>)<br><br>connection.rollback(<span class="hljs-keyword">savePoint</span>);  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><ol><li><code>setTransactionIsolation</code> api 就可以设置数据库的隔离级别</li><li><code>setSavepoint</code> 创建一个 <code>SAVEPOINT</code></li><li><code>rollback</code> 到上一个 <code>SAVEPOINT</code></li></ol><p>可以看到 jdbc 中对数据库事务的操作都是非常简单的，Spring 与 jdbc 实现事务的操作并无太大差别，只是他把这些封装的太好，会让你觉得是魔法，难以理解。</p><h2 id="Spring-的事务魔法"><a href="#Spring-的事务魔法" class="headerlink" title="Spring 的事务魔法"></a>Spring 的事务魔法</h2><h3 id="Transactional-注解"><a href="#Transactional-注解" class="headerlink" title="Transactional 注解"></a>Transactional 注解</h3><p>使用 JDBC 开启事务，需要写大量的 <code>try...catch</code> 。通常 <code>try</code> 代码块执行 SQL 操作，<code>catch</code> 中捕获异常进行回滚。</p><p>来看下 Spring 中为一个方法添加事务有多简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        userDao.save(user);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>加上 <code>@Transactional</code> 注解等价代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            userDao.save(user);<br><br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个操作，相比上面的 JDBC 操作，简便不少。操控事务的样板代码，不用在每个方法中写了，一个注解 Spring 统统搞定。</p><p>因此，Spring 的事务魔法秘密就揭开了。对加了 <code>@Transactional</code>的方法或者类，使用 AOP 的方式，帮你生成数据库的链接，事务开启、提交、回滚代码，仅此而已。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在深入 <code>@Transcational</code> 注解之前，还是要先简单介绍下 AOP 在事务上的实现，这对你理解后面的问题，大有裨益。</p><p>首先要清楚 AOP 在实现事务时，并不会改变原来类的行为，它只是生成了一个代理类。生成代理类的方式有 CGLIB、JDK 动态代理，两种代理方式各不相同，但这里不对代理方式阐述。</p><p>通过一个简单的 Demo 看下这个流程：</p><p>在 <code>UserService</code> 的 <code>registerUser</code> 方法开启事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 注册用户代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 使用 AOP 为 <code>UserService</code> 生成代理类 <code>UserServiceProxy</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 调用 UserService 的 registerUser 方法</span><br>            invoke();<br>           <br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>UserController</code> 中注入 <code>UserService</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/register&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span>&#123;<br>userService.registerUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>/register</code> 请求的流程如下：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/01acb810-c014-487d-9a72-7a6111fd0920.png" alt="aop.png"></p><p>可以看到，<code>Controller</code>  实际上是调用 <code>UserServiceProxy</code> 的 <code>registerUser</code> 方法，然后在代理方法中操控事务，并调用真正的 <code>UserService</code> 的 <code>registerUser</code>。</p><p>或许你还有个疑问：注入的是 <code>UserService</code> ，为什么调用的却是它的代理类？</p><p>这就涉及 Spring  的依赖注入原理，详细可以自行搜索。实际上在 <code>UserController</code> 中注入的是 <code>UserServiceProxy</code> ，而非看到的 <code>UserService</code>。</p><h3 id="一些疑难杂症"><a href="#一些疑难杂症" class="headerlink" title="一些疑难杂症"></a>一些疑难杂症</h3><p>列举一些关于 Spring 事务的疑难杂症，也是面试的常考题。</p><h4 id="为什么-private-方法加-Transactional-注解不生效"><a href="#为什么-private-方法加-Transactional-注解不生效" class="headerlink" title="为什么 private 方法加 @Transactional 注解不生效?"></a>为什么 <code>private</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>这个问题其实是和 AOP 相关的，因为 AOP 无法对 <code>private</code> 方法生成代理。无法代理也就意味着对 <code>priavte</code> 方法的调用，都是直接调用被代理的类。</p><h4 id="为什么-final-方法加-Transactional-注解不生效"><a href="#为什么-final-方法加-Transactional-注解不生效" class="headerlink" title="为什么 final 方法加 @Transactional 注解不生效?"></a>为什么 <code>final</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>原理同上，还是 AOP 无法代理被 <code>final</code> 关键字修饰的方法和类</p><h4 id="为什么类方法相互调用事务不生效？"><a href="#为什么类方法相互调用事务不生效？" class="headerlink" title="为什么类方法相互调用事务不生效？"></a>为什么类方法相互调用事务不生效？</h4><p>事务方法 <code>a</code>调用同类的事务方法 <code>b</code> ，在外部调用 <code>a</code> 方法，<code>b</code> 方法的事务不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个只需要分析下调用过程就清楚了：</p><ol><li>先调用代理类中的 <code>a</code> 方法，然后代理类中调用真正的 <code>a</code> 方法。</li><li><code>UserService</code> 的 <code>a</code> 方法执行过程中，发现要调用 <code>b</code> 方法，因此调用了自己的 <code>b</code> 方法。</li></ol><p>可以看到，<code>a</code> 调用 <code>b</code> 的时候，并没有先经过代理类，而是直接在 <code>UserService</code> 中执行了，所以 <code>b</code> 的事务不会生效。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/9559d6ef-b67e-49b3-b2a3-6ed40d97aa6d.png" alt="question_1.png"></p><h4 id="为什么注入自己就能解决相互调用问题？"><a href="#为什么注入自己就能解决相互调用问题？" class="headerlink" title="为什么注入自己就能解决相互调用问题？"></a>为什么注入自己就能解决相互调用问题？</h4><p>同样是上面的代码，只需要在 <code>UserService</code> 中注入自己，<code>b</code> 的事务就生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Autowird</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        userService.b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面说的依赖注入吗，这里注入自己，实际上注入的是 <code>UserService</code> 的代理类。因此在执行 <code>userService.b()</code> 这段代码时，会调用代理类的 <code>b</code> 方法，所以 <code>b</code> 的事务生效。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/4f01d7cf-3c53-4e24-ae76-69b835d7d61b.png" alt="question_2.png"></p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的 GC</title>
    <link href="/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/"/>
    <url>/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/</url>
    
    <content type="html"><![CDATA[<p>人在日常活动中不可避免会产生垃圾，程序也是如此。在方法中 new 一个对象，每次调用该方法都会进行 new 对象操作，如果没有人去管理这些对象，没有把这些对象占有内存及时释放掉，内存很快就会满。因此，在程序运行过程中，需要及时寻找和处理「 死去」的对象。这个「 死去」的对象就是<strong>垃圾</strong>，而寻找和处理垃圾的过程就叫做 <strong>GC</strong>。</p><p>GC 全称 “Garbage Collection” 即垃圾收集。不同的语言对于 GC 的处理都是不一样的，因此也产生了不同的「流派」。</p><p><strong>需要说明的是</strong>：本文介绍的 GC 都是基于 HotSpot。</p><h2 id="垃圾管理流派"><a href="#垃圾管理流派" class="headerlink" title="垃圾管理流派"></a>垃圾管理流派</h2><p>根据内存的管理方式，划分出两个流派：手动管理和自动管理。</p><p>手动管理的代表就是：C ++ 和 C。它们需要在编码过程中，手动去释放内存。</p><ul><li>优点：能明确垃圾的产生，以及提高回收的效率。 </li><li>缺点：垃圾太多，在代码中手动清理内存很「痛苦」，很容易忘记释放内存，导致内存泄露。由于需要明确垃圾的产生位置，因此也需要对该语言非常熟悉，这也无形中加大了语言的上手难度。</li></ul><p>自动管理的代表：Java (当然还有很多其他语言，篇幅有限，暂不阐述)。</p><ul><li>优点：使用者无需关心内存的使用，只需专注功能和业务的实现。内存的处理和回收有个智能的程序替我们完成。</li><li>缺点：屏蔽了底层细节，出现了内存问题，使用者无法着手解决。当然解决办法也很简单，就是去了解 GC 原理。</li></ul><h2 id="寻找垃圾"><a href="#寻找垃圾" class="headerlink" title="寻找垃圾"></a>寻找垃圾</h2><p>现在我们知道 Java 是自动 GC，那现在问题来了：它是怎么去找到垃圾？怎么保证找的对象就一定是垃圾呢？</p><p>在「 找垃圾」这块，也有两种方式：引用计数和可达性分析。虽然有两种方式，但主流的 Java 虚拟机里面都没有选用引用计数。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>如图所示，小圆圈代表对象，箭头代表引用关系，数字代表对象被引用的次数。可以看到蓝色的对象都是处于「 活跃」状态的，而灰色的对象要么没有被引用，要么引用它的对象没有被引用，这些对象就是程序需要回收的垃圾。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%AD%E7%9A%84GC/2069ac04-c401-4330-bb40-6fda0dea5fcb.png" alt="GC-in-Java-01.PNG"></p><p>这一切看似完美无缺，实则存在一个巨大问题：对象间的循环引用。</p><p>仔细看上面这张图，红色的对象相互循环引用，程序并没有使用到，理应当作垃圾处理。但是，在引用计数方法看来这是个「 活跃」的对象，因此并不会进行处理。</p><p>在一些文章上有谈论到解决该问题的方法，例如：循环引用的对象使用 <code>弱引用</code>，使用单独的算法等，详情可以自行搜索。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>Java 就是通过<code>可达性分析</code>算法来进行内存管理的。</p><p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，即通过 GC Roots 访问不到该对象时，则证明此对象是垃圾。</p><p>用比较生活化的例子来解释：家是内存，家庭成员是 GC Roots，物品是对象，家庭大扫除就是可达性分析。家庭大扫除的结果就是把家庭成员都用不到的东西归为垃圾，并把它清除掉。</p><p>如图所示：灰色的对象就是 GC Roots 访问不到的对象，这些对象就是垃圾。图中也可以看到对象循环引用的问题的，在这里也已经不复存在，都会被当做垃圾。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%AD%E7%9A%84GC/09db1a69-e11e-4a4b-9bdd-43946cb355a5.png" alt="GC-in-Java-02.PNG"></p><p>大扫除的例子，我们知道「 家庭成员」是 GC Roots，在 Java 技术体系中常见的 GC Roots 包括以下几种：</p><ul><li>线程</li><li>native 方法</li><li>栈帧中的局部变量表</li><li>Class 引用的 static field</li><li>所有被同步锁（synchronized关键字）持有的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过上面两种方法来看，似乎对象在内存中的状态只有「 被引用」和「 未被引用」两种状态，GC 把「 未被引用」 的对象收集。</p><p>在在内存空间充足时，可能并不希望「 未被引用」的对象被清除，只有当内存紧张时，才把那些对象抛弃。</p><p>在 Java 中对引用的概念进行扩充，将引用分为：</p><ul><li>强引用（Strongly Re-ference） <ul><li>在 Java 程序代码中普遍存在的就是<code>强引用</code>，比如你 new 一个对象。</li></ul></li><li>软引用（Soft Reference） <ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li></ul></li><li>弱引用（Weak Reference） <ul><li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li></ul></li><li>虚引用（Phantom Reference） <ul><li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。类似于 Linux 中的 <a href="https://zh.wikipedia.org/wiki/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">退出状态</a>。</li></ul></li></ul><p>这4种引用强度依次逐渐减弱。</p><h2 id="垃圾自我救赎"><a href="#垃圾自我救赎" class="headerlink" title="垃圾自我救赎"></a>垃圾自我救赎</h2><p>使用可达性分析找到「未被引用」的对象并不会立即将内存释放，而是给这些对象进行<code>标记</code> ，当对象被<strong>标记两次</strong>后才会进行回收。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%AD%E7%9A%84GC/8939c679-8d1a-4d66-8bd4-910e8e25d6bd.png" alt="image.png"></p><p>当对象第一次标记之后，随后会进行一次筛选，筛选的依据是：<strong>对象是否有必要执行 finalize() 方法？</strong></p><p>假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>「没有必要执行」</strong>。</p><p>对象被判定为「没有必要执行」，则直接进行回收。否则，会把对象放入到一个名为 <code>F-Queue</code> 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。流程如下：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%AD%E7%9A%84GC/f74a1943-9e8f-440b-b097-b3eb7995cd64.png" alt="image.png"></p><p>对象的 finalize() 方法执行，GC 对 <code>F-Queue</code> 中的对象进行第二次标记。如果 finalize() 方法执行之后，对象重新回到了 GC Roots 的引用链上，则把它移出队列。否则，被 GC 回收。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%AD%E7%9A%84GC/41e3ebdc-ac30-40a3-9783-9bdd08b958f7.png" alt="image.png"></p><p>这个时候你可能就有问题了：那我在对象的 finalize() 方法中，编写代码使得当前对象重新回到 GC Roots 引用链上，这个对象岂不是永远不会被 GC 回收？</p><p>答案是会被回收。可以看到「没有必要执行」的条件中有一条是： <strong>finalize() 方法已经被虚拟机调用过</strong>。因此对象虽然能回到引用链上，但是下一次 GC 它一定会被回收。<strong>总结就是：一个对象只能被救赎一次。</strong></p><p>其实关于  finalize() 方法，很多人也不了解，只需要知道它会于 GC 过程产生联系即可。在 《Effective Java》第三版 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md">Item 8</a> ，以及《深入理解 Java 虚拟机》第三版中，作者都不建议在代码中使用 finalize，甚至让我们忘记这个 API。</p><p>因此，使用  finalize() 方法的最佳实践就是：从不使用它。</p><blockquote><p>文章参考《深入理解 Java 虚拟机》第三版、《Effective Java》第三版、《Plumbr Handbook Java Garbage Collcetion》。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例实现的几种方式</title>
    <link href="/2022/06/24/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/06/24/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是单例"><a href="#什么是单例" class="headerlink" title="什么是单例"></a>什么是单例</h2><p>单例是一个只实例化一次的类，即类仅存在一个对象。</p><h2 id="私有化构造器-静态成员变量"><a href="#私有化构造器-静态成员变量" class="headerlink" title="私有化构造器 + 静态成员变量"></a>私有化构造器 + 静态成员变量</h2><p>显示声明构造器，并使用 <code>private</code> 关键字将其私有化，避免使用 <code>new Object</code> 来创建对象。需要使用该实例，只需要通过成员变量 INSTANCE 访问即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：会被 AccessibleObject.setAccessible 方法利用反射调用私有构造函数，实例化新的对象。</p><h2 id="私有化构造器-静态工厂方法"><a href="#私有化构造器-静态工厂方法" class="headerlink" title="私有化构造器 + 静态工厂方法"></a>私有化构造器 + 静态工厂方法</h2><p>该单例实现方法与上面基本一致，只需要将成员变量私有化，添加工厂方法来访问该成员变量即可。获取实例只需要调用 <code>getInstance</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：同上。</p><p><strong>实现序列化需要注意的问题</strong></p><p>使用上述两种方法实现单例，且需要实现可序列化时，仅仅是实现 Serializable 接口是不够的，要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md">Item-89</a>）。</p><p>否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 MySingleton。为了防止这种情况发生，将这个 readResolve 方法添加到 MySingleton 类中。</p><p>详细的解决方法可以查看《Effective Java》第三版 Item 89。</p><h2 id="单元素枚举"><a href="#单元素枚举" class="headerlink" title="单元素枚举"></a>单元素枚举</h2><p>优点：默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MySingleton</span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：当类需要扩展超类时，enum 便不在适合。</p><h2 id="延迟加载单例（双重检查不成立？）"><a href="#延迟加载单例（双重检查不成立？）" class="headerlink" title="延迟加载单例（双重检查不成立？）"></a>延迟加载单例（双重检查不成立？）</h2><p>延迟加载即只有第一次调用时，才进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当程序第一次调用 <code>getInstance</code> 方法时，MySingleton 实例才被初始化。</p><p>该延迟加载在多线程情况下，可能会创建多个实例，因此需要对 <code>getInstance</code> 方法进行加锁处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>          INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> INSTANCE;<br>  &#125;<br></code></pre></td></tr></table></figure><p>加锁的意图在于第一次初始化的时候，保证只有一条线程进入到 if 语句中，生成实例。直接在方法上加锁，会导致性能下降。因为每次去取该实例都要去获得锁，所以需要对该方式进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">synchronized</span> (MySingleton.class)&#123;<br>               <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                   INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> INSTANCE;<br>   &#125;<br></code></pre></td></tr></table></figure><p>该方法称作 <code>双重检查</code> ，保证了多线程环境下，只生成一个实例，且后续对该实例的调用都不会进行加锁处理。</p><p><strong>由于类加载以及对象初始化的特殊性值，会导致该双重检查不成立，可以使用 volatile 关键字声明变量，防止指令重排，实现最终目的。想了解该问题具体产生的原因，可以</strong><a href="writing"><strong>查看</strong></a><strong>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (MySingleton.class)&#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一份来自 Java 巨佬关于 <code>双重检查</code>的阐述，点击<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">这里</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>单例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins 自动化部署</title>
    <link href="/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>简介：Java 编写的最广泛使用的开源持续集成工具，非常易用，广泛的第三方插件支持，以及分布式构建。</p><p>文章所演示的项目地址：</p><p>GitHub: <a href="https://github.com/greek-zzf/oh-my-jenkins.git">https://github.com/greek-zzf/oh-my-jenkins.git</a><br>Gitee: <a href="https://gitee.com/geek-zzf/oh-my-jenkins.git">https://gitee.com/geek-zzf/oh-my-jenkins.git</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="War-包方式"><a href="#War-包方式" class="headerlink" title="War 包方式"></a>War 包方式</h3><p>优点：安装启动非常方便。</p><p>缺点：与环境强绑定，服务器要为 Jenkins 提供部署项目所需要的环境，例如：Node、Java 等。 部署成服务需要使用对应平台的命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到安装方式，下载 War 包。或者直接点击<a href="https://www.jenkins.io/download/">这里</a>下载。 </p></li><li><p>下载完成运行命令 <code>java -jar jenkins.war</code> ，等待几分钟。 </p></li><li><p>在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>优点：与宿主机环境隔离，不依赖宿主机环境。注册成服务非常方便，只需要启动时设置好参数 <code>--restart=always</code> 即可。</p><p>缺点：启动稍微复杂，需要配置好启动命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到 Docker 安装方式。或者直接点击<a href="https://www.jenkins.io/doc/book/installing/docker/">这里</a>访问。 </p></li><li><p>运行 Docker 命令如下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">step1: docker network create jenkins<br><br>step2: docker run --name jenkins-docker --rm --detach \<br>  --privileged --network jenkins --network-alias docker \<br>  --env DOCKER_TLS_CERTDIR=/certs \<br>  --volume jenkins-docker-certs:/certs/client \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --publish 2376:2376 \ <br>  docker:dind --storage-driver overlay2   --insecure-registry 47.107.74.10:5000 <br> <br><br>step3: 创建 Dockerfile 文件，并把如下内容复制进去<br><br>    FROM jenkins/jenkins:2.332.2-jdk11<br>    USER root<br>    RUN apt-get update &amp;&amp; apt-get install -y lsb-release<br>    RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \<br>      https://download.docker.com/linux/debian/gpg<br>    RUN echo &quot;deb [arch=$(dpkg --print-architecture) \<br>      signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \<br>      https://download.docker.com/linux/debian \<br>      $(lsb_release -cs) stable&quot; &gt; /etc/apt/sources.list.d/docker.list<br>    RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli<br>    USER jenkins<br>    RUN jenkins-plugin-cli --plugins &quot;blueocean:1.25.3 docker-workflow:1.28&quot;<br><br>step4: docker build -t myjenkins-blueocean:2.332.2-1 .<br><br>step5: docker run --name jenkins-blueocean --rm --detach \<br>  --network jenkins --env DOCKER_HOST=tcp://docker:2376 \<br>  --env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \<br>  --publish 8080:8080 --publish 50000:50000 \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --volume jenkins-docker-certs:/certs/client:ro \<br>  myjenkins-blueocean:2.332.2-1<br></code></pre></td></tr></table></figure></li><li><p>等待一会，在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><p><strong>注意</strong>：步骤4构建失败，可能是由于 Docker 权限问题，解决方案可参考<a href="https://github.com/docker/buildx/issues/476">这里</a>。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>解锁 Jenkins：浏览器中提示输入管理员密码。War 在启动的控制台中会打印密码，或者页面提示的文件中。Docker 方式使用命令，查看容器日志信息即可看到 <code>docker logs jenkins-blueocean</code>。 </p></li><li><p>插件下载镜像设置：为了部署和运行项目，需要安装一些插件。首先需要给插件站点设置一个镜像，不然访问速度感人。配置路径 “Manager Jenkins -&gt; Manager Plugins -&gt; Advanced”，在底部的 <code>Update Site</code> 中把地址进行替换。这里提供一个国内可访问的镜像地址：<a href="https://updates.jenkins-zh.cn/update-center.json%E3%80%82">https://updates.jenkins-zh.cn/update-center.json。</a></p></li><li><p>设置好插件镜像源之后，去搜索对应的插件，下载安装即可。 </p></li><li><p>下载并安装插件：由于项目是用 Git 来管理的，并且使用的是 Maven，因此需要下载这两个插件。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建 Job 之前，需要先了解一个 Job 任务涉及到哪些流程。Jenkins 给我们提供了以下几个模块：</p><ul><li><p><code>General</code> Job 描述，可选。 </p></li><li><p><code>Source Code Management</code> 源代码管理，有多个版本工具选择：Git、Svn 等。 </p></li><li><p><code>Build Triggers</code> 构建触发器，选择构建代码的时机 </p><ul><li>Trigger builds remotely，手动去触发。</li><li>Build after other project are built，在其他项目构建完成后触发。</li><li>Build periodically，周期的进行构建</li><li>GitHub Hooks，当有代码更新到 GitHub，GitHub 会触发一个 Hooks，并通知 Jenkins 服务开始构建，这个需要在 GitHub 中配置推送地址信息。</li><li>Poll SCM 定时任务轮询，填写 Cron 表达式指定轮询的时机。例如：每 10 分钟去检查 GitHub 仓库是否有代码更新。</li></ul></li><li><p><code>Build Environment</code>构建环境，配置项目构建的环境，可以在构建的时候传递环境变量信息。 </p></li><li><p><code>Build</code> 可以选择构建所需步骤。 </p></li><li><p><code>Post-build Actions</code>可以指定项目完成构建之后的行为。</p></li></ul><h2 id="手动创建-Job"><a href="#手动创建-Job" class="headerlink" title="手动创建 Job"></a>手动创建 Job</h2><p>在 Jenkins 中添加两个任务，一个用于拉取代码运行测试、打包任务，另一个可以手动选择版本的部署任务。</p><h3 id="创建测试打包任务"><a href="#创建测试打包任务" class="headerlink" title="创建测试打包任务"></a>创建测试打包任务</h3><ol><li>填写创建的 Job 信息</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/24e982a6-9b83-4233-99f0-15c083663bb5.png" alt="image.png"></p><ol start="2"><li>选择 Git 作为代码管理工具，配置对应的仓库地址。如果是私密仓库，需要填写对应的账号密码。这里使用了 ssh 方式，并提前配置好了私钥信息。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/0c9f33b3-b50e-45dd-b984-8fdd5c4a1ea9.png" alt="image.png"></p><ol start="3"><li>选择一个构建方式，这里我们选择 SCM，填写一个每 10 分钟轮询一次的 corn 表达式。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/415593ca-72bb-4786-a3c5-14271c5d15ac.png" alt="image.png"></p><ol start="4"><li>构建的时候选择 <code>Execute shell</code> 并在文本框中填写要执行的脚本信息，这里我们填写 <code>mvn clean package</code>，该命令会执行清理、测试、打包操作，在 target 目录下生成 jar 包。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3fea80cf-d62d-4d27-a028-4bae6b70c59a.png" alt="image.png"></p><ol start="5"><li>保存任务，回到页面。等待 10 分钟或者手动点击立即构建，即可开始构建。 控制台最终打印了文件夹下所有项目版本信息。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b452178d-9bdd-4873-98f7-663fd62ef8bf.png" alt="image.png"></p><h3 id="创建部署任务"><a href="#创建部署任务" class="headerlink" title="创建部署任务"></a>创建部署任务</h3><ol><li>创建 deploy 任务，在页面中填写描述，并勾选 <code>This project is parameterized</code>，选择 String 参数，这里定义一个变量 version。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f0e1221-1b21-4ac1-a991-19753f4085ca.png" alt="image.png"></p><ol start="2"><li>由于部署任务和打包任务是分开，此处无需在使用 Git 去拉取代码，也无需定义构建触发器，直接手动构建即可。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/8489f466-cf27-4f07-b07a-304f8b42769b.png" alt="image.png"></p><ol start="3"><li>build 环节还是去执行一个 shell，这里我们配置一个 java 程序启动命令 <code>java -Dserver.port=5000 -jar  /c/Users/Administrator/Desktop/jenkins/$&#123;version&#125;.jar</code>指定 5000 端口，并且根据输入的版本号，去执行对应的 jar 包。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f823c65-51d5-4936-b226-d635fc86e3c3.png" alt="image.png"></p><ol start="4"><li>根据上个任务构建的输出，我们执行部署任务的构建。Jenkins 会弹出提示，此时输入对应的项目版本号，点击开始构建，等待构建完成项目就启动成功了。</li></ol><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b651a7f8-0267-42c9-861b-4ea128b5f596.png" alt="image.png"></p><h2 id="使用-Jenkinsfile-创建-Job"><a href="#使用-Jenkinsfile-创建-Job" class="headerlink" title="使用 Jenkinsfile 创建 Job"></a>使用 Jenkinsfile 创建 Job</h2><p>图形化页面创建一个 Job 很方便，但是当 Jenkins 需要为多个项目创建 Job 时，一个一个手动创建就会很繁琐，并且 Job 信息也没办法进行版本管理。</p><p>Jenkinsfile 就是来解决这个问题的，他将 Job 的配置信息用脚本语言来表示，这样只需要维护这个脚本即可。Jenkinsfile 就像是一份说明书，指导 Jenkins 的工作，让他自动帮我们完成配置。编写 Jenkinsfile 的脚本语言是 Groovy，推荐学习。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>整个流程如图：<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/70124ec6-6334-457c-9f47-4341127d490c.png" alt="image.png"></p><p><strong>创建流程</strong>：</p><ul><li><p>为项目编写 Dockerfile。</p></li><li><p>创建 Jenkinsfile。</p></li><li><p>使用 pipleline 语法编写脚本：使用 Dockerfile 文件 build 一个镜像，并上传到 Docker 私服。</p></li><li><p>使用一个新的 Job，用来获取 Docker 私服所有项目版本信息，支持选择对应版本部署。</p></li></ul><h3 id="为项目编写-Dockerfile"><a href="#为项目编写-Dockerfile" class="headerlink" title="为项目编写 Dockerfile"></a>为项目编写 Dockerfile</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">FROM <span class="hljs-attr">java:</span>openjdk<span class="hljs-number">-8</span>u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target<span class="hljs-regexp">/oh-my-jenkins-0.0.1-SNAPSHOT.jar /</span>app<br><br>EXPOSE <span class="hljs-number">8080</span><br><br>CMD [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;oh-my-jenkins-0.0.1-SNAPSHOT.jar&quot;</span> ]<br></code></pre></td></tr></table></figure><h3 id="在-master-分支创建-Jenkinsfile-并编写对应的脚本"><a href="#在-master-分支创建-Jenkinsfile-并编写对应的脚本" class="headerlink" title="在 master 分支创建 Jenkinsfile 并编写对应的脚本"></a>在 master 分支创建 Jenkinsfile 并编写对应的脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>     agent any<br>     triggers &#123;<br>          pollSCM(<span class="hljs-string">&#x27;* * * * *&#x27;</span>)<br>     &#125;<br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            agent &#123; docker &#123;<br>                image <span class="hljs-string">&quot;circleci/openjdk:8u212-jdk-stretch&quot;</span><br>                args <span class="hljs-string">&#x27;-v /usr/local/docker-cache:/root/.m2&#x27;</span><br>                            &#125;<br>                 &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&#x27;mvn clean package&#x27;</span><br>                stash <span class="hljs-attr">includes:</span> <span class="hljs-string">&#x27;**/target/*.jar&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;app&#x27;</span><br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Docker Build&#x27;</span>) &#123;<br>           steps &#123;<br>               echo <span class="hljs-string">&#x27;Starting to build docker image&#x27;</span><br><br>                unstash <span class="hljs-string">&#x27;app&#x27;</span><br>                script &#123;<br>                    <span class="hljs-keyword">def</span> customImage = docker.build(<span class="hljs-string">&quot;172.29.145.109:5000/on-my-jenkins:$&#123;new Date().format(&#x27;yyyy-MM-dd-HH-mm-ss&#x27;)&#125;&quot;</span>)<br>                    customImage.push()<br>                &#125;<br>           &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本定义了轮询任务，在 docker 中使用 java 环境运行 <code>mvn clean package</code>打包，并把它暂存。之后使用一个 docker build 构建镜像并推送到 docker 私服。由于私服地址和 Jenkins 都在同一个服务器，因此直接使用内网 ip。</p><h3 id="在-deploy-分支创建-Jenkinsfile-并编写部署脚本"><a href="#在-deploy-分支创建-Jenkinsfile-并编写部署脚本" class="headerlink" title="在 deploy 分支创建 Jenkinsfile  并编写部署脚本"></a>在 deploy 分支创建 Jenkinsfile  并编写部署脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> responseJson = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://172.29.145.109:5000/v2/oh-my-jenkins/tags/list&quot;</span>)<br>        .getText(<span class="hljs-attr">requestProperties:</span> [<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&quot;application/json&quot;</span>]);<br><br>println(responseJson)<br><br>Map response = <span class="hljs-keyword">new</span> groovy.json.JsonSlurperClassic().parseText(responseJson) <span class="hljs-keyword">as</span> Map;<br><br><span class="hljs-keyword">def</span> versionsStr = response.tags.join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>pipeline &#123;<br>     agent any<br><br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            input &#123;<br>                message <span class="hljs-string">&quot;Choose a version&quot;</span><br>                ok <span class="hljs-string">&quot;Deploy&quot;</span><br>                parameters &#123;<br>                    choice(<span class="hljs-attr">choices:</span> versionsStr, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;version&#x27;</span>)<br>                &#125;<br>            &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker rm -f oh-my-jenkins&#x27; || true&quot;</span><br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker run --name oh-my-jenkins -p 8081:8080 -d 172.29.145.109:5000/oh-my-jenkins:$&#123;version&#125;&#x27;&quot;</span><br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本获取 Docker 私服的<code>oh-my-jenkins</code>镜像，部署我们选择的版本。</p><h3 id="在-Jenkins-创建多分支流水线任务"><a href="#在-Jenkins-创建多分支流水线任务" class="headerlink" title="在 Jenkins 创建多分支流水线任务"></a>在 Jenkins 创建多分支流水线任务</h3><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b439354a-e1a4-47f4-9bf4-06975e7d8c98.png" alt="image.png"></p><p>然后只需要配置仓库地址就好了，由于 GitHub 抽风，所以使用 Gitee 仓库地址。<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/4047e5a2-911f-4a91-9380-55c45988a209.png" alt="image.png"><br>创建完流水线任务，他会自动扫描仓库上的所有分支，并读取 Jenkinsfile 文件，执行命令。</p><h3 id="选择版本部署"><a href="#选择版本部署" class="headerlink" title="选择版本部署"></a>选择版本部署</h3><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3368c931-7653-4f8a-bc9e-df43d04ee7fc.png" alt="image.png"><br>当流水线分支创建完成之后，deploy 分支会等待我们选择版本，选择需要部署的版本，deploy 即可完成部署。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/2022/04/28/interview/"/>
    <url>/2022/04/28/interview/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><ul><li>为什么需要装插箱？ <ul><li>为了兼容集合类，由于 List 不放便，因此使用装箱类型表示他的集合 List</li></ul></li><li>Method.invoke(obj,args) &#x2F; Method.invoke(null,args) static &#x2F; non-static 字段同理。 </li><li>异常中 finally 中的字节码实现，是将 Finally 块中的代码分别复制到 try 和 catch 末尾的。</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>基本的 IO 模型：阻塞、基于流的。</li><li>基本的 IO 模型：由于是阻塞的，因此被迫有多个线程才能同时处理多个 IO 事件、有多个线程就会产生竞争条件（锁、同步、CAS）</li><li>为什么需要 NIO：线程、上下文切换及其昂贵、IO 多路复用。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li>栈内存分配？何时分配？ <ul><li>当代码中创建了「无人引用」的对象时，编译器在编译过程会将代码优化，当方法栈被调用时该对象在栈上进行分配，简轻 GC 的负担。</li></ul></li><li>方法区常量池 <ul><li>Class 对象，Java 7 永久代、Java 8 元空间。</li></ul></li><li>字节码转换：编译器前端后端 <ul><li>java -&gt; 抽象语法树 -&gt; class （编译器前端）</li></ul></li><li>字节码指令（参照 Java 虚拟机规范） <ul><li>INVOKESPECIAL：调用特殊的方法：construct、private、super、static 方法</li><li>INVOKEVIRTUAL：方法调用</li><li>PUTFIELD：对象写值，例如：user.name &#x3D; “xxx”；</li></ul></li><li>Java 8 的三层类加载体系： <ul><li>Bootstrap (JVM 核心类) &#x2F; Ext(扩展类加载器) &#x2F; App (应用类加载器)</li></ul></li><li>常用 JVM 命令与问题排查 <ul><li>jps：列举 jvm 进程信息。jstack：线程调用栈信息。jmap：dump 堆内存信息。</li></ul></li><li>Java 的引用链 <ul><li>日常使用的都是「强引用」，弱引用、虚引用、影子引用</li></ul></li><li>什么是垃圾？ <ul><li>可达性分析，沿着 GC root 能访问到的都是非垃圾、其他都是垃圾</li></ul></li><li>GC root 有哪些？ <ul><li>线程、native 方法、栈帧中的局部变量表、Class 引用的 static field</li></ul></li><li>什么是 safepoint？ <ul><li>所有线程停止的地方（安全点）</li></ul></li><li>GC  过程 <ul><li>等待 safepoint （干活的人都停下来）</li><li>引用分析 (找到垃圾)</li><li>Finalize 队列 （把垃圾放到队列，最终判断是否要回收）</li><li>分代垃圾回收 （回收垃圾）</li></ul></li><li>分代垃圾回收 <ul><li>年轻代：Survivor0 &#x2F; Survivor1 &#x2F; Eden</li><li>GC 次数多了，提升到老年代。</li><li>永久代 &#x2F; 元空间</li></ul></li><li>不同的垃圾回收算法 <ul><li>老年代&#x2F;年轻代（串行、并行算法），年轻代：压缩拷贝 老年代：压缩整理</li><li>之前的 GC 需要一个 STW 过程，因此为了降低 STW 的时间使用了 CMS，又由于与之前的串行并行不兼容，因此单独使用了一个 ParNew</li><li>当前算法：G1。 未来算法：Shenandoad &#x2F; ZGC</li></ul></li><li>GC 调优：参考网上文档，看看过程。</li><li>GC 问题：OOM、CPU 100% ( cpu 一值在执行，死循环 )</li></ul><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><ul><li>Thread &#x2F; Runnable &#x2F; Callable 关系 <ul><li>Thread 是真正的线程，对应内核中的线程。Runable 无法返回，且不抛出 checked 异常。Callable 只能交由线程池运行。</li></ul></li><li>Thread 声明周期： <ul><li>new: 线程创建</li><li>runnable: 分配了任务</li><li>terminated: run 方法执行完。</li><li>blocked: 线程阻塞、等待获取锁</li><li>waiting:  等待、等待被唤醒</li><li>time waiting: 超时等待。</li></ul></li><li>ThreadLocal 实现原理： <ul><li>具体的数据并非保存在 ThreadLocal，而是保存在线程里面。好处就是：线程结束或者销毁，他所持有的数据也会被销毁。</li></ul></li><li>InterruptedException 异常，当 wait、sleep 等方法运行抛出。用于线程任务的中断。</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>synchronized 锁住的是什么? <ul><li>锁住的永远都是对象，有普通对象实例，Class 对象，this</li></ul></li><li>synchronized 底层实现 <ul><li>方法：modifiers - sync  有对应的标志位</li><li>代码块：进入的时候有 MONITORENTER &#x2F; MONITOREXIT 两条字节码指令。</li></ul></li><li>锁升级（膨胀）、锁消除、锁粗化、自旋锁（八股先不急）</li><li>volatile 是什么？ <ul><li>关键字，保证了共享变量对其他线程的可见性，任何一个线程写入之后，其他线程应该都可见。</li><li>实现：JVM 立刻把共享变量刷新到主内存，其他线程都从主内存读即可。</li></ul></li><li>指令重排序 <ul><li>编译器发现同一线程的指令执行互不干扰，于是与不同的顺序方式去执行。</li></ul></li><li>为什么有同步的时候不需要 volatile ?（有规定） <ul><li>synchronized &#x2F; Lock &#x2F; AtomicX</li></ul></li></ul><h2 id="JUC-包（简化多线程开发）"><a href="#JUC-包（简化多线程开发）" class="headerlink" title="JUC 包（简化多线程开发）"></a>JUC 包（简化多线程开发）</h2><ul><li>乐观锁和悲观锁 <ul><li>悲观锁，Synchronized，锁住的对象在某一时刻只能被一个线程持有，严格保证了数据安全，但是上下文切换的性能开销相对较大。例子：一群人维圈抢一个凳子，谁快谁先做椅子，抢到椅子的人离开后，剩下那群人继续抢这个椅子，一直持续下去。</li><li>乐观锁，基于 CAS。</li></ul></li><li>AQS （抽象的队列同步器）原理：基于队列的同步容器（工具），里面有一个状态，该状态是原子更新的，如果没有办法成功更新该状态，则代表没有线程获取锁，反之有线程获取到锁。</li><li>CAS 实现和底层原理： <ul><li>原理：内存位置的内容与给定值进行比较，并且仅当它们相同时，才将该内存位置的内容修改为给定的新值。</li><li>例子：内存位置 V，程序执行从 V 中取到的值为 10，需要对值进行自增 1 操作，因此新值为 11 。程序开始执行，之前从 V 中取到的值为 10，获取当前 V 中的值，如果为 10，表示 V 中的值没有被修改，因此把 11 放进 V 中，如果为 11  表示 V 中的值被其他线程篡改了，因此此次更新失败，并把现在 v 中的值 11 返回保存，继续进行重试，直到成功。</li></ul></li><li>ConcurrentHashMap 原理： <ul><li>Java 8：哈希表加链表或红黑树，并发扩容，CAS。锁的粒度很细。</li></ul></li><li>CountDownLatch：主线程 await 等待，其他线程使用 countDown 数量减1，数量为 0 时，继续执行主线程代码。 <ul><li>主线程：做核酸。其他线程：核酸排队，10人一组。工作人员清点组人数，来一个就减 1 直到减为 0，安排该组进行核酸。</li></ul></li><li>CyclicBarrier：await 等待，当所有数量的线程都在 await，开始执行。 <ul><li>每个大白需要负责一条核酸线路，共 5 条。需要所有大白在场，才开始进行核酸检测，先来的大白就等待（await），直到5个人都来齐了，开始进行核酸检测。</li></ul></li><li>线程池（一家公司，核心员工数量 预计10人，除核心员工外还可以多招5个外包员工） <ul><li>参数：核心员工、外包员工人数、超过多长时间没事干就开除员工</li><li>如何工作： <ol><li>当新项目来的时候，发现核心员工数量不到10人，招一个核心员工来处理这个项目。</li><li>如果项目来的时候，所有核心员都在干活，那我们就给尝试给项目排期（放入队列）</li><li>如果排期失败（核心员工没时间处理新项目），就去招一个外包员工。如果人数已经达到最大上限（核心员工+外包员工 &#x3D; 15）或者公司倒闭了，就拒绝该新项目（拒绝项目也有策略）。</li></ol></li><li>公司接不了新项目了，如何拒绝： <ul><li>放弃该项目</li><li>谁建的新项目，自己去执行</li><li>直接丢弃排期项目中最晚的项目，然后再把该新项目加入排期，再去试试看能不能完成。</li><li>直接摆烂、不管这个丢弃的项目</li></ul></li><li>需要注意的地方 <ul><li>需要明确项目中最大支持的线程</li><li>大概知道线程池的工作状态</li></ul></li></ul></li></ul><h2 id="计算机原理-x2F-操作系统"><a href="#计算机原理-x2F-操作系统" class="headerlink" title="计算机原理&#x2F;操作系统"></a>计算机原理&#x2F;操作系统</h2><ul><li>进程之间的通信：管道 &#x2F; 信号 &#x2F; 共享内存 &#x2F; socket (tcp)</li><li>僵尸进程 <ul><li>当父进程创建了子进程，且子进程销毁后，子进程会留下 task 数据结构，exit code 等相关信息保留一段时间，便于父进程调用，此时子进程是僵尸状态。父进程调用后就会删除相关信息，但是当父进程不调用或者自身销毁后，子进程的留下的信息如何处理？</li><li>解决方法：Linux 的 init 进程会定时把自身设置僵尸进程的父亲，然后把他们清理。</li></ul></li><li>常见系统问题排查与僵尸进程</li></ul><h2 id="TCP-x2F-UDP-x2F-HTTP-x2F-HTTPS-x2F-SSH"><a href="#TCP-x2F-UDP-x2F-HTTP-x2F-HTTPS-x2F-SSH" class="headerlink" title="TCP &#x2F; UDP &#x2F; HTTP &#x2F; HTTPS &#x2F; SSH"></a>TCP &#x2F; UDP &#x2F; HTTP &#x2F; HTTPS &#x2F; SSH</h2><ul><li>tcp 可靠传输，自动重传。三次握手、四次挥手 <ul><li>明文、基于流。</li></ul></li><li>udp 尽最大可能交付，允许错误发生。场景：视频、语音、直播。</li><li>SSH 连接流程 <ul><li>在服务器上设置自己的公钥信息。</li><li>使用 SSH 命令连接服务器，此时 SSH 会用你的私钥加密一小段数据，传输给服务器。</li><li>服务器使用公钥，进行解密，解密成功建立连接。</li></ul></li><li>RSA 非对称加密 <ul><li>公加私解：保密传输</li><li>私加公解：数字签名</li></ul></li><li>HTTPS 的 SSL handshake 流程 <ul><li>请求服务器，服务器用私钥加密一段数据（数字签名），把加密后的数据和公钥返回给客户端</li><li>计算机中的 CA 机构对公钥进行检查认证，验证通过往下执行，否则会提示。</li><li>客户端根据用返回的公钥对加密的数据进行解密，解密成功即可确认该服务器是想要请求的服务器。</li><li>客户端用公钥加密一段数据（对称加密算法），返回给服务器。服务器用私钥进行解密，得到对称加密算法，此时客户端与服务器 HTTPS 连接已经建立完成</li><li>后续的通信使用对称加密算法，对内容进行加密解密。</li></ul></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>Redis 为什么这么快？ <ul><li>单线程，避免了上下文切换。</li><li>数据结构优化</li><li>IO 多路复用</li></ul></li><li>Redis 支持的数据结构 <ul><li>String &#x2F; List &#x2F; Set &#x2F; Zset &#x2F; Hash</li><li>延时队列实现 - Zset score 设置为时间戳</li><li>不带消费保证消息队列</li></ul></li><li>Redis 的两种持久化 <ul><li>RDB &#x2F; AOF：全量 &#x2F; 增量</li><li>BGSAVE &#x2F; CopyOnWrite</li></ul></li><li>Redis 淘汰策略 <ul><li>LRU - Least Recent Used 最近最少使用</li><li>noeviction 不淘汰，内存超过设置的值丢出异常。</li><li>allkeys-lru 所有的 key 使用 lru 的方式淘汰</li><li>volatile-lru 过期的 key 使用 lru 的方式淘汰</li><li>allkeys-random 所有的 key 随机淘汰</li><li>volatile-random 所有过期的 key 随机淘汰</li><li>volatile-ttl 淘汰超时的 key，和快要过期的 key</li></ul></li><li>Redis 主从？ <ul><li>一个 Master， 若干个 Slave 同步</li></ul></li><li>Redis 哨兵机制 <ul><li>Master 和若干个 slave，以及 Sentinel，其中 Sentinel 用来监控 redis 集群状态。当 master 挂掉，Sentinel 就会知道，并且选一个 slave 称为新的 master，然后通知应用程序做变更。</li></ul></li><li>分布式锁 <ul><li>SETNX TIMEOUT，命令在指定的 key 不存在时，为 key 设置指定的值，这种情况下等同 <a href="https://www.redis.com.cn/commands/set.html">SET</a> 命令。当 <code>key</code>存在时，什么也不做。并设置个超时时间避免死锁。</li><li>redlocks?</li></ul></li><li>缓存雪崩 <ul><li>缓存突然挂了，所有的流量涌到数据库上</li><li>解决方案：限流（熔断）只处理指定数量流量、服务降级。</li></ul></li><li>缓存穿透 <ul><li>使用一个不存在的 key 频繁 访问数据库。</li><li>解决方法：把找不到的情况也放在 redis 中，同正常的情况一致处理。</li></ul></li><li>缓存与数据库的一致性（左耳朵耗子：<a href="https://coolshell.cn/articles/17416.html">缓存更新的条路</a>)</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>B+ 树，是多叉树，高度很低。Hash 索引。</li><li>B+ 树特点：减少磁盘 IO，每次读取尽可能多的数据、范围查找、磁盘预读（把数据和周围的数据都读取做缓存）</li><li>Hash特点：快，但是无法进行范围查找</li><li>聚簇索引和非聚簇索引 <ul><li>InnoDB 聚簇索引，只有主索引关联对应并持有的数据，非主索引存储主索引的指针（也称回表），因此通过非主索引的查找如下：非主索引 -&gt; 主索引 -&gt; 数据。</li><li>MyISAM 非聚簇索引，主索引和非主索引都关联并持有数据。</li></ul></li><li>乐观锁悲观锁</li><li>各种隔离等级</li><li>MySQL 索引优化 <ul><li>最左匹配原则：创建联合索引 “a,b,c” 时，实际上创建了三个索引，a索引，a,b 索引，a,b,c 索引。根据查询条件选择索引。</li><li>排查：explain 命令，查看对应的语句使用索引的情况。</li><li>索引失效：不满足最左匹配或者使用了函数。例如：where date(create_at) &lt; ‘2022-05-01’</li></ul></li><li>MySQL 主从 <ul><li>什么是 Binlog: 记录所有对数据库更改的一个日志，二进制文件。用于数据库主从同步和备份。</li><li>主从同步过程：主库发生写请求，对应的 Binlog 会进行修改。binlog 会发送给从库，binlog在从库中有个 relaylog(中继日志)，把relaylog 和当期那从库合并。</li></ul></li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h2 id="RPC-与-Dubbo"><a href="#RPC-与-Dubbo" class="headerlink" title="RPC 与 Dubbo"></a>RPC 与 Dubbo</h2><ul><li>RPC 是如何工作？ <ul><li>代理模式：JDK 动态代理、Cglib 字节码增强</li><li>二者优缺点：本质都是生成一个字节码，JDK 只能代理接口，而 Cglib 是代理一个类，功能更强大。</li></ul></li><li>Dubbo 是如何工作？ <ul><li>官网图</li></ul></li><li>负载均衡、服务注册、健壮性 <ul><li>负载均衡算法：roundrobin（轮流）、加权轮流、Sticky（粘性）、hash（客户端 ip 进行 hash）</li><li>服务注册：每个服务提供者把自己注册到服务中心中</li><li>健壮性： <ul><li>当注册中心挂掉，不影响到消费者和服务者通信。</li><li>当服务提供者挂掉后，服务消费者应自动的重连下一个机器，自动恢复</li><li>所有的提供者挂掉，消费者可以预先配置默认的返回值</li></ul></li></ul></li><li>限流算法 <ul><li>计数器：设定接口的值，例如1000，每个请求进来都减1，当变成负数之后，不处理请求。后台设置定时任务，每秒将该值设置为 1000，这样就可以达到 1000qps。缺点：1000 瞬间变成0，服务器会一直拒绝其他请求，导致无响应。</li><li>漏桶：请求都放在漏斗中，处理完成的请求通过尖嘴流出，漏斗溢出的请求不处理。</li><li>令牌桶：令牌生成器，往桶里放令牌。每个请求需要去桶拿令牌消耗，能拿到请求继续，否则请求结束。当令牌桶的令牌被消耗完之后，请求则需要等待令牌生成器生成令牌，才能往下继续。</li></ul></li></ul><h2 id="Zookeeper-与分布式"><a href="#Zookeeper-与分布式" class="headerlink" title="Zookeeper 与分布式"></a>Zookeeper 与分布式</h2><ul><li>分布式序列号生成算法 <ul><li>雪花算法</li></ul></li><li>分布式事务</li><li>分布式一致性 <ul><li>强一致：用户所做的修改所有服务器上立刻得到更新，可用性和性能相对差</li><li>弱一致（最终一致）：下完订单，刷新回到未付款状态，再次刷新已支付</li></ul></li><li>保证分布式一致性 <ul><li>一致性 Hash，请求计算 hash 选择最近的 hash 节点。节点分布不均，可以设置虚拟节点</li></ul></li></ul><h2 id="Spring-x2F-SpringMVC-x2F-Spring-Boot"><a href="#Spring-x2F-SpringMVC-x2F-Spring-Boot" class="headerlink" title="Spring &#x2F; SpringMVC &#x2F; Spring Boot"></a>Spring &#x2F; SpringMVC &#x2F; Spring Boot</h2><ul><li>IOC &#x2F; DI 及其实现原理</li><li>容器 &#x2F; bean 声明周期</li><li>AOP 实现及原理：JDK 动态代理和 Cglib 字节码增强。</li><li>设计模式：refresh 模板方法，单例模式，代理模式，工厂模式。</li><li>Spring Boot 改进 <ul><li>流程配置全部自动化掉，Spring 和 SpringMVC 有的他都有</li><li>基于注解的，减少 xml</li><li>Auto configuration 自动配置</li><li>内置 Tomcat 等 Servlet 容器</li></ul></li><li>Spring Boot 缺点 <ul><li>像魔法，封装的太好了。使用者不明白他是如何工作的</li><li>jar 包比较大，内存比较多</li></ul></li></ul><h2 id="CI-与持续集成"><a href="#CI-与持续集成" class="headerlink" title="CI 与持续集成"></a>CI 与持续集成</h2><ul><li>概念：程序员写代码，提交代码，测试环境中进行测试，测试无误发布到生产环境，生产环境出 bug 又要回滚。可以看到从提交代码之后的每个步骤，程序员都需要手动的进行操作，比如发布，部署项目，手动测试项目，回滚项目等等。我们要做的是，程序员只需要负责编写和提交代码，剩下的工作都交给自动化工具去做。 </li><li>流程：本地开发环境 -&gt; 版本控制系统 (Git) -&gt; CI 服务器（Jenkins）-&gt; 测试环境服务器、预生产服务器、生产服务器</li></ul><h2 id="what-do-you-do"><a href="#what-do-you-do" class="headerlink" title="what do you do?"></a>what do you do?</h2><ul><li>研究文本抄袭算法 SimHash、了解 Handlp、斯坦福 MOSS 服务。</li><li>学英语</li><li>Java 8 - Java 18 历代的变化，有哪些新特性，自己的项目在使用 Java 17</li><li>简单学习了 LaTeX，CV 也是使用开源项目 Awsome CV 和 LaTex 编排的。</li><li>学习 Groovy 脚本语言</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字节码加载与执行</title>
    <link href="/2022/03/03/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <url>/2022/03/03/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码是高级语言和 JVM 通信的桥梁，高级语言只做一件事：把代码编译成字节码。因此，完全可以编写一套自己的编程语言，定义他的语法规则，然后将实现一个编译器，将代码转为字节码即可。</p><p>来看看 Java 中的字节码长什么样子，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.greek.shop;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译之后部分字节码如下：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/3f4c78d1-d33f-4463-a2d3-b2a4dc2901d4.png" alt="image.png"></p><p>图中的字节码，正在一行行地执行指令，这些指令作用可以参考 <a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">Java 字节码指令表</a>。</p><p>不知你是否察觉，我们可以直接编写字节码，而不再需要高级语言编译成字节码，这当然是可行的，因为我们熟知的「动态代理」就是这么做的。</p><h2 id="字节码加载"><a href="#字节码加载" class="headerlink" title="字节码加载"></a>字节码加载</h2><p>编译器把高级语言编译成字节码文件，那么 JVM 又是怎么加载和执行字节码的呢？</p><p>不知你注意到没，在使用 IDE 运行程序时，好像只要点击绿色箭头代码就可以运行了。IDE 好像有魔力一般，但实际上那个绿色箭头只是在后台「偷摸」地拼接一个命令行，启动一个 JVM ，仅此而已。</p><p>你可以通过控制台查看到 IDE 帮你拼接的命令行，命令行中有一个参数 **”-classpath”**，这个 classpath 就指明了 JVM 加载字节码路径。想更多了解 Java 启动命令相关知识，可以参考我之前写的<a href="https://www.yuque.com/greek-zzf/uc535m/lvzgfb">博客</a>。</p><p>使用 classpath 指明了加载路径，于是 JVM 便使用类加载器 (ClassLoader) 加载字节码。</p><p>类加载器只有一个作用，负责加载字节码文件，仅此而已。他也支持动态加载代码，动态生成代码等，用一段代码简单演示动态加载代码过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>   <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> scanner.next();<br><br>   <span class="hljs-type">File</span> <span class="hljs-variable">jar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;fastjson-&quot;</span> + version + <span class="hljs-string">&quot;.jar&quot;</span>);<br>   <span class="hljs-keyword">if</span> (jar.exists()) &#123;<br>       <br>       <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;jar.toURI().toURL()&#125;);<br>       <span class="hljs-type">Class</span> <span class="hljs-variable">fastJson</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;com.alibaba.fastjson.JSON&quot;</span>);<br>       System.out.println(fastJson.getField(<span class="hljs-string">&quot;VERSION&quot;</span>).get(<span class="hljs-literal">null</span>));<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       System.out.println(jar.getName() + <span class="hljs-string">&quot; Not Found!&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>上诉代码在项目中没有引入任何依赖和 Jar 包，只是在项目根目录中放了两个不同版本的  FastJson jar 包。用户输入 FastJson 版本，类加载器去加载对应的 jar 包，获取成功打印 jar 包的版本信息，这就是个简单的动态加载过程。</p><p>上诉代码可以让 ClassLoader 加载指定版本的 jar 包，其实热部署的原理也类似于此。通过监听器监听对应的文件或文件夹，倘若发生改变，则调用自定义的 ClassLoader 进行重新加载，达到热部署的目的。</p><p>当然类加载器的场景还存在 Mock ，AOP 中，使用过 Mockito 或者 AOP 就会知道，他们都是通过<strong>字节码增强</strong>的方式生成目标对象的子类，然后交给 JVM 执行。</p><h3 id="双亲委派加载模型"><a href="#双亲委派加载模型" class="headerlink" title="双亲委派加载模型"></a>双亲委派加载模型</h3><p>由于 ClassLoader 只负责加载字节码，因此完全有可能，编写一个恶意的字节码文件，让 ClassLoader 去加载执行它，破环我们的程序。为了程序的安全性，于是就有了<strong>「双亲委派加载模型」</strong>。</p><p>在 Java 8 及之前的双亲委派加载模型如图：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/83a6b7ef-4646-4e08-bd37-8568ca3b1ff7.png" alt="classloader.png"></p><p>通过图中的关系，可以发现 JVM 的启动不止有一个类加载器，而是有三个。这三个类加载器各司其职，分工明确，且三个类加载器都是继承关系。</p><ul><li><strong>Application ClassLoader （应用类加载器）</strong>是负责加载 classpath 里面的包，即我们编写好的代码，该加载器继承 Extension ClassLoader。 </li><li><strong>Extension ClassLoader （扩展类加载器）</strong>负责加载与运行程序相关的 jar 包，像使用的 ArrayList，Object 等等，该类加载器继承 Bootstrap ClassLoader。 </li><li>** Bootstrap ClassLoader（启动类加载器） **负责加载 JVM 启动时至关重要的包。</li></ul><p>双亲委派加载模型简单描述就是：<strong>子加载器加载类之前，需要先去询问父加载器，如果父加载器不为空且找到该类，则直接返回，否则子加载器才去加载</strong>。</p><p>在这个过程中你发现了吗？越核心的类都是由父加载器去加载的，这样在一定程度上保存了程序的安全。倘若你伪造一个 java.lang.Object 类，想让类加载器去加载该 Object 类，这是做不到的。当 Application ClassLoader 去加载伪造的 Object 时，就会先去询问父加载器是否加载该类，显然该 Object 类已经被 Extension ClassLoader 加载，只不过加载的 Object 并非你伪造的 Object，因此你伪造的 Object 并不会被加载。</p><h3 id="神奇的类"><a href="#神奇的类" class="headerlink" title="神奇的类"></a>神奇的类</h3><p>自定义一个 ClassLoader 并且实现了 loadClass 方法，如果加载的类名字为 BadClass 则使用自定义的类加载器去加载，否则由父加载器加载。然后将加载好的 BadClass 字节码文件，实例化一个 BadClass 对象。详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.greek;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BadClass</span> <span class="hljs-variable">bad</span> <span class="hljs-operator">=</span> (BadClass) <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>().loadClass(BadClass.class.getName()).newInstance();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">if</span> (name.contains(<span class="hljs-string">&quot;BadClass&quot;</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;target/classes/com/greek/BadClass.class&quot;</span>).toPath());<br>                <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;Class &quot;</span> + name + <span class="hljs-string">&quot; Not Found!&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当你运行这段代码时，你会发现竟然报错了，在我的控制台中错误信息如下：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/162ca5ee-c88c-48af-8cd7-14fdd98ebfa0.png" alt="image.png"></p><p>什么？两个相同的类包名也完全一样，竟然不能互转，，真是令人大跌眼镜。</p><p>那么为什么会这样呢？这是因为这两个 BadClass，不是由同一个类加载器加载的。BadClass 在 JVM 中是由 Application ClassLoader 加载的，上面的代码使用 MyClassLoader 覆盖 loadClass 逻辑，主动去加载 BadClass 并用加载的字节码实例化一个 BadClass 对象，但由于声明的对象和实例化的对象并非相同的类加载器加载的，就会导致类型转换异常。</p><p>同样的在 Java 的 instanceof 方法，类加载器也会被检查，若不是同一个类加载器加载的类，则 instanceof 判断为 false，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">badClass</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>().loadClass(BadClass.class.getName()).newInstance();<br>System.out.println(badClass <span class="hljs-keyword">instanceof</span> BadClass);<br></code></pre></td></tr></table></figure><h2 id="JIT-Compiler"><a href="#JIT-Compiler" class="headerlink" title="JIT Compiler"></a>JIT Compiler</h2><p>有了类加载器加载字节码，还需要将字节码「翻译」成对应平台的指令。这个「翻译」过程由两种方式：<strong>编译执行和解释执行</strong>。</p><p><strong>解释执行</strong>就是每执行一行就把该行翻译成机器指令，类似于「同声传译」。自然他会比较慢，因为每次执行都需要一个转换的过程，但是它对于跨平台是很方便的，因为，不用操心平台是否能看懂字节码，只需要带个同声传译的翻译即可。</p><p><strong>编译执行</strong>就是把要翻译的内容，提前翻译好，然后直接给到平台。这样的好处是执行快，平台不用等你翻译，它直接拿翻译好的文件阅读即可。缺点也很明显，就是不灵活，在 Windows 平台运行，要提前翻译成 Windows 的指令，在 Liunx 平台运行，又要翻译成 Liunx 的指令，且翻译后的文件都比较臃肿。</p><p>那么 HotSpot 是用的那种方式呢？</p><p>答案是混合模式，它既不想丢失解释执行的便利性，也不想失去编译执行的速度，所以采取了折中的方案。他把一些常用的方法采用编译执行编译好，以提升执行的代码执行速度，其他的则采用解释执行。</p><p>JIT Compiler 全称是 Just In Time Compiler（即时编译器），HotSpot 就是使用该编译器动态地发现 JVM 运行时的<strong>热点</strong>，然后针对这些热点编译成相应的 native code ，提高运行效率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，字节码的加载与执行过程已经结束了，他的神秘面纱也被揭开。</p><p>高级语言通过编译器编译成字节码，JVM 使用类加载器去加载字节码。字节码存在安全性问题，因此 JVM 采用双亲委派机制去加载字节码。又因为每次执行都需要将字节码编译成机器指令，效率并不高，因此采用了即时编译 JIT 技术，这样既保证了效率又保证了跨平台性。</p><p>纵观整个过程发现，编程语言到可以执行的机器指令，经历了不止一次编译过程。把从高级语言到字节码的过程称为<strong>编译前端，</strong>从字节码到机器指令的过程称为<strong>编译后端。</strong>两个端各司其职，互不干扰，都是通过字节码这个「中介」交流<strong>。</strong></p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>字节码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基本结构</title>
    <link href="/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>谈起 JVM 第一印象就是「八股」，毕竟正经人谁学 JVM 啊。当我深入学习，了解了相关原理后，真令人大呼过瘾。</p><p>了解 JVM 并不会让你更快的 CRUD，对大部分工作没有实质性的帮助，但这是成为高级程序员的第一步。</p><h2 id="JVM-初识"><a href="#JVM-初识" class="headerlink" title="JVM 初识"></a>JVM 初识</h2><p>JVM 全称是 <strong>Java virtual machine</strong> 即 Java 虚拟机。JVM 是抽象（虚拟）计算机，它定义了一系列规范，因此他有很多实现，如：HotSpot，Eclipse OpenJ9 等等，最常使用的应该就是 Oracle 的 HotSpot。</p><p>JVM 存在的意义就是抹平所有平台和操作系统的鸿沟。它就像是一个在不同平台提供的翻译官，当用英语和它对话时，他翻译成自己「国家」的语言并执行。这就是为什么在 Windows 下编写好的代码能够在 Linux 等其他系统运行的原因。</p><p>代码编译执行过程如图<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/4ff19c89-d87f-4273-bfe4-3c47e3a8f1ad.png" alt="jvm_1.png"><br>程序员使用像 Java，Kotlin，Scala ，Groovy 等高级语言进行编码，编译成 JVM 能识别的语言。JVM 识别并进行「二次编译操作」，将它翻译成对应的平台语言。</p><p>日常编码所做的仅仅只是用高级语言编写一份「说明书」，说明书如何编译成中间语言，这就是高级语言编译器做的事了，当然也可以自己去实现一个编译器，嗯。。至少我目前没有这个能力。</p><p><strong>JLS</strong></p><p>Java 语言规范 Java Language Specification， 定义了 Java 编程的语法。比如 Java 中的关键字信息 class、public 等等，都是在 JLS 规范下，完成 Java 代码的开发。</p><p><strong>JVMS</strong></p><p>Java 虚拟机规范 Java Virtual Machine Specifiction，定义了字节码如何在 JVM 中执行，仅此而已。</p><h2 id="JVM-堆-Heap"><a href="#JVM-堆-Heap" class="headerlink" title="JVM 堆 (Heap)"></a>JVM 堆 (Heap)</h2><p>堆是 JVM 中非常重要的区域，所有的「对象」都在堆上分配，它是个无情的对象生产机器，只负责生产，不负责销毁。</p><p>堆为我们创建了对象，但是在代码中操作与访问对象实际上都是在操作对象的地址或者引用。</p><p>来看个非常简单的代码，以此来演示堆中发生了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1540f816-9a4c-4b1f-af66-0a4c6b917b3c.png" alt="jvm_heap.png"><br>首先堆内存中创建了一个对象（假设对象地址为 100），然后将该对象的地址赋值给 obj 变量，可以想象有一条线将 obj 和 对象 100 连接起来。</p><p>接着，堆内存中又创建了一个变量 101，然后将该对象地址赋值给 obj，此时 obj 和对象 101 连接起来了。这就是堆所做的一切。</p><p>很显然，上面的例子对象 100 还是存在堆中，他并没有消失，他还在等有缘人「联系」它。</p><p>这样就会存在一个问题，「无人问津」的对象越来越多怎么办？这就涉及到 GC 了，GC 会根据相应的算法来判断对象是否需要回收销毁，因此暂时不需要操心，后续提供 GC 的讲解。</p><p>当然堆中产生的对象太多，大量占用堆内存，导致内存溢出，常见表现为 OOM (Out Of Memory) 异常。当代码出现该异常时，就应该关心，代码是否产生了大量不必要的对象，谨慎的检查代码。</p><h2 id="JVM-栈（Stack）"><a href="#JVM-栈（Stack）" class="headerlink" title="JVM 栈（Stack）"></a>JVM 栈（Stack）</h2><p>当我们用 IDEA Debug 如下代码，可以看到在 IDEA 界面底部，多了一些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    a();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am a&quot;</span>);<br>    b();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我的调试器中表现形式如下：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/9c51eaa9-3ce2-4d47-9a40-b38be9fba7aa.png" alt="method_stack.PNG"></p><p>从 main 方法到 b 方法，中间一系列调用都称作<strong>「栈」</strong>或<strong>「方法栈」</strong>，其中每一次方法调用称作<strong>「栈帧」</strong>，如图中的 main，a，b。</p><p>不知你是否思考过，为什么代码的调用形式会是这样？无论你是否好奇过，现在我来分析下代码执行的过程。</p><p>我们都知道，Java  程序的入口都是 main 方法开始的，因此当代码被执行时，会先调用 <strong>main</strong> 方法。不过，在调用 main 方法之前，JVM 创建一个方法栈，用来保存「当前线程」方法调用过程（因此方法栈是线程私有的）。于是方法栈中会放入第一个栈帧 main，由于栈结构的特性，main 自然而然的就会在栈底。</p><p>接着执行 main 方法，执行到最后需要调用 <strong>a</strong> 方法，因此将栈帧 a 放入方法栈中。接着 a 中又调用 b 方法，以此类推。现在，方法栈中已经有 3 个栈帧了，方法调用已经结束了。于是从栈顶开始，将方法的执行结果依次返回，b 方法中无返回值，因此执行完打印语句，b 栈帧就销毁了。以此类推到 a 方法，最后到 main，这就是上述代码玩完整的执行过程，流程如图：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/41370100-58dc-4f78-bdde-b88dd7483c77.png" alt="method_stack_invoke.png"></p><p>了解了方法调用的基本流程，这里有几个疑问：</p><p><strong>Q：当方法栈满了会发生什么？</strong></p><p>A：当栈深度过⼤时抛出 StackOverflowError，著名的程序员交流网站就是以此命名的 <a href="https://stackoverflow.com/">stackoverflow</a></p><p><strong>Q：栈帧销毁什么时候被销毁？</strong></p><p><strong>A</strong>：这些情况栈帧会被销毁：当方法执行抛出异常或者错误；方法正常返回结果或者无返回。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>来看一段简单的代码， a 方法定义了一个变量，并且调用了 b 方法使得该变量自增，然后打印该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    b(i);<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    i++;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中打印的结果为 0，按照正常的思维去理解的话，i 的值因该为 1 才对，这是为什么？</p><p>这是因为这些变量在方法中都是<strong>「值传递」</strong>的，当把 i 传递给 b 方法时，发生了一次拷贝，因此 b 方法中操作的 i，实际上只存在 b 方法中，并不会影响到 a 方法中的 i 变量。</p><p>上面说的是基本类型变量传递，接下来用引用数据类型来进行参数传递，看看发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    b(obj);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(Object obj)</span>&#123;<br>    obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中初始化了一个变量 obj，并把它当作参数传递给 b 方法，b 方法中创建一个新的对象，并把该对象地址赋值给参数 obj。整个过程就是这样，此时 a 中的 obj 对象和 b 中的 obj 是什么关系？他们是同一个对象吗？b 中的对象改变了，会影响到 a 吗？</p><p>有过编程经验的应该都知道，答案是否定的。<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/42e48b45-6083-49b6-ae87-95fe66c76114.png" alt="stack_argument.png"><br>如图所示，a 中 obj 变量指向 Object 10087，把 obj 当作参数给 b 方法时，他会直接复制 obj 所指向的对象地址，即 b 方法刚开始也指向 10087 对象。之后创建了一个新对象地址为 10086，并把地址重新赋值给了 obj，因此 b 中的 obj 指向的是 10086，而 a 指向的是 10087，两者操作的都不是同一个对象，因此也不会相互影响。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>现在已经对 JVM 中的堆和栈有所了解，但是对于方法栈中的每个栈帧还不了解，目前只是知道方法调用就入栈，结束就出栈。因此，现在将栈帧放大来看，看看代码执行过程中，栈帧发生了什么。</p><p>每个栈帧中都有一个「操作数栈」和「局部变量表」。</p><p>每当方法调用开始的时候，局部变量表会被初始化成当前方法的参数。操作数栈上会根据代码实际情况，加载局部变量表中的数据，或者直接加载常量，根据<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">字节码指令集</a>，完成相应的数据操作。</p><p>这就像是人在吃饭一样，用筷子在碟子（局部变量表）中夹菜，夹到碗中（操作数栈），然后根据自己喜好（代码）吃自己的菜。</p><h2 id="JVM-方法区"><a href="#JVM-方法区" class="headerlink" title="JVM 方法区"></a>JVM 方法区</h2><p>方法区中包含了整个虚拟机所共享的 Class 信息，JVM 就是根据方法区中 Class 这份说明书，来帮我们生成对象的。</p><p>方法区中存的所有信息都是共享，基本都是只读的，但这并不是一定的。<strong>「运行时常量池」</strong>就是个例外，在程序运行时往往会往常量池中放入常量信息。</p><p>运行时常量池会保存经常使用的常量，例如 String 字符串常量，当重复 new 一个相同字符串对象时，新的对象就会指向字符串常量池中的字符串常量，这样就节省了内存开销。同时在 String api 中，由于常量的重复使用，可以使得它的 equals 方法可以更快速地进行判断。</p><p><strong>永久代和元空间</strong></p><p>JVM 方法区是一块所有的线程共享的区域，是 JVM 所定义的规范。</p><p>Java 7 之前发方法区的实现称作<strong>「永久代」</strong>，即 <strong>PermGen</strong>。Java 8 之后的称作<strong>「元空间」</strong>，即 <strong>Metaspace</strong>。</p><p>在 Java 7 中，方法区和堆是使用一块连续的物理内存，仅仅是在逻辑上分开的。如果没有设置方法区的大小的话，使用默认大小很容易遇到 OOM 错误。</p><p>在 Java 8 之后，把方法区和堆区分开来，使用了本地内存（Native memory），大小取决于本地内存大小。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机原理</title>
    <link href="/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-执行过程（简述）"><a href="#CPU-执行过程（简述）" class="headerlink" title="CPU 执行过程（简述）"></a>CPU 执行过程（简述）</h2><p>CPU 的本质就是一个执行<strong>指令</strong>的工人。</p><p>上面的概述引发了几个问题，什么是指令？指令从哪里来？CPU 如何执行和加载这些指令？</p><p><strong>指令</strong>，顾名思义指示和命令。这个命令和指示的对象是 CPU，CPU 可以明白它的意图，并执行。</p><p>现代 CPU 识别的指令都是由<code>字节码</code>组成，即一长串的 0 和 1。</p><p>还记得远古计算机是如何编写和执行指令的吗？没错，是一条条穿孔的纸带，带孔为 1，无孔为 0。那个时候就是用这种<code>朴素</code>的方式来组成一条条指令。但是现在已经被晶体管代替了。</p><p>CPU 从内存中读取指令，并执行指令内容。指令执行的中间结果会保存到相应的寄存器中。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/image.png" alt="image.png"></p><p>Tips:  像这种指令和数据存储在一起的结构称作 <a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84"><strong>冯·诺伊曼结构</strong></a></p><h2 id="程序装载与执行"><a href="#程序装载与执行" class="headerlink" title="程序装载与执行"></a>程序装载与执行</h2><p>CPU 能够执行指令，但一般都是给一组指令交给 CPU  去执行。该组指令中可以构成简单的逻辑跳转，例如：C 指令执行成功，则跳转到 F 指令执行，否则跳转到 D 指令。</p><p>程序就是一组指令和数据的集合，在 Windows 中就是我们常见的 exe 文件。</p><p>当我们在电脑中打开多个记事本时，内存中为多个记事本进程开辟了不同的空间，对于每个记事本来说，自己所处和所使用的的内存地址都是一样的，进程之间互不干扰。但是通过「上帝视角」可以发现每个记事本进程只是占用内存的一段空间而已。</p><p><strong>Q: 不同 CPU 架构，为什么不能运行同一个程序 ？</strong></p><p>A: 不同 CPU 架构对于，指令集的理解不同。因此程序需要在不同的 CPU 架构中使用不同的指令集。</p><p><strong>Q: 同 CPU 架构，不同操作系统，不能运行同一个程序 （Linux  和 Windows）？</strong></p><p>A: 同 CPU 架构 对于程序指令集的理解是相同的。</p><p>不同之处在于，系统提供的 API 不同。例如，Windows 提供了 createProcess 方法创建进程，但对应 Liunx 上就不存在该方法。</p><p>不同系统内存布局也不相同，导致装载程序的方式也存在差异。因此，程序跨平台性存在问题。</p><h3 id="解决跨平台"><a href="#解决跨平台" class="headerlink" title="解决跨平台"></a>解决跨平台</h3><p>为了解决跨平台问题，于是在操作系统之上维护了一个虚拟机 JVM。</p><p>JVM 负责把统一的<strong>中间语言</strong>，转换成对应操作系统的能识别的语言。而这个中间语言之上就是高级语言，像 Java，Python 等。这些高级语言的作用就是把我们编写的代码，编译成<strong>中间语言</strong>，然后交给 JVM 执行。这也是为什么 Java 和 Python 具有跨平台性。</p><p>但并非所有的语言都需要转化成中间语言，像 Go 编译之后就是 native 的，因此不需要 JVM，直接交给操作系统执行。由于省去了一个 JVM 虚拟机中间操作，因此性能会极大的增强，但跨平台方面就会收到限制，需要对不同操作系统编译。</p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>假如所有程序都需要调用一个指令 A，为了避免重复，可以把 A 和一些经常使用的指令封装成库。这样程序中就不需要完整地写入 A 指令，只需要引用 A 指令即可。这样CPU 就会在程序之外去调用 A 指令，完成操作。</p><p>把这个引用库的行为称作「动态链接库」</p><p>这样做的好处显而易见，可以省空间，程序都从一个地方调用执行。还有就是，需要升级的话，只需要升级引用的库即可。</p><p>缺点也很明显，当程序引用的库，找不到时。就会提示「缺少 xxx」，比如一些游戏启动的时候。存在库，但是不兼容也是很要命，例如程序需要 1.0 版本的库，但是系统只有 2.0 的库。程序在刚开始启动可能不会有问题，但是当执行到需要引用 1.0 版本的库命令时，程序就会崩溃。</p><h2 id="程序时分复用"><a href="#程序时分复用" class="headerlink" title="程序时分复用"></a>程序时分复用</h2><p>日常生活中，经常会一边听着歌，一边敲着代码。有没想过，为什么听歌和我写代码可以同时执行？</p><p>这是因为，虽然 CPU 只有一个，他只能按照顺序一个一个执行，但是架不住他快啊。你这一眨眼的功夫，他已经在几个程序中切换执行了很多遍，给你的感觉这几个程序在同时进行，计算执行效率快的离谱。</p><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>正如上所说，CPU 会再程序中切换执行，相当于每个程序在轮流占用 CPU 时间，占用的时间称为「时间片」。只有线程和进程能占用 CPU 时间。</p><p>程序进程能占用 CPU 时间，但是并不能一直占用 CPU，否则其他程序便无法继续执行了。当程序的时间片结束了之后，CPU 便往下执行下一个程序的时间片。</p><p>请求慢速设备时，也会例如我们用记事本编写一段文字后，点击「保存」。这个时候需要将我们写的内容存储到磁盘上，由于 IO 操作和 CPU 的执行速度相比实在是太慢了，因此 CPU 并不会傻傻等待 IO 保存，而是继续往下执行下一个指令。</p><p>这可能与你理解的不相符，有的应用程序保存后，会弹出「保存成功」的框，如果 CPU 不等待 IO 的话，那他怎么及时处理这个弹框呢？这就涉及到另一个知识了「中断」。CPU 会对中断请求进行「特殊处理」，当 IO 操作结束后，就会向 CPU 发起一个中断请求，CPU 会放下手头的活，优先处理这个中断请求。</p><p>总结，以下三种情况会放弃 CPU。当前程序的时间片执行完成之后，当需要请求一个慢速设备时（IO 操作），存在中断请求时。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当占有 CPU 的程序，时间片到了后，CPU 开始执行下一个程序了。当 CPU 再次执行原来的程序时，他是怎么知道原来的程序执行到哪一步了，换句话说，如何恢复程序执行的状态。</p><p>时间片快要结束时，CPU 会将当前程序的数据，执行步骤等信息保存起来，当再次执行到该程序时，就会加载保存的数据，恢复之前的状态继续执行。和打游戏一样，打着打着，突然被爸妈喊去吃饭，这个时候就要把游戏存档，等下次打开游戏直接读档，继续游戏即可。这个「存档」和「读档」过程，就叫做<strong>上下文切换</strong>。</p><p>由于 CPU 频繁的切换上下文，这个性能开销虽然对于普通用户感知不到，但是对于 CPU 执行来说确是巨大的。这也是为什么有「用户态线程」的概念，即程序自身去维护内部的线程调度，这样就会大大减少 CPU 上下文切换，这也正是 Go 语言所使用的的协程。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2022/01/03/Stream/"/>
    <url>/2022/01/03/Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Stream-流"><a href="#什么是-Stream-流" class="headerlink" title="什么是 Stream 流"></a>什么是 Stream 流</h2><p>流就相当于工厂的流水线工作，传送带上是一件件产品，而传送带周围是一些工人。有的负责把挑出次品，把它放到其他另一条流水线中重新加工，有的负责根据产品颜色进行收集，等等。如下图所示。<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Stream/446cbca4-82a6-49e7-8ceb-1ceadcbcc8a9.png" alt="image-20210424211146663.png"></p><p>三个员工对传送带上的产品进行操作，老王负责收集把黄色产品挑出，老周负责把产品按先后排序，而老赵负责把残次品挑拣出来，拆开零件放到新的床送带中，继续加工。传送带的终点就是篮子，产品都流向篮子里面。</p><p>流的操作就是如此。在没有流之前，我们要自己从一堆产品中找到残次品很难。但是我们有了流之后，我们有了流水线，有了工人，我们就可以让工人帮我们收集，让他们来处理，我们只是充当老板的角色，下达命令即可。在 Java 的流 (Stream) 中，我们只需要使用一些命令，剩下的交给程序本身去执行。这样做既减少了代码量，又能高效完成我们的需求，真是两全其美。</p><p>在上面的过程中，我们把老王和老周，以及老赵操作叫做<strong>中间操作</strong>。因为他们并没有把产品收集起来，他们只是把其他不合格的产品过滤挑出，产品最终都是到篮子里面。但是你装产品不一定是用篮子，你也可以使用箱子，等其他容器。我们把使用这些<code>容器</code>装产品的操作称作<strong>终结操作</strong>。在 java 中，<strong>中间操作就是返回为 Stream 的操作，终结操作就是返回非Stream 的操作。</strong>下面会详细讲解。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p><strong>创建 Stream</strong></p><ul><li>Collection.stream()</li><li>Stream.of()</li><li>String.chars()</li><li>IntStream.range() 等</li></ul><p><strong>Stream 中间操作</strong></p><ul><li>filter 按照输入的条件，过滤流中的元素</li><li>map</li><li>sorted 对流中的元素排序</li></ul><p><strong>Stream 终结操作</strong></p><ul><li>forEach 遍历流中的元素</li><li>count &#x2F; max &#x2F; min 统计元素个数 、最大元素、最小元素</li><li>findFirst &#x2F; findAny 找到第一个元素、随机找一个元素</li><li>anyMatch &#x2F; noneMatch 是否有匹配的元素、没有匹配的元素</li><li><strong>collect</strong> 等</li></ul><p>从方法名中我们就能了解它的用处，更为详细的 API 操作可以查看 Stream 源代码。</p><h2 id="Collector-操作"><a href="#Collector-操作" class="headerlink" title="Collector 操作"></a>Collector 操作</h2><p>Collector 操作是 Stream 中最强大的操作，他就是我们上面例子中提到的「篮子」「箱子」等。它具有以下 API</p><ul><li>toSet &#x2F; toList &#x2F; toCollection</li><li>joining()</li><li>toMap()</li><li>groupingBy()</li></ul><p>通过这些 API 操作，使得我们能将流中的元素收集起来</p><p>下面通过一些实际案例，加深对 Stream 的理解。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        User(String name, <span class="hljs-type">int</span> age) &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有个需求<strong>筛选出年龄大于等于60的用户，然后将他们按照年龄从大到小排序，将他们的名字放在一个LinkedList中返回</strong>。我们可以使用 Stream 写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LinkedList&lt;String&gt; <span class="hljs-title function_">collectNames</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>       <span class="hljs-keyword">return</span> users.stream()<br>               .filter(user -&gt; user.age &gt;= <span class="hljs-number">60</span>)<br>               .sorted(comparing(User::getAge).reversed())<br>               .map(user -&gt; user.name)<br>               .collect(toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><p>解析：要使用 Stream 首先就需要创建它<code>users.stream()</code>，根据要求筛选出年龄大于 60 的用户 <code>filter(user -&gt; user.age &gt;= 60)</code>，然后使用 sorted 对筛选后的用户按照年龄排序。由于我们要返回的是一个字符串列表<code>LinkedList&lt;String&gt;</code>，而我们 Stream 中的元素都是对象类型，因此我们使用 <code>map(user -&gt; user.name)</code>，把User 映射成 String 类型，这样 Stream 中的元素都是用户的名字了。最后，使用 collect 操作将用户的名字收集成一个 Linked ，这样就解决了我们的需求。</p><p>通俗解释：我们作为老板，我们要创建一条流水线，然后安排工人在流水线旁边进行操作。安排员工老赵把用了60年以上的产品，筛选出来。筛选完后，安排老周按使用时长进行从大到小排序。排序之后，安排老王把可用的零件拆下来，最后用一个篮子收集这些可用的零件。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>统计一个给定的字符串中，大写英文字母（A,B,C,…,Z）出现的次数</strong>。例如，给定字符串”AaBbCc1234ABC”，返回6，因为该字符串中出现了6次大写英文字母 ABCABC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUpperCaseLetters</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) str.chars()<br>            .filter(Character::isUpperCase)<br>            .count();<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：String 类型创建流 <code>str.chars()</code>，然后使用 filter 进行过滤操作，过滤出大写字母 <code>filter(Character::isUpperCase)</code>，接着对过滤出的字母进行统计，完成需求。</p><p>更多关于 Stream 操作 demo点击<a href="https://github.com/greek-zzf/my-demo/tree/main/example/Stream%20%E7%BB%83%E4%B9%A0">这里</a></p><h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>可以通过并发提高<strong>互相独立操作</strong>的性能。</p><p><strong>互相独立操作</strong>指的就是，操作相互之间不影响。例：1个人割麦子需要10天，那10个人割相同面积的麦子就只需要1天。</p><p><strong>非互相独立操作</strong>就像女人生孩子，1个女人十10个月生1个孩子，但是10个女人并不是一个月就能把孩子生出来。</p><p>在正确使用的前提下，可以获得近似线性的性能提升。要使用并发流我们可以使用 <code>parallelStream()</code>创建并发流。或者在原有流的基础上，使用 <code>parallel()</code> 方法将流转化为并发流。</p><p>使用一个简单的案例来使用并发流，统计 1 到 100万之间的质数个数 。原始的 Stream 写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).filter(是否为质数).count()<br></code></pre></td></tr></table></figure><p>并发流写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).parallel().filter(isPrime).count();<br></code></pre></td></tr></table></figure><p>因为统计个数属于互相独立操作，就像两个人数羊群有多少只绵羊一样，两人分别数自己区域的羊，然后再加起来汇总。</p><p>对于并发流来说，使⽤要⼩⼼，性能要测试，如果你不知道⾃⼰在做什 么，就忘了它吧。对于详细的操作可以参考<a href="https://book.douban.com/subject/30412517/">《Effective Java 第三版》</a>42-48节。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-年终总结（技术向）</title>
    <link href="/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/"/>
    <url>/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。</p><h3 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h3><ul><li>Maven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。</li><li>学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。</li><li>了解 Jenkis 自动化部署的流程，能够进行简单的构建。</li><li>学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。</li><li>编写了自己的自动化脚本，自动拉取代码打包，运行项目。</li><li>会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。</li><li>学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）</li><li>深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。</li><li>了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。</li><li>熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。</li><li>写了一个简单的新浪新闻爬虫。</li><li>GitHub 也开始有绿点了，尽管不多，但也是个很好的开始。</li></ul><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/a2f75394-0052-49aa-8e37-a56774bf8a47.png" alt="image.png"></p><ul><li>帮助开源项目 <a href="https://github.com/ByteLegend/ByteLegend">https://github.com/ByteLegend/ByteLegend</a>，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。</li><li>了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。</li></ul><h3 id="知识获取渠道推荐："><a href="#知识获取渠道推荐：" class="headerlink" title="知识获取渠道推荐："></a>知识获取渠道推荐：</h3><ul><li>正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 <a href="https://fsou.cc/">https://fsou.cc/</a>，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。</li><li>取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。</li><li>论坛：<ul><li><a href="https://v2ex.com/">V站</a> 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。</li><li>HackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。</li><li>GitHub 全球最大的同性交友平台（手动滑稽）</li><li>CoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。</li><li>[<a href="https://nipafx.dev/]">https://nipafx.dev/]</a>(You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。</li></ul></li><li>许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。</li><li>了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是<strong>无所不知</strong>)、陈皓（Collshell 作者）</li></ul><h3 id="2022-的一些目标"><a href="#2022-的一些目标" class="headerlink" title="2022 的一些目标"></a>2022 的一些目标</h3><ul><li>工作顺利、生活愉快。</li><li>去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》</li><li>参与到更多开源项目中去、GitHub 绿点也可以多一些。</li><li>保持自己的好奇心、做自己想做的事。</li></ul>]]></content>
    
    
    <categories>
      
      <category>年终总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？</p></blockquote><p>我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。</p><p>上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。</p><p>对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></blockquote><p>简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。</p><p><strong>二进制向量</strong>就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。</p><p>下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/54a416e0-66c1-4893-aade-ede8e001bd04.png" alt="1.png"></p><p><strong>映射函数</strong>我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。</p><p>布隆过滤器对一个 key 使用多个映射函数，得到多个值。</p><p>哈希函数映射</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/63b9a80b-0cd5-48ea-ac54-a93256a7caf7.png" alt="hash.png"></p><p>布隆过滤器中映射函数</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/51445b83-d4a0-497f-8ebb-5f0fb9ddcc76.png" alt="bloomfilter.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解一些基本概念之后，布隆过滤器的原理就很明了了。</p><p>布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。</p><p>例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/ccf230bf-6de4-49ab-8238-c9387cad586d.png" alt="insert.png"></p><p>我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。</p><p>如果是，则该元素<strong>可能</strong>在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。</p><p>如果不是，则表示该元素一定不在集合中。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。</p><h3 id="误识别率"><a href="#误识别率" class="headerlink" title="误识别率"></a>误识别率</h3><p>插入字符串 “zzh” 得到下标 2、7、11</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8b034b8d-b422-4dfc-a270-10c65db5d255.png" alt="insert.png"></p><p>插入字符串 “greek” 得到下标 5、8、9</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4bc4c95c-abee-4c20-9d5e-cf66a4b02cd5.png" alt="insert_greek.png"></p><p>插入字符串 “gem” 得到下标 2、5、8</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/66253d9d-d8ac-4783-9ba3-a3f954bfb9fa.png" alt="insert_gem.png"></p><p>可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。</p><h3 id="删除困难"><a href="#删除困难" class="headerlink" title="删除困难"></a>删除困难</h3><p>删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。</p><p>我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。</p><h3 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h3><p>识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。</p><p>假设在布隆过滤器里面有 <em>k</em> 个映射函数, <em>m</em> 个比特, 以及 <em>n</em> 个已插入元素，那么该过滤器误判率近似于：_(1-e-kn&#x2F;m)k_ 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。</p><p>对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情<a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/#footnote2">点击</a></p><blockquote><p>对于给定的 <em>m</em> 和 <em>n</em> ，有一个函数可以帮我们确定最优的 <em>k</em> 值: <em>(m&#x2F;n)ln(2)</em></p><p>所以可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的_n_, <em>m</em>, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束</li></ol></blockquote><p>事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">wiki</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>查询效率和插入效率高</strong>，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。</p><p><strong>空间效率</strong>。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。</p><p>假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。</p><p>一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 提交作业</title>
    <link href="/2021/12/24/GitHub%20%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/"/>
    <url>/2021/12/24/GitHub%20%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>使用一个工具的时候，应该先要问自己他是什么，他有什么作用？所以先根据这两个来初步了解下 Git 和 GitHub。</p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>GitHub 简单来说就是一个<code>代码仓库</code>，里面存放着世界各地程序员写的代码，我们也可以在 GitHub 上注册自己的账号，拥有自己的代码仓库。我们可以往自己的仓库提交代码，也可以去看一些大牛的仓库，学习他们的编码技巧，倘若发现一些小 Bug，我们也可以帮助别人解决，贡献一份力量。</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>想一个问题：我们已经有了自己的代码仓库 GitHub，那么我们该怎么把自己电脑上的代码放到 GitHub 中去呢？</p><p>解决这个问题的办法有：我们打开 GitHub ，在自己的代码仓库点击上传文件，这样就可以上传自己的代码。但是这样上传速度慢，而且容错性较差，可能遇到提交错误的代码，导致无法回到上一版本。</p><p><code>Git</code> 最大的用处，应该就是版本控制。可以记录你提交记录与版本，相当于「后悔药」，也支持多人协作，每个人的代码提交记录都会保存，所做的修改也有记录，这就是 <code>Git</code> 的好处。</p><h1 id="修改别人的代码"><a href="#修改别人的代码" class="headerlink" title="修改别人的代码"></a>修改别人的代码</h1><p>这是一次在 GitHub 上完成提交的经历，整个过程如下：</p><h2 id="一、Fork-别人的代码"><a href="#一、Fork-别人的代码" class="headerlink" title="一、Fork 别人的代码"></a>一、<code>Fork</code> 别人的代码</h2><p>首先，找到你要修改的仓库地址。因为是别人的代码，你没办法直接 「clone」复制下来，修改并提交，除非仓库的主人你认识，并且赋予了你修改的权限。既然没有直接的修改权限，那么我们就要 <code>Fork</code> 一份代码。<code>Fork</code> 的意思是：<strong>把当前仓库，拷贝到自己的 GitHub。</strong><code>Fork</code> 的结果就是你的 GitHub 中多了一个一模一样的仓库。<code>Fork</code> 操作如图：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/cb59b504-916e-4f55-af84-6dc15999ca16.png" alt="image.png"><br>图中的 <code>Fork</code> 结果，在我的 GitHub 中多了一个「JavaCollection」的仓库，代码也和拷贝过来的一模一样。</p><h2 id="二、Clone-代码，并在本地进行修改"><a href="#二、Clone-代码，并在本地进行修改" class="headerlink" title="二、Clone 代码，并在本地进行修改"></a>二、<code>Clone</code> 代码，并在本地进行修改</h2><p>Clone 代码就相对简单很多了，找到 Fork 之后的仓库。我这边对应的就是我 GitHub 中的「JavaCollection」仓库，打开，并点击「code」，弹框选择 「HTTPS」,复制 「HTTPS」下面的地址。需要说明一点：如果你对 「SSH」和「GitHub CLI」不熟悉，就老老实实选择「HTTPS」。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/d3c61600-7248-4c10-be02-f8bb0a09b2f0.png" alt="image.png"></p><p>复制好地址之后，打开<strong>开发者工具</strong>，此处以 IDEA 举例。打开 IDEA，并在首页点击 <code>Get from Version Control</code> ，不同的 IDEA 版本可能名称不一样。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/3b5b086c-ccd2-4dc9-8870-53f0888ae0f9.png" alt="image.png"></p><p>在弹出的对话框中，选择在 <code>Version control</code> 选择 Git，并在 <code>Url</code> 一栏粘贴刚才复制的地址，再点击 <code>Clone</code> 即可</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/94d71270-bf17-4655-82c8-e34d275a0a9c.png" alt="image.png"></p><p>点击 Clone 之后，IDEA 会自动帮你把代码拷贝到本地，拷贝完成之后 IDEA 提示你「是否需要打开它」，选择「Yes」，等待一会，就可以对代码就行操作了。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/e55425a2-2f40-407f-8d8e-c1f85262010b.png" alt="image.png"></p><h2 id="三、Commit-代码，并-Push-本地代码到-GitHub"><a href="#三、Commit-代码，并-Push-本地代码到-GitHub" class="headerlink" title="三、Commit 代码，并 Push 本地代码到 GitHub"></a>三、<code>Commit</code> 代码，并 <code>Push</code> 本地代码到 <code>GitHub</code></h2><p>点击 IDEA 左下角的 Version Control，可看到修改的文件详情，在需要提交的文件处右键，然后点击 <code>Commit</code> ，代码就会先提交到本地仓库</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/64deed58-e000-482f-a9a7-4a34f2a7ccb7.png" alt="image.png"></p><p><code>Commit</code> 代码之后，接下来就要进行 <code>Push</code> 操作，在 IDEA 工具栏中找到「VCS」「Git」「Push」，就可以把本地代码提交到自己的 GitHub 中。接下来可以在 GitHub 中找到对应的代码仓库，查看刚才提交 <code>Push</code> 的结果。</p><h2 id="四、发起-Pull-requests"><a href="#四、发起-Pull-requests" class="headerlink" title="四、发起 Pull requests"></a>四、发起 <code>Pull requests</code></h2><p>在 GitHub 点击上传代码的仓库，就可以看到 <code>Pull requests</code> ，点击它，然后选择要提交的分支，以及他人仓库的分支，点击完成就可以了。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/269c3072-c82c-4bf3-8981-dc5abe3189e8.png" alt="image.png"><br>发起 <code>Pull requests</code> 之后只需要等待开发者查看你的 <code>PR</code>，根据情况判断是否需要，如果通过了，恭喜你成功贡献了一份力量，没有通过也不用气馁，可以看看不通过的原因什么，下次继续努力。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective Java》- Object 通用方法</title>
    <link href="/2021/12/16/%E3%80%8AEffective%20Java%E3%80%8B%20-%20Object%20%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/12/16/%E3%80%8AEffective%20Java%E3%80%8B%20-%20Object%20%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在日常 coding 中，我们会经常使用或者覆盖 Object 对象中的方法，如：equals、toString、hashcode 等。除此之外，还有 clone、finalize 方法。限于作者实力，很少用到这两个方法，即使看过原书也是一知半解，因此不敢用来「忽悠」别人。因此，这篇文章只对 equals、toString、hashCode、compareTo（该方法并非 Object 的方法）进行讲解。</p><blockquote><p>强烈推荐去看原书《Effective Java》，Java 程序员不能没有这本书，就像西方不能没有耶路撒冷。</p></blockquote><h2 id="equals-覆盖最佳实践"><a href="#equals-覆盖最佳实践" class="headerlink" title="equals 覆盖最佳实践"></a>equals 覆盖最佳实践</h2><p>equals 方法对于刚入行的人既熟悉又陌生。给人的感觉是知道这个方法，但是在实际工作中从来没有用过。虽然我也用的很少，但还是知道它的用处，以及在日常业务代码中的一些技巧，作用。</p><h3 id="equals-作用"><a href="#equals-作用" class="headerlink" title="equals 作用"></a>equals 作用</h3><p>一句话概述：<strong>比较两个对象是否相等</strong>。仅仅是比较对象是否相等，好像不值得拿出来一说。因为是 Object 的方法，因此所有的类都可以重写这个 equals 方法，满足不同类的需求，以及和 Java 中的集合类搭配使用，会产生不一样的化学反应（后面会具体描述）。</p><h3 id="业务场景与-equals-产生的化学反应"><a href="#业务场景与-equals-产生的化学反应" class="headerlink" title="业务场景与 equals 产生的化学反应"></a>业务场景与 equals 产生的化学反应</h3><blockquote><p>假设老板给你提这样一个需求：在一组用户数据中，筛选出每个省份，年龄不重复用户数据。例如不能包含两条籍贯江西，年龄一岁的用户</p></blockquote><p>你可能会想到，每次往筛选好的集合中添加数据，都要进行判断，插入的数据在集合是否有重复，这样就写成了一个双重 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;User&gt; noDuplicatedUserList, List&lt;User&gt; allUserList)</span> &#123;<br>       <span class="hljs-keyword">for</span> (User user1 : allUserList) &#123;<br>           <span class="hljs-keyword">for</span> (User user2 : noDuplicatedUserList) &#123;<br>               <span class="hljs-keyword">if</span> (user1.getHome.equals(user2.getHome) &amp;&amp; user1.getAge().equals(user2.getAge())) &#123;<br>                   <span class="hljs-keyword">continue</span>;<br>               &#125;<br>               noDuplicatedUserList.add(user1);<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>    <span class="hljs-keyword">return</span> noDuplicatedUserList;<br>   &#125;<br></code></pre></td></tr></table></figure><p>任务当然可以完成，但是你掌握一些 equals 的用法后，你就可以开始玩一些「骚操作」了。</p><p>我们开始覆盖 User 类的 equals 方法，使得这个行为变得更简单，equals 覆盖后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;User&gt; noDuplicatedUserList, List&lt;User&gt; allUserList)</span> &#123;<br>       <span class="hljs-keyword">for</span> (User user : allUserList) &#123;<br>           <span class="hljs-keyword">if</span>(!noDuplicatedUserList.contains(user))&#123;<br>           noDuplicatedUserList.add(user);<br>           &#125;;<br>       &#125;<br>    <span class="hljs-keyword">return</span> noDuplicatedUserList;<br>   &#125;<br></code></pre></td></tr></table></figure><p>是的，重写完 equals 之后，只需要使用 <code>contains</code>判断两个对象是否相等即可，因为 <code>contains</code>方法内部使用的就是对象的 equals 方法。</p><p>你还可以将代码更简化，让他返回一个去重的 HashSet 即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Set <span class="hljs-title function_">filter</span><span class="hljs-params">(List&lt;User&gt; allUserList)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(allUserList);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="覆盖-equals-注意事项"><a href="#覆盖-equals-注意事项" class="headerlink" title="覆盖 equals 注意事项"></a>覆盖 equals 注意事项</h3><p>覆盖 equals 能帮我们解决问题，但必须使用得当，如果覆盖的 equals 方法，没有遵守相关约定，那么你的程序必然会在一些类的使用上出现 bug。出现 bug 一点都不可怕，可怕的是你不知道 bug 出现在哪，检查代码也发现不了错误，到头来才发现原来是这个不起眼的 equals 导致的。</p><ul><li><p>自反性：对于任何非 null 的引用值 x，x.equals(x) 必须返回 true。</p></li><li><p>对称性：对于任何非 null 的引用值 x，x.equals(y) 返回 true，y.equals(x) 也必须返回 true。</p></li><li><p>传递性：对于任何非 null 的引用值 x，y，z，x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 必须返回 true。</p></li><li><p>一致性：如果两个对象相等，在没有改变对象的前提下，他们就始终相等。</p></li><li><p>非空性：所有的对象都不能等于 null，x.equals(null)，因此在一些 equals 方法中都会进行 null 检查，如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(o == <span class="hljs-literal">null</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这些规定，你可能头都炸了，我就写个 equals 还要遵守这么多约定，我还不如直接使用第一种方法呢。别急，往下看，最佳实践有人已经帮你总结出来了。</p><h3 id="覆盖-equals-最佳实践"><a href="#覆盖-equals-最佳实践" class="headerlink" title="覆盖 equals 最佳实践"></a>覆盖 equals 最佳实践</h3><p>了解 equals 的注意事项后，以下经验就能帮助我们优雅地，高质量地覆盖 equals。拿上面的 User 来举例说明，步骤如下。</p><p><strong>步骤一</strong>：使用 &#x3D;&#x3D; 操作检查对象是否相等，如果是，返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(obj == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>步骤二</strong>：使用 instanceof 操作符检查「参数是否为正确类型」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> User))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：把参数转化成正确的类型（需要先通过步骤二的检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) obj;<br></code></pre></td></tr></table></figure><p><strong>步骤四</strong>：比较参数中的字段与该对象的字段，匹配返回 true，不匹配返回 false;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(user.getHome().equals(home) &amp;&amp; user.getAge.equals(age))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p><strong>完整的 equals 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br><span class="hljs-keyword">if</span>(obj == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> User))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <br><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) obj;<br><span class="hljs-keyword">if</span>(user.getHome().equals(home) &amp;&amp; user.getAge.equals(age))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>这样就写完了一个高质量的 equals 方法。但是还需要注意的是，覆盖 equals 方法，必须也覆盖 hashCode 方法（原因见下一节）。equals 的参数是 Object 对象，而不是具体的某个类，因为前者才是覆盖了 equals 方法，后者只是类中的一个普通方法。</p><h2 id="hashCode-覆盖最佳实践"><a href="#hashCode-覆盖最佳实践" class="headerlink" title="hashCode 覆盖最佳实践"></a>hashCode 覆盖最佳实践</h2><h3 id="覆盖-equals-为什么一定要覆盖-hashCode"><a href="#覆盖-equals-为什么一定要覆盖-hashCode" class="headerlink" title="覆盖 equals 为什么一定要覆盖 hashCode"></a>覆盖 equals 为什么一定要覆盖 hashCode</h3><p>回答这个问题很简单，其实就是违反了 hashCode 的约定：<strong>两个对象相等，则必须返回相同的 hashCode</strong>。</p><p>由于覆盖了类的 equals 方法，导致对象相等的逻辑发生了改变，而类的 hashCode 方法还是使用的 Object 提供的方法，就会导致相同的对象返回不同的 hashCode。</p><p>你可能觉得 hashCode 不同就不同嘛，但是你也就此失去了使用 HashMap，HashSet 等集合类的权利，强行使用会给你的代码带来未知的 bug，因为这些类都是根据 hashCode 约定来实现的。</p><p>我们可以通过一个例子演示该行为带来的问题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;User, String&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>m.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;江西&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>), <span class="hljs-string">&quot;渣渣辉&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们向 HashMap 插入了一条数据，你可能期望 <code>m.get(new User(&quot;江西&quot;，&quot;18&quot;))</code>会返回「渣渣辉」，但很可惜并不是，而是返回 null。</p><p>这是因为，虽然是两个是相同的对象，但是没有覆盖 hashCode 方法，导致存进 map 的对象的 hashcode 和 取值对象 hashcode 不一样，因此就会取不到对应的 value。</p><h3 id="覆盖-hashCode-方法"><a href="#覆盖-hashCode-方法" class="headerlink" title="覆盖 hashCode 方法"></a>覆盖 hashCode 方法</h3><p><strong>计算 hashCode</strong> </p><ol><li>我们在方法中初始化变量 result，并让他的值等于第一个需要计算字段的值。</li><li>如果字段是基本类型，我们就使用它的装箱基本类型的 hashCode 方法，计算该字段的 hashcode。</li><li>如果是对象，并且类的 equals 方法调用了该对象的 equals 方法进行比较，则我们也需要在类的 hashCode 方法中递归地调用该对象的 hashCode 方法。</li><li>如果是数组，则需要对数组中的重要元素使用上诉的方法计算 hashCode。如果所有元素都很重要，则可以使用 Arrays.hashCode 方法</li></ol><p><strong>合并返回 hashCode</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">result = <span class="hljs-number">31</span> * result + c;  <span class="hljs-comment">// 其中 C 为单个字段的 hashCode 值</span><br></code></pre></td></tr></table></figure><p>这里估计你又会好奇，为什么是要乘 31。首先 31 是一个奇素数，如果是偶数的话并且乘法导致数据溢出，就会产生信息丢失。31 有个很好的特性，可以使用移位和减法来代替乘法，可以获得更好的性能，如：<code>31 * i == (i &lt;&lt; 5) - i</code>。</p><p>我们把上述实践运用到 User 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> String.hashCode(home);<br>    result = <span class="hljs-number">31</span> * result + String.hashCode(age);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写算是比较高效的合理的覆盖，有时我们需要让 hashCode 值尽可能地不会造成冲突，我们可以使用 Guava 包下得 Hashing。如果对性能没有该要求可以使用 Objects 提供的静态 hash 方法 <code>Objects.hash(home, age);</code>。</p><p>如果是一个不可变类，且每次计算 hashCode 的开销比较大，我们可以把 hashCode 值保存到对象内部，这样下次计算 hashCode 时可以直接把保存的 hashCode 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashCode;<br>    <br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> hashCode;<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 执行相应的 hashCode 计算操作</span><br>            hashCode = result; <span class="hljs-comment">// 计算完成记得赋值保存</span><br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优雅地覆盖-toString"><a href="#优雅地覆盖-toString" class="headerlink" title="优雅地覆盖 toString"></a>优雅地覆盖 toString</h2><p>我们在开发中，使用打印语句打印对象，或者在 debug 中查看对象的信息，经常能看到如下形式：<code>User@1b456</code> 。上诉这些行为都默认的调用了对象的 toString 方法，如果类本身没有覆盖 toString 的话，则会调用 Object 的 toString 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br> &#125;<br></code></pre></td></tr></table></figure><p>从打印的对象信息来看，给我们的开发调试，提供不了任何有用的信息，因此覆盖 toString 旨在提供更多有效的信息，而不是那一串干巴巴的 <code>User@1b456</code>。</p><p>在 toString 方法中应该包含一些与类相关的信息。例如 User 类，可以返回 <code> User=&#123;&quot;江西&quot;, &quot;18&quot;&#125;</code>，这样清晰明了，比 <code>User@1b456</code> 不知好了多少。当 toString 生成的格式没有那么清晰时，就应该考虑在 javadoc 中添加格式说明，让这一过程容易被调用者接收。</p><blockquote><p>tips: 应该在抽象类中编写 toString 方法，让他的子类享有公共的 toString 方法。大多数集合类就是如此，例如：ArrayList 使用的就是 AbstractCollection 的 toString 方法。</p></blockquote><p>总而言之：如果 toString 能够为你的开发和调试等带来美观的格式，返回对象简明有用的描述，那你就应该毫不犹豫的覆盖它。</p><h2 id="优雅地实现-Comparable-接口"><a href="#优雅地实现-Comparable-接口" class="headerlink" title="优雅地实现 Comparable 接口"></a>优雅地实现 Comparable 接口</h2><p>虽然这博客说的是 Object 通用方法，但是必须说明的是 compareTo 并不是 Object 中的方法，而是 Comparable 接口的唯一方法。因为该方法很重要，且使用频率很高，所以就放在一起介绍。实现了 Comparable 接口的类，就表明该类有内在的排序关系，当然这个排序肯定是自己定义的。</p><p>java 中的有序集合类会根据其中元素类的 compareTo 方法，将内部的元素进行排序。例如：TreeSet、TreeMap 等。</p><h3 id="撞脸-equals"><a href="#撞脸-equals" class="headerlink" title="撞脸 equals"></a>撞脸 equals</h3><p>compareTo 方法在官方文档的说明如下：</p><blockquote><p>将此对象与指定对象进行比较。当该对象小于、等于、大于指定对象的时候、分别返回一个负整数、零或者正整数。如果由于指定的对象类型与该对象类型不一致、则会抛出 ClassCastExcetion 异常。</p></blockquote><p>除了上诉说明，compareTo 方法还必须遵守和 equals 类似的约定：</p><ul><li><p>sgn(x.compareTo(y)) &#x3D;&#x3D; -sgn(y.compareTo(x))，其中 sgn 是根据表达式的值为负数、正数、零，分别返回 -1、1、0。上面那个公式翻译过来就是：如果 x 大于等于 y，则 y 一定小于或等于 x，并且暗示着后者抛出异常时，前者也必定抛出异常。反之亦然。</p></li><li><p>可传递性：如果 x 大于 y，并且 y 大于 z，则 x 必须大于 z。反之亦然。</p></li><li><p>如果 x.compare(y) &#x3D;&#x3D; 0，则 sgn(x.compare(z)) 等于 sgn(y.compare(z))。</p></li><li><p>强烈建议，但非必要。(x.compareTo(y) 等于 (x.equals(y))。</p></li></ul><p>相信看完 equals 的约定，遵守这些约定对你来说应该是小菜一碟了。遵守这些约定，就能安全的使用有序集合类，以及包含搜索和排序算法的工具类。</p><h3 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="与 equals 的区别"></a>与 equals 的区别</h3><p>上面提到的强烈建议，与 equals 保持同等性。即当 compareTo 比较两个对象相等时， 两个对象进行 equals  方法比较也应该相等。</p><blockquote><p>如果违反这条建议，那么它的顺序就与 equals 不一致。如果一个类的 compareTo 方法强加了一个与 equals 不一致的顺序，那么这个类仍然可以工作，但是包含该类元素的有序集合可能无法遵守集合接口（Collection、Set 或 Map）的一般约定。这是因为这些接口的一般约定是根据 equals 方法定义的，但是有序集合使用 compareTo 代替了 equals 实施同等性检验。</p></blockquote><p>以下例子可以很好的解释。</p><p>Java 中的 BigDecimal 类，它的 compareTo 方法与 equals 不一致（没有遵守上述的建议）。如果你创建一个空的 HashSet 实例，然后添加 new BigDecimal(“1.0”) 和 new BigDecimal(“1.00”)，那么该 HashSet 将包含两个元素，因为添加到该集合的两个 BigDecimal 实例在使用 equals 方法进行比较时结果是不相等的。但是，如果你使用 TreeSet 而不是 HashSet 执行相同的过程，那么该集合将只包含一个元素，因为使用 compareTo 方法比较两个 BigDecimal 实例时结果是相等的。</p><p>因此，在使用具有排序功能的集合类时，需要特别注意 compareTo 和 equals 实现，防止引入 bug 。</p><h3 id="编写-comparaTo-方法"><a href="#编写-comparaTo-方法" class="headerlink" title="编写 comparaTo 方法"></a>编写 comparaTo 方法</h3><p>应该杜绝使用关系运算符 “&gt;” 和 “&lt;” 来表示大小关系，推荐使用包装类型提供的 compareTo 方法，来比较值。假设用户的年龄值为 int 类型，比较年龄可以使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age &gt; user.getAge())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(age &lt; user.getAge())&#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的写法也能达到比较的目的，但是很容易出错，而且需要比较的字段一多整个逻辑就很复杂。所有的装箱类型在 java7 中已经提供了静态的 compare 方法，并且也都实现了 comparable 接口。</p><blockquote><p>我们给 User 类添加一个字段 name，然后对他进行排序，先比较年龄，然后根据姓名进行排序</p></blockquote><p>使用包装类型的 compareTo 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> age.compareTo(user.getAge);<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>        result = name.compareTo(user.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用包装类型的静态 compare 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.compare(age, user.getAge);<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>        result = String.compare(name, user.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 java 8中，Comparator 接口配置了一组比较器构造方法，使得构造比较器非常简单，并且代码的可读性非常高。还是上面的示例，我们为 User 类编写一个比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;User&gt; COMPARATOR = <br>    comparingInt(User::getAge)<br>.thenComparing(User::getName);<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User user)</span>&#123;<br>   <span class="hljs-keyword">return</span> COMPARATOR.compare(<span class="hljs-built_in">this</span>, user);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码为 User 类编写了一个比较器，先比较年龄，然后比较名字。定义好比较器后，就直接在 User 的compareTo 方法使用即可。comparingInt 对应比较 int 类型，相似的也有 comparingLong_、和 _comparingDouble等。</p><p><strong>一个错误地实践</strong>，有时我们会把比较结果的正负来判断大小，我们就很容易偷懒写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> value1, <span class="hljs-type">int</span> value2)</span>&#123;<br><span class="hljs-keyword">return</span> value1 - value2;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用它的比较结果，来判断是正还是负，以此来判断 value1 和 value2 的大小关系,但是我们却没有考虑过整数溢出的情况。因为 int 类型最大，最小能表示正负21 亿左右的数字，假如 value1 是 int 类型最小值，value2 是正数，两者相减就会导致整数越界。因此使用官方为我们提供的比较方法 <code>Integer.compare(value1, value2)</code>，更为安全实用。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Effective Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 基础</title>
    <link href="/2021/12/08/Docker%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/08/Docker%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>软件的依赖，开发环境不确定性，导致部署软件项目是一件令人头疼的事。</p><p>虚拟机解决了这个问题，但是太吃内存，很耗资源。 Docker 使用了一个轻量的虚拟机。</p><p><strong>优点</strong></p><ul><li>保证开发、测试、交付、部署的环境完全一致</li><li>保证资源的隔离</li><li>启动临时的、用完即丢弃的环境，例如测试</li><li>迅速（秒级）扩容</li></ul><h2 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h2><p>docker 可以类比装系统，换系统操作。有了这个前置知识，对于 docker 的一系列知识会更容易理解。</p><h3 id="镜像-images-与容器-container"><a href="#镜像-images-与容器-container" class="headerlink" title="镜像 (images) 与容器 (container)"></a>镜像 (images) 与容器 (container)</h3><p>镜像就和电脑镜像是一样的，而容器对应的就是电脑。电脑和电脑之间是相互隔离的（A 电脑数据无法与其他电脑共享，除非使用特殊手段），容器之间也是如此。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>pull</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 镜像:镜像版本 <br></code></pre></td></tr></table></figure><p>从 docker 官方拉取镜像，镜像版本不指定默认下载 Latest 版本。镜像地址不指定默认从 Docker 官方仓库下载。</p><p><strong>images</strong> 查看所有下载的 docker 镜像</p><p><strong>run</strong> 运行容器</p><ul><li>–name 为将要启动的容器起一个名字，在引用容器 id 的时候可以替换成容器 name</li><li>–restart&#x3D;always 遇到错误自动重启</li><li>-p 与宿主机（自己的电脑）</li><li>-v &lt;本地文件&gt;:&lt;容器文件&gt; 与宿主机进行文件映射，使得容器内部和宿主机共享同一份文件</li><li>-p &lt;本地端口&gt;:&lt;容器端口&gt; 将本地端口映射到 docker 容器内部</li><li>-e  <NAME>&#x3D;<VALUE>  启动容器时传递的环境变量，使得容器在初始化时可以使用这些变量</li></ul><p><strong>rm</strong> 删除容器</p><p><strong>start&#x2F;stop&#x2F;restart</strong> 启动&#x2F;停止&#x2F;重启一个容器</p><p><strong>exec</strong> 访问容器，进入容器内部</p><p><strong>logs</strong> 容器id 查看容器日志</p><p><strong>inspect</strong> 容器id 查看当前容器的状态信息</p><p><strong>tag</strong> 镜像id 给镜像取名字</p><h2 id="创建自己的镜像"><a href="#创建自己的镜像" class="headerlink" title="创建自己的镜像"></a>创建自己的镜像</h2><p>我们可以很方便的从 Docker 官方拉取镜像，就像我们可以很方便的去网上找到 win10 镜像一样。但是，Docker 镜像并不能完全满足你的需求，所以就需要我们自己制作一个镜像。</p><p>在开始制作镜像之前，需要知道镜像内部都是分层的，我们来看一个 Redis 的 Dockerfile 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM debian:buster-slim<br><br>RUN groupadd -r -g 999 redis &amp;&amp; useradd -r -g redis -u 999 redis<br><br>ENV GOSU_VERSION 1.12<br>RUN .... // 一系列命令（此处已省略）<br><br>ENV REDIS_VERSION 6.2.5<br>ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-6.2.5.tar.gz<br>ENV REDIS_DOWNLOAD_SHA 4b9a75709a1b74b3785e20a6c158cab94cf52298aa381eea947a678a60d551ae<br><br>RUN .... // 一系列命令（此处已省略）<br><br>RUN mkdir /data &amp;&amp; chown redis:redis /data<br>VOLUME /data<br>WORKDIR /data<br><br>COPY docker-entrypoint.sh /usr/local/bin/<br>ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]<br><br>EXPOSE 6379<br>CMD [&quot;redis-server&quot;]<br></code></pre></td></tr></table></figure><p>上面的代码都很简单</p><ul><li>使用 FROM 指定基础镜像（当多个镜像指定同一个基础镜像时，就不需要重复下载）</li><li>RUN 后面跟一系列需要执行的命令</li><li>ENV 配置环境变量</li><li>VOLUME 创建可持久化目录</li><li>WORKDIR 指定了工作目录</li><li>ENTRYPOINT 为容器提供命令和参数</li><li>EXPOSE 对外暴露的端口</li><li>CMD 容器启动之后执行的命令</li></ul><p>可以看到镜像的制作都是一步一步来的，就好像你跟一个智能机器人说，我要 debian，然后帮我运行一些命令，帮我设置一个工作目录，帮我暴露一个对外端口等等，你只需要用机器人能听懂的语言跟它说，他就会按照你的要求去执行相应步骤。</p><p>Dockerfile 文件创建好之后，我们就需要把它构建成一个镜像文件。只需要使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build &lt;dockerfile 所在目录&gt;<br></code></pre></td></tr></table></figure><p>等待 Docker 帮你构建完成，接下来你就可以同其他镜像一样使用自己的镜像。</p><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><p>可以通过上面的步骤，自己编写了一个 Dockerfile，并且使用该文件构建一个镜像。如图：<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Docker%E5%9F%BA%E7%A1%80/cb2c1d1e-f3d5-4401-a041-d0af4089e3a5.png" alt="image.png"></p><p>由于新构建的镜像是没有名字的，为了方便后续使用我们可以给它取个名字。我们可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag cf6ef720090d zzf:1.0.0<br></code></pre></td></tr></table></figure><p>再次查看我们的镜像<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Docker%E5%9F%BA%E7%A1%80/a07b120e-37c5-4ddf-84ad-444a6622e869.png" alt="image.png"></p><p>可以看到 <code>REPOSITORY</code> 那一栏名字变成了 <code>zzf</code>，<code>TAG</code>栏也变成了 <code>1.0.0</code>。需要特别声明的是，<code>REPOSITORY</code>那一栏的名称，定义了镜像的 push 和 pull 地址，由于我们命令为 <code>zzf</code>，并没有给镜像设置地址，因此当我们 push 的时候，docker 会使用默认的 docker 官方仓库的地址，如图：<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Docker%E5%9F%BA%E7%A1%80/c7b36c39-9367-4528-ab5e-0088e06224c2.png" alt="image.png"></p><p>为了发布到自己的 docker 仓库中去，我们需要注册一个 Docker 账号。然后把我们的镜像名称改成如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag cf6ef720090d wszzh/zzf:latest<br></code></pre></td></tr></table></figure><p>只需要在镜像名前加上 docker 用户名加 <code>/</code>，即可。这样使用 docker push 命令就能推送到我们的仓库，如图：<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Docker%E5%9F%BA%E7%A1%80/0011501c-d73f-4819-b9a1-2409b4de1e51.png" alt="image.png"><br>这样就推送成功，我们可以登录自己的 Docker 账户查看该镜像。需要使用的时候只需要使用如下命令即可拉取我们自己的镜像，如果有多个版本，则需要在镜像地址后面加冒号跟上对应的版本号即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull wszzh/zzf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 代码插件</title>
    <link href="/2021/11/01/Maven%20%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/11/01/Maven%20%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="代码规范检查工具-CheckStyle"><a href="#代码规范检查工具-CheckStyle" class="headerlink" title="代码规范检查工具 CheckStyle"></a>代码规范检查工具 CheckStyle</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>checkstyle 插件能帮助我们规范代码行为，尽可能地检查代码的坏味道。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>checkStyle 插件配置很简单，主要是分两步：引入插件，编写代码规则 xml。</p><p><strong>引入插件的配置如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-checkstyle-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">configLocation</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/checkstyle.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configLocation</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">includeTestSourceDirectory</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">includeTestSourceDirectory</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enableRulesSummary</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enableRulesSummary</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>check<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入插件的坐标，在   中配置插件的一些属性， <code>configLocation</code> 配置了要使用的规则文件位置，如若不配置则默认使用 sun 公司提供的代码规范配置。<code>includeTestSourceDirectory</code> 是否检查测试代码规范 ，<code>enableRulesSummary</code> 是否开启规则摘要等等，详细的配置信息请<a href="https://maven.apache.org/plugins/maven-checkstyle-plugin/checkstyle-mojo.html">点击</a></p><p>在标签中将 checkstyle 插件的 check 目标绑定到 default 生命周期的 compile 阶段。当使用 <code>mvn compile</code> 编译代码时，checkStyle 便会执行 check 目标，或者手动执行 <code>mvn checkstyle:check</code></p><p><strong>编写代码规则 xml：</strong></p><p>代码规则已经有现成的模板，因此可以直接使用现成的模板，或者根据已有的模板进行修改。比如 sun 公司的代码规范，以及 google 的代码规范。以下是个人开发中经常使用的代码规则，可根据需要修改。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">module</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Puppy Crawl//DTD Check Configuration 1.1//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.puppycrawl.com/dtds/configuration_1_1.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Checker&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localeLanguage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;en&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NewlineAtEndOfFile&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lineSeparator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lf&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FileTabCharacter&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fileExtensions&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java,xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RegexpSingleline&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- \s matches whitespace character, $ matches end of line. --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;format&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;\s+$&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Line has trailing spaces.&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TreeWalker&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;IllegalImport&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RedundantImport&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;UnusedImports&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NeedBraces&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;JavadocMethod&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;scope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;public&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ModifierOrder&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RedundantModifier&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;UpperEll&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LeftCurly&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NeedBraces&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RightCurly&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GenericWhitespace&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;WhitespaceAfter&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NoWhitespaceBefore&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，规则文件的目录名称需要与插件配置的地址一致，否则插件无法使用自己编写的规则。</p><h2 id="代码缺陷检查工具-SpotBugs"><a href="#代码缺陷检查工具-SpotBugs" class="headerlink" title="代码缺陷检查工具 SpotBugs"></a>代码缺陷检查工具 SpotBugs</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>SpotBugs 的前身是 FindBugs，从字面意思很好理解就是帮我们的代码找 bug，当然这个 bug 指的是代码层面的，而不是业务上的。特别说明，SpotBugs 检查的是编译后的字节码文件，而非源代码。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>SpotBugs 的配置也很简单：引入插件依赖，并在插件中做配置即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--     SpotBugs 插件      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.spotbugs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spotbugs-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>              <span class="hljs-comment">&lt;!-- 此处的依赖用于指定 spotbugs 的版本，不引入该依赖，插件默认会有一个提供一个版本 --&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.spotbugs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spotbugs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spotbugs<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>check<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于 SpotBugs 是检查字节码文件，因此需要将 SpotBugs 的目标绑定到 compile 之后的阶段，上述配置将 SpotBugs 绑定到 default 生命周期的 verify 阶段，亦可以直接使用命令 <code>mvn spotbugs:check</code> 执行目标。</p><p>对于一些不需要 SpotBugs 检查的方法或者类需要在 pom 中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.findbugs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>引入依赖后，在对应的类或者方法上添加 <code>@SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)</code> 其中括号中替换为对应的错误类型，更多关于 SpotBugs 的配置信息请<a href="https://spotbugs.github.io/spotbugs-maven-plugin/check-mojo.html">点击</a></p><h2 id="测试覆盖率报告插件-Jacoco"><a href="#测试覆盖率报告插件-Jacoco" class="headerlink" title="测试覆盖率报告插件 Jacoco"></a>测试覆盖率报告插件 Jacoco</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>给单元测试生成测试覆盖率报告，覆盖率报告可以详细的查看测试覆盖到的地方。</p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>给 Junit 测试生成测试报告配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.8.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-prepare-agent<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>prepare-agent<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                     <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                 <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-report<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>report<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                     <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                 <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-check<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>check<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                     <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                         <span class="hljs-tag">&lt;<span class="hljs-name">rules</span>&gt;</span><br>                             <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span><br>                                 <span class="hljs-tag">&lt;<span class="hljs-name">element</span>&gt;</span>BUNDLE<span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span><br>                                 <span class="hljs-tag">&lt;<span class="hljs-name">limits</span>&gt;</span><br>                                     <span class="hljs-tag">&lt;<span class="hljs-name">limit</span>&gt;</span><br>                                         <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span>COMPLEXITY<span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><br>                                         <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>COVEREDRATIO<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                                         <span class="hljs-tag">&lt;<span class="hljs-name">minimum</span>&gt;</span>0.60<span class="hljs-tag">&lt;/<span class="hljs-name">minimum</span>&gt;</span><br>                                     <span class="hljs-tag">&lt;/<span class="hljs-name">limit</span>&gt;</span><br>                                 <span class="hljs-tag">&lt;/<span class="hljs-name">limits</span>&gt;</span><br>                             <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span><br>                         <span class="hljs-tag">&lt;/<span class="hljs-name">rules</span>&gt;</span><br>                     <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                 <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配值 Jacoco 的 report 目标绑定到 verify 阶段，当运行 <code>mvn verify</code>命令时，会生成代码测试覆盖率报告。</p><p>Jacoco 排除文件的配置也需要注意：当我们既需要在生成报告中排除，又需要在检查测试覆盖率中排除时，可以在插件依赖下声明如下，configuration 与插件的 <code>executions</code>在同一级。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>com/greek/shop/entity/*<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>仅需要在某些目标执行是过滤文件，则在对应目标的配置中加入上面的代码。例如要在 report 目标中排除文件，则要在 report 对应的 <code>execution</code> 里面添加上面的配置。</p><p>官方文档中针对单元测试和集成测试有不同的配置方法请<a href="https://www.eclemma.org/jacoco/trunk/doc/maven.html">点击</a>查看，关于 report 的具体配置，以及相关参数也可点击<a href="https://www.eclemma.org/jacoco/trunk/doc/report-mojo.html">这里</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 函数式编程</title>
    <link href="/2021/09/20/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/09/20/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><strong>优点：</strong>减少工作量，减少 Bug，提高效率</p><p>减少工作量：做同样一件事，普通的方法实现，可能需要几十行代码，而函数式编程只需要几行代码</p><p>减少 Bug：代码写的越少，Bug 自然也变的越少</p><p>提高效率：别人还在吭哧坑次的写几十上百行代码时，你已经写完，顺便刷了个知乎</p><h2 id="函数式编程深入浅出"><a href="#函数式编程深入浅出" class="headerlink" title="函数式编程深入浅出"></a>函数式编程深入浅出</h2><p>你可能对我的话不信，那咱们就来看看实际的例子</p><p>假如给定一个用户列表信息，现在要你分别获取<code>id 为偶数的用户</code>、<code>姓周的用户</code>、<code>姓王的用户</code>，你会如何实现这个需求。</p><p>大多数人会写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤 id 为偶数的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithEvenId</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br><br> <span class="hljs-comment">// 过滤姓周的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterZhouUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>)) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br><br> <span class="hljs-comment">// 过滤姓王的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterWangUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.name.startsWith(<span class="hljs-string">&quot;王&quot;</span>)) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>代码达到了我们需要的效果，但是你仔细观察，会发现重复的代码太多了，不同的地方仅仅是 if 中的条件判断，这个时候就需要思考一下如何简化这些代码。稍微细心的人就会发现，过滤姓张的用户，和过滤姓王的用户可以抽取成一个方法，只需要把姓氏当做参数传给函数就行了，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤指定姓氏的用户</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithLastName</span><span class="hljs-params">(List&lt;User&gt; users,String lastName)</span>&#123;<br>      List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (User user : users) &#123;<br>          <span class="hljs-keyword">if</span> (user.name.startsWith(lastName)) &#123;<br>              result.add(user);<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样的确简化了部分代码，但是仅此而已吗？难道<code>过滤id为偶数的用户</code> 方法，就不能跟其它方法合并了吗？</p><p>这个时候你可能会想，要是可以传条件就好了，这样方法就能根据条件，过滤我们需要的用户信息。的确，这种方法确实可行，那要怎么去实现呢？既然传递的都是自己「实现」的条件，那么很容易想到「接口」这个东西。所以我们可以根据要求写一个接口，并提供一个方法，让其他实现该接口的类，自己定义方法的实现，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users,Condition condition)</span> &#123;<br>    List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-keyword">if</span> (condition.isSatisfied(user)) &#123;<br>            result.add(user);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhouUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WangUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;王&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsersWithEvenId</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用了一个接口，以及三个类，每个类对应不同的实现。编写一个根据条件过滤的方法 <code>filterUsersWithCondition</code>，我们传入接口类，然后进行条件判断。</p><p>但是实际上 Java 已经帮我们定义好了这些通用接口，不用我们再去定义，在 <code>java.util.function</code>包中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><p>他与我们自己定义的 Condition 接口很像，方法都是接收一个参数，返回一个布尔值。因此，我们完全可以把自己定义的接口，替换成官方提供的。这样又减少了一点代码量，以 <code>ZhouUser</code>类举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhouUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Predicate</span> &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(User user)</span> &#123;<br>          <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这个时候我们得 <code>filterUsersWithCondition</code> 方法，更改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users,Predicate&lt;User&gt; predicate)</span> &#123;<br>    List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-keyword">if</span> (predicate.test(user)) &#123;<br>            result.add(user);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，做到这样已经很不错了，但是我们还能精简。每次调用 <code>filterUsersWithCondition</code> 方法的时候，都要传入一个实现类，并且每次有新需求，都要生成一个新类实现 Predicate 接口，这样代码量还是很多。</p><p>我们可以这样，直接使用匿名类完成操作，这样我们就不用频繁的实现接口了。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>filterUsersWithCondition(users, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;User&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(User user)</span> &#123; <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候 IDEA 就会提示你了，按下快捷键 alt + enter 建，将匿名类转化为 Lambda 表达式。于是我们上面的代码就变成这样，代码瞬间简洁了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>filterUsersWithCondition(users, user -&gt; user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>));<br></code></pre></td></tr></table></figure><p>这边简单的介绍下 Lambda 表达式：<code>user -&gt; user.name.startsWith(&quot;周&quot;)</code>它对应的就是过滤姓周用户的匿名内部类 test 方法。<code>-&gt;</code> 左边对应参数，他完整的参数是 <code>(User user)</code>，由于 Lambda 可以通过上下文推断出参数类型，因此我们得式子仅仅指定了参数名<code>user</code>。<code>-&gt;</code> 右边的就是要执行的语句了，遇到多行执行语句需要用 <code>&#123;&#125;</code>括起来，用分号分隔语句。</p><p>Predicate 中的 test 方法，是将一个 User 对象到 boolean 的映射。实际上只要我们写的方法满足<code>object-&gt;boolean</code>，都可以自动转化成一个函数接口。比如我们刚写的 Lambda 表达式 <code>user -&gt; user.name.startsWith(&quot;周&quot;)</code> ，以及我们将要展示的方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        filterUsersWithCondition(users, Main::zhouUser);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">zhouUser</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users, Predicate&lt;User&gt; predicate)</span> &#123;<br>        List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(user)) &#123;<br>                result.add(user);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们自己编写了一个方法 <code>zhouUser</code>，这个方法也是满足 Object -&gt; boolean  的映射关系，因此他会被转化成相应的函数接口，这时使用方法引用调用这个方法，即可达到相同的目的。方法引用相比 Labmda 表达式的实现，更为清晰易懂，因为有方法名，我们很容易根据方法的名称来了解代码在干什么，对于日常维护开发更为友好。</p><h2 id="Java-中的函数接口"><a href="#Java-中的函数接口" class="headerlink" title="Java 中的函数接口"></a>Java 中的函数接口</h2><p>先说一个结论：<strong>任何只包含一个抽象方法的接口，都可以转化成函数接口</strong>，例如我们刚开始使用的 <code>Condition</code>接口。</p><p>在 Java 中不只有 Predicate，还有很多默认的实现。像，<code>Consumer</code>是 Object-&gt;void 的映射；<code>Supplier</code>是 void-&gt;Object 的映射;<code>ToIntFunction</code> 是 Object-&gt;int 的映射，等等，如图：</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/8360c589-7218-40e8-9bd9-f4f03414de05.png"></p><p>我们可以根据我们得需求使用以上接口，或者自己定义我们所需的接口。</p><h2 id="使用-Comparator-实战"><a href="#使用-Comparator-实战" class="headerlink" title="使用 Comparator 实战"></a>使用 Comparator 实战</h2><p>当我们需要对数据进行比较的时候，就需要 Comparator</p><p>还是上面说到的 User 对象，现在有了新需求，需要对 user 的 id 进行从小到大排序，然后按照年龄从大到小排列。我们可以使用 Collections.sort() 方法，对数据进行排序。可以发现需要传入的参数是一个 Comparator 接口，因此我们可以直接 New 一个 Comparator，并实现他的方法。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">4</span>, <span class="hljs-number">20</span>));<br><br>Collections.sort(users, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User o1, User o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o1.id &lt; o2.id) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.id &gt; o2.id) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Java 8 之后，JDK 为我们提供了更好的方法。在 Comparator 接口中有一个静态方法 comparing()，我们可以查看代码，发现他需要我们传入一个 Function 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">        Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>&#123;<br>    Objects.requireNonNull(keyExtractor);<br>    <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>        (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们传入的参数遵循 Function 接口对应的映射关系就可以了，打开发现 Function 是 T-&gt;R 的映射关系，即我们传入的参数转化成另一种数据类型。因此我们可以写成这样，User 类转化成整形，符合映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users,Comparator.comparing(user -&gt; user.id);<br></code></pre></td></tr></table></figure><p>我们可以使用方法引用替换 Lambda 表达式，getId 方法表面上没有参数，实际上是有一个隐藏的 this，因次该方法引用也符合映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users,Comparator.comparing(User::getId);<br></code></pre></td></tr></table></figure><p>比较了 id 之后我们还需要比较年龄的倒序排列，使用 thenComparing 继续比较，再使用 reversed() 方法将结果倒序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users, Comparator.comparing(User::getId).thenComparing(User::getAge).reversed());<br></code></pre></td></tr></table></figure><p>这样就完成了我们得需求，一行代码完成了我们得工作，还减少了 bug，头发又可以少掉几根了，真是幸福。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的分布式部署流程</title>
    <link href="/2021/09/01/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/09/01/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>使用 3 种不同的方式，将项目部署成 3 个实例，每个实例监听不同的端口，由 Nginx 负责将请求转发到对应的实例中，完成请求流程。</p><h2 id="Docker-启动-MySQL，Redis"><a href="#Docker-启动-MySQL，Redis" class="headerlink" title="Docker 启动 MySQL，Redis"></a>Docker 启动 MySQL，Redis</h2><p>首先使用 Docker 启动一个全局的 Redis，MySQL，Nginx，让项目连接上对应的数据库。</p><p><strong>获取并启动 MySQL</strong></p><p>获取最新的 MySQL 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql<br></code></pre></td></tr></table></figure><p>启动 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql<br></code></pre></td></tr></table></figure><p><strong>获取并启动 Redis</strong></p><p>获取最新的 Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis<br></code></pre></td></tr></table></figure><p>启动 Redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 6379:6379 -d redis<br></code></pre></td></tr></table></figure><h2 id="使用-Maven-Exec-插件进行部署"><a href="#使用-Maven-Exec-插件进行部署" class="headerlink" title="使用 Maven Exec 插件进行部署"></a>使用 Maven Exec 插件进行部署</h2><p>在项目的 pom 文件中，引入并配置 exec 插件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;plugin&gt;<br>    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br>    &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">3.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>    &lt;configuration&gt;<br>        &lt;executable&gt;java&lt;/executable&gt;<br>        &lt;arguments&gt;<br>            &lt;argument&gt;-classpath&lt;/argument&gt;<br>            &lt;classpath/&gt;<br>            &lt;argument&gt;com.github.hcsp.Application&lt;/argument&gt;<br>        &lt;/arguments&gt;<br>    &lt;/configuration&gt;<br>&lt;/plugin&gt;<br></code></pre></td></tr></table></figure><p>改配置信息指定了<strong>可执行程序</strong> java，指定使用 classpath 中的 jar 包，配置了主类（即程序入口），完成以上配置即可使用 <code>mvn exec:exec</code> 运行程序，演示项目运行的端口为 8081。</p><h2 id="使用-java-jar-方式运行部署"><a href="#使用-java-jar-方式运行部署" class="headerlink" title="使用 java -jar 方式运行部署"></a>使用 java -jar 方式运行部署</h2><p>使用 maven 命令对项目进行打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn package<br></code></pre></td></tr></table></figure><p>得到一个可执行的 jar 包：xxx.jar，接着使用命令执行该 jar，并指定端口为 8082</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Dserver.port=8082  -jar xxx.jar<br></code></pre></td></tr></table></figure><h2 id="使用-Docker-部署项目"><a href="#使用-Docker-部署项目" class="headerlink" title="使用 Docker 部署项目"></a>使用 Docker 部署项目</h2><p>在当前项目文件中编写 Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM java:openjdk-8u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target/spring-aop-redis-mysql-0.0.1.jar /app<br><br>EXPOSE 8080<br><br>CMD [&quot;java&quot;,&quot;-jar&quot;, &quot;spring-aop-redis-mysql-0.0.1.jar&quot;]<br></code></pre></td></tr></table></figure><p>根据编写好的 Dockerfile 生成一个 Docker 镜像文件，在当前目录运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build .<br></code></pre></td></tr></table></figure><p>构建好镜像之后运行该镜像文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -v /C/Users/Administrator/Desktop/application.properties:/app/config/application.properties -p 8083:8081 镜像id<br></code></pre></td></tr></table></figure><p>由于项目默认使用的 Redis 和 MySQL 连接都是 localhost，因此在 Docker 中运行该项目会访问不了数据库，因此，我们在本地重写了 <code>application.properties</code> 文件，并把该配置文件映射到 Docker 内部，使得 Docker 内的项目可以读取并使用该配置文件（配置文件有优先级关系，详情<a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/html/boot-features-external-config.html">点击</a>）。</p><h2 id="使用并配置-Nginx，完成分布式部署"><a href="#使用并配置-Nginx，完成分布式部署" class="headerlink" title="使用并配置 Nginx，完成分布式部署"></a>使用并配置 Nginx，完成分布式部署</h2><p>获取最新的 Nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><p>在启动 Nginx 之前需要对它进行配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">events <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>http <span class="hljs-punctuation">&#123;</span><br>    upstream backend <span class="hljs-punctuation">&#123;</span><br>        server <span class="hljs-number">192.168</span><span class="hljs-number">.110</span><span class="hljs-number">.112</span><span class="hljs-punctuation">:</span><span class="hljs-number">8081</span>;<br>        server <span class="hljs-number">192.168</span><span class="hljs-number">.110</span><span class="hljs-number">.112</span><span class="hljs-punctuation">:</span><span class="hljs-number">8082</span>;<br>        server <span class="hljs-number">192.168</span><span class="hljs-number">.110</span><span class="hljs-number">.112</span><span class="hljs-punctuation">:</span><span class="hljs-number">8083</span>;<br>    <span class="hljs-punctuation">&#125;</span><br>    <br>    server <span class="hljs-punctuation">&#123;</span><br>    listen <span class="hljs-number">80</span>;<br>        location / <span class="hljs-punctuation">&#123;</span><br>            proxy_pass http<span class="hljs-punctuation">:</span><span class="hljs-comment">//backend;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面配置的意思是：Nginx 监听 80 端口，并对所有 80 端口的请求转发给 <code>backend</code>，<code>backend</code> 里面又配置了三个服务，这三个服务就是上面用三种方式开启的。由于没有配置具体的转发规则，因此 Nginx 会使用默认的负载均衡机制轮询，即请求在三个服务之间均匀分布。详细的负载均衡机制点击<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">这里</a>。</p><p>由于 Nginx 是 Docker 启动的，因此需要把本地编写的配置文件映射到 Docker 容器内部，使用 <code>-v</code> 参数。最后 Nginx 的启动命令如下，其中 <code>--restart=always</code> 表示 Nginx 遇到错误会自动重启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --restart=always -v /C/Users/Administrator/Desktop/nginx.conf:/etc/nginx/nginx.conf -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>启动完成后，本机上所有的 80 端口请求都会交给 Nginx 去处理，Nginx 把请求转发到对应的服务上，服务完成请求解析，执行相应过程，返回结果，流程结束。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>使用了 3 种方式部署 Java 项目，但还是推荐使用 Docker 方式。使用 Docker 编写好一个 Dockerfile，然后构建一个 Docker 镜像，要运行多个服务，使用该镜像启动多个容器即可，非常方便。</p><p>Docker 是未来的趋势，学习并使用 Docker 很有必要。最近打算使用 Docker 打造一个 Java 开发环境，理想的结果是本机使用 IDEA，其他所有的环境都在一个 Docker 镜像中，只需要让本机的代码和 Docker 内部的代码保持同步即可。</p><p>下一节搞个 Docker 基本概念介绍，以及理解并手动编写自己的 Dockerfile。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 包管理</title>
    <link href="/2021/08/26/Java%20%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/26/Java%20%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>java 程序的本质就是在拼接命令行，如何拼接的细节，都由 ide 帮我们实现了。假如我们在程序中添加一个包，我们只需要 java -cp 后面补上包的位置，以及这个包依赖的其他包的位置。 当程序中引用的包越来越多时，带来传递性依赖也会越来越多，要在 Java -cp 后面一个个补上包的位置，并且保证不遗漏传递性依赖的包，并且还要保证包不能同名。这将是一比巨大的工作量，费时费力，还容易出错。</p><p>这个时候就需要使用包管理了。它的本质就是告诉JVM如何找到所需的第三⽅类库，以及成功地解决其中的冲突问题。</p><h2 id="JVM-加载包"><a href="#JVM-加载包" class="headerlink" title="JVM 加载包"></a>JVM 加载包</h2><p>首先，JVM 的工作被设计地相当简单：执行一个类的字节码，假如这个过程中碰到了新的类，就去加载它。</p><p>既然碰到新的类就会去加载，那么就存在一个问题：去哪里加载呢？</p><p><strong>类路径（Classpath）</strong></p><p>当 jvm 去找一个新的类时，就会到类路径（Classpath）中挨个去找，碰到 jar 包就会解压缩再去查找。<br>由于类的全限定类名（⽬录层级）唯⼀确定了⼀个类，因此 jvm 可以找到这个类。其中 jar 包本质上就是把许多类放在一起打的压缩包。</p><p><strong>包加载存在的一些问题</strong></p><ul><li><strong>传递性依赖。</strong>简单的解释就是，你依赖的类还依赖了别的类。例如：A -&gt; B -&gt; C，A 依赖 B，B 依赖 C。</li><li>Classpath hell。因为全限定类名是类的唯⼀标识，所以当多个同名类同时出现在Classpath中，就会出现问题。例如：当 classpath 中存在同名的但是不同版本的 jar 包，A-1.0.jar 和 A-1.2.jar。jvm 会根据声明顺序去选择执行，假如 A-1.0.jar 声明在前，jvm 就会加载 A-1.0.jar，而不使用 A-1.2.jar。如果 A-1.0.jar 中是存在安全风险，那么到时候程序运行到安全风险时，就会导致灾难性后果。</li></ul><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><h3 id="Apache-Ant"><a href="#Apache-Ant" class="headerlink" title="Apache Ant"></a>Apache Ant</h3><p>Apache Ant 解决了部分包管理的问题。通过⼿动下载 jar 包，放在⼀个⽬录中。然后写XML配置，指定编译的源代码⽬录、依赖的jar包、输出目录等。</p><p>这样做带来的缺点是什么呢？</p><ul><li>每个人都要自己造一套轮子库</li><li>依赖的第三⽅类库都需要⼿动下载，费时费力。依赖的第三方类库越多，越麻烦。</li><li>没有解决 Classpath hell 问题。即，还是可能存在包同名的问题。</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="Maven-包管理"><a href="#Maven-包管理" class="headerlink" title="Maven 包管理"></a>Maven 包管理</h4><p>Maven 是划时代的包管理工具，但是 Maven 能做的远不止包管理。 </p><p>Maven 的理念是约定优于配置，默认的 Maven 项目结构都是一样的。Maven 具有中央仓库，包都是按照一定约定存储的。Maven 还有本地仓库，默认是位于 <code>~/.m2</code> 。当我们引入一个依赖时，Maven 就会根据填写的信息找到对应的包，并把它下载到本地仓库，下载到本地仓库之后，下次再有相同的包，则直接从本地仓库找。</p><p>Maven 的包按照约定为所有的包编号，方便检索。例如要在项目中引入 fastjson.jar </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.75<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 通过 groupId &#x2F; artifactId &#x2F; version，来定位唯一的包。开发过程中只需要在 pom.xml 文件添加包相应的信息即可。</p><p>其中 version 中的版本 1.2.75 是有一个规约的，1表示主版本号，2表示此版本号，75表示修订号</p><ol><li>主版本号：当你做了不兼容的 API 修改。</li><li>次版本号：当你做了向下兼容的功能性新增。</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><h4 id="Maven-的传递性依赖以及包冲突"><a href="#Maven-的传递性依赖以及包冲突" class="headerlink" title="Maven 的传递性依赖以及包冲突"></a>Maven 的传递性依赖以及包冲突</h4><p><strong>maven 传递性依赖的⾃动管理原则：绝对不允许最终的 classpath 出现同名不同版本的jar包</strong></p><p><strong>maven 解决传递性依赖</strong></p><p>当我们引入相关的包时，maven 会帮我们下载这个包，<strong>并且把他的传递性依赖的包都下载下来。</strong>因此，在 maven 中我们不需要去管理包的传递性依赖问题，maven 都会帮我们处理好。 </p><p><strong>maven 解决传递性依赖带来的包冲突问题</strong></p><p>假设你的项目有以下依赖。A 依赖 C，C 依赖 D 的0.2版本；B 依赖 D 的 0.1版本。<br> <img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E5%8C%85%E7%AE%A1%E7%90%86/90d36004-cdb8-47f4-9707-1c5d3ef77706.png" alt="image.png"></p><p>如果按照图上所示，把所有的包都下载，势必会造成前面的 Classpath hell 问题，因为两个包 D 同名了。首先，maven 会根据包的 groupId 和 artifactId 来判断是否为同一个。存在相同的包 maven 就会帮我们自动解决。</p><p>maven 解决的原则就是：离项目最近的胜出，如果一样近，则靠前声明的胜出。回到图中，D-0.2 离项目的距离是3，而 D-0.1 离项目的距离是2，因此 D-0.2就会被 maven 剔除，classpath 路径中只存在 D-0.1。maven 解决冲突的做法，在大部分情况下是可行的，但也有不行的时候。假设项目中使用了 D-0.2 中的 API，由于 D-0.1 是旧版，没有相同的 API，maven 根据原则，帮我们把 D-0.2 剔除了，这个时候项目启动就会报错了。</p><p><strong>手动解决包冲突</strong></p><p>当遇到上诉情况就需要我们手动来解决冲突问题。</p><ol><li>首先我们要对比冲突包的区别，判断项目实际上所需要的包（maven 中央仓库找到冲突的包，通过查看源代码进行对比）</li><li>确定了所需要的版本之后，可以使用如下方法进行解决<ul><li>方法一：根据 maven 的解决原则，最近的胜出，我们可以直接在项目中引入一个 D-0.2 版本，此时 D-0.2 离项目的距离是1，所以会使用 D-0.2。</li><li>方法二：指定 maven 排除不需要的包，把不需要的依赖排除掉，剩下需要的依赖就可以了。使用exclusions，在 B 的 dependency 中排除掉 D 的依赖。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>**tips: ** 可以使用<code>Maven helper</code> 查看依赖树，也可以通过 <code>mvn dependency:tree</code> 命令查看依赖树。</p><p><strong>依赖的 scope</strong></p><p>我们经常可以在 pom 文件中看到以下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 groupId、artifactId、version 来定位这个包。scope 则是用来声明这个包在项目的作用范围。通常有这三个值<br><code>test</code> 、 <code>compile</code> 、 <code>provided</code> 。test 表示包作用在测试代码中，src&#x2F;test 目录下。compile 作用在源代码和测试代码中，并且编译和运行都有效。procided 作用在代码的编译期间，代码运行期间不生效。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行的入门与详解</title>
    <link href="/2021/08/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是命令行"><a href="#什么是命令行" class="headerlink" title="什么是命令行"></a>什么是命令行</h1><p>操作系统都有内核的概念，内核是直接与硬件打交道的。我们通过包裹内核的一层壳（ shell ）来与内核打交道。</p><p><strong>广义的命令行包括一切通过字符终端控制计算机的⽅式</strong></p><ul><li>Windows - cmd&#x2F;PowerShell&#x2F;Git bash </li><li>UNIX&#x2F;Linux系列：sh&#x2F;zsh&#x2F;Terminal, etc.</li></ul><h1 id="为什么需要命令行"><a href="#为什么需要命令行" class="headerlink" title="为什么需要命令行"></a>为什么需要命令行</h1><ul><li>因为基本所有公司的服务器都运⾏在 Linux 上 ，所以不得不用</li><li>将工作自动化（暂时没有接触到的领域）</li><li>相比 GUI，命令行更容易开发维护，bug 更少</li><li>远程连接命令行占用资源远低于 GUI</li><li>命令行上的开发者工具更丰富</li></ul><h1 id="不同平台命令行启动方式"><a href="#不同平台命令行启动方式" class="headerlink" title="不同平台命令行启动方式"></a>不同平台命令行启动方式</h1><ul><li>Windows：cmd&#x2F;PowerShell&#x2F;WSL </li><li>UNIX&#x2F;Linux：⼀开机就是，不⽤找。Mac OS 对应的是终端。</li></ul><h1 id="命令行的全部要素"><a href="#命令行的全部要素" class="headerlink" title="命令行的全部要素"></a>命令行的全部要素</h1><p><strong>命令是由可执行程序和参数组成的。</strong>例如：git add test.txt，git 就是<strong>可执行程序</strong>，git 后面所有的都是<strong>参数，</strong>即 <code>add test.txt</code> 。命令行输入命令，会把参数原封不动地交给可执行程序解释。</p><h2 id="可执行程序（Executable）"><a href="#可执行程序（Executable）" class="headerlink" title="可执行程序（Executable）"></a>可执行程序（Executable）</h2><p>什么样的东西是可执行的呢？在 Windows 和 Linux &#x2F; Unix有着不同的区别</p><ul><li>Windows：只要是 exe &#x2F; bat &#x2F; com 结尾的文件都是可执行文件</li><li>LIunx &#x2F; Unix：文件有 <strong>x 权限</strong>，表示该文件为可执行文件</li></ul><p><strong>可执行程序的位置</strong></p><ul><li>Windows：Path 环境变量或当前⽬录 </li><li>UNIX &#x2F; Linux：PATH 环境变量</li></ul><p><strong>可以在脚本的第一行指定解释器（shebang）</strong>，假设 zzf.sh文件中有如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/env node</span><br>console.log(123)<br></code></pre></td></tr></table></figure><p><code>#!/usr/bin/env node</code> 意思是在 PATH 环境变量找到 node 解释器位置，来解释 zzf.sh 文件。也可以使用 node.exe 文件的绝对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/d/node</span><br>console.log(123)<br></code></pre></td></tr></table></figure><p>从环境变量找解释器和使用绝对路径是等价的，但是一般都是从环境变量去找，更为灵活。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>UNIX 参数的约定</strong></p><ul><li>使用一个 “-“ 后面只能跟一个字符，例如：-a -f  等等。后面跟多个参数的话可以合并，例如：-a -f 合并成 -af</li><li>使用两个 “-“ 后面可以跟一个单词，例如： <code>ls -a</code>  显示所有文件，等价于 <code>ls --all</code></li></ul><p> </p><p>然而，Java 并不鸟 UNIX 参数约定，例如：当我们查看当前 Java 版本，使用命令 <code>java -version</code> ，一个 “-“ 后面跟了一个单词，与 UNIX 参数约定不符</p><p><strong>参数一些注意事项</strong>默认情况下 “$” 符号会进行展开。假设当前目录存在一个 <code>main$A.class</code> 文件，并且 <code>export A=123</code> 设置环境变量 A 为123， 使用 <code>Java main$A</code> 运行该文件，等价于 <code>Java main123</code> 。即，把 $A 替换成 123，如果不进行替换，就要使用单引号包裹起来，即 <code>Java &#39;main$A&#39;</code> 。双引号包裹内容也会进行替换。</p><p><strong>因此得出以下结论</strong></p><ul><li>单引号：不会对引号的内容做处理</li><li>双引号：对引号里的内容替换</li><li>空格：当做参数处理</li></ul><h2 id="环境变量（Environment-variable）"><a href="#环境变量（Environment-variable）" class="headerlink" title="环境变量（Environment variable）"></a>环境变量（Environment variable）</h2><ul><li>进程（Process）<ul><li>进程是计算机程序运⾏的最⼩单位 </li><li>独占⾃⼰的内存空间和⽂件资源</li></ul></li><li>每个进程都和⼀组变量相绑定 <ul><li>传递不同的环境变量可以让程序表现出不同的⾏为 </li><li>CLASSPATH&#x2F;GOPATH</li></ul></li><li>在进程的fork过程中，环境变量可以被完全继承</li><li>所有的操作系统&#x2F;编程语⾔都⽀持环境变量 </li><li>局部和全局的环境变量<ul><li>局部变量：只在当前环境生效</li><li>全局变量：全局生效的变量</li></ul></li></ul><p>我们可以通过 export &#x2F; set 设置环境变量，通过 echo 读取环境变量 。修改全局变量就需要在全部变量文件中修改，不同操作系统对应的文件不同。</p><h2 id="工作目录（Working-directory）"><a href="#工作目录（Working-directory）" class="headerlink" title="工作目录（Working directory）"></a>工作目录（Working directory）</h2><p><strong>工作目录就是输入命令行时，所处的目录即为工作目录。绝对路径是以根目录开头的路径，相对路径是相对于当前目录的路径。</strong></p><h1 id="进程的输入与输出"><a href="#进程的输入与输出" class="headerlink" title="进程的输入与输出"></a>进程的输入与输出</h1><p>标准输⼊ stdin ，进程将从标准输入中得到输入数据。例如使用 <code>rm -rf *</code> 命令，会提示是否确认删除，当我们回复y 的时候，就时一个标准输入。</p><p><strong>输出的重定向</strong>，我们可以使用 “&gt;” 符号来重定向输出，例如在终端输入 <code>date +&quot;%Y-%m-%d %H:%M:%S&quot; &gt; output.txt</code> ，就是将<strong>标准输出</strong>重定向到 output.txt 文件中，若再次运行该命令，会将之前的 output.txt 文件覆盖 。使用 “&gt;&gt;” 可以将标准输出追加到 output.txt 文件中。</p><p><strong>标准输出 stdout</strong> 和<strong>标准错误 stderr <strong>相当于一个进程的两个管道。标准输出对应着文件描述符1，标准错误 对应着文件描述符2。假设我们要将一个</strong>进程的标准输出重定向</strong>到 output.txt 文件中，我们可以使用 <code>命令 &gt; output.txt</code> 或者 <code> 命令 1&gt; output.txt</code> 。同理类推，将<strong>进程的标准错误重定向到</strong> error.txt 文件，可以使用    <code>命令 2&gt; error.txt</code> 。要让标准输出和标准错误都重定向到 output.txt 文件，使用 <code> 命令 &gt; output.txt &gt; 2&gt;&amp;1</code> 。该命令代表的意思是，先将2（标准错误），重定向到1（标准输出），再把结果重定向到 outout.txt 文件。</p><p><strong>&#x2F;dev&#x2F;null</strong> 相当于一个垃圾桶的概念，可以把标准输出或者标准输入重定向到该文件。 <code> 命令 &gt; /dev/null</code> 即把标准输出丢到垃圾桶里，相当于黑洞一般，把标准输出给「吞」了。</p><h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><p>任何一个 UNIX 文件都有9位，分成3组，分别是自己（文件创建者），同用户组的人，不同用户组的人。每一组都有 rwx，r 代表读（read），w 代表写（write），x 代表可执行。</p><p>假设有一个需求，我们要当前文件只能被当前用户读写执行。就需要把自己组的 r 设置为1，w 设置为1，x 设置为1，其他组的 rwx 都设置为0，设置完成后对应的二进制分别是 <code>111 000 000</code> ，对应的十进制就是 <code>700</code> ，因此使用 <code>chmod 700 当前文件</code> 即可赋予当前用户读写执行权限。</p><p>根据上面的结论，我们需要给所有用户可读可写可执行权限，就需要把所有组的 rwx 设置为1，得到的二进制就是 <code>111 111 111</code> ，对应的十进制为 <code>777</code> ，因此 <code>chmod 777 当前文件</code> 表示为所有用户，赋予可读可写可执行权限。</p><h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><ul><li>进⼊⽬录 cd (change directory) </li><li>展示⽂件 ls&#x2F;ll&#x2F;ls -alth (list) </li><li>移动&#x2F;重命名⽂件 mv (move) </li><li>删除⽂件 rm&#x2F;rm -r&#x2F;rm -rf (remove) </li><li>拷⻉⽂件 cp&#x2F;cp -r (copy) </li><li>显示变量 echo </li><li>导出变量 export </li><li>Git系列操作 git pull&#x2F;push&#x2F;add&#x2F;commit&#x2F;…</li><li>新建⽬录 mkdir&#x2F;mkdir -p (make directory) </li><li>当前⽬录 pwd (print working directory) </li><li>显示⽂件 cat (concatenate and print files)</li><li>编辑⽂件 vi</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 依赖与插件解析机制</title>
    <link href="/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>劝退提醒</strong>：不了解 maven 坐标机制，没有使用过 maven 插件，不了解 maven 插件命令的，可以关闭文章了。</p><p>我们经常在项目中引入包，使用 <code>&lt;dependency&gt;</code> 标签，然后填写包的坐标信息， Maven 就可以帮我们引入该 jar 包。当本地存在该 jar 包时，就从本地引入该 jar 包，否则就从远程仓库引入。</p><p>这背后的解析机制是什么呢？</p><h2 id="依赖解析机制"><a href="#依赖解析机制" class="headerlink" title="依赖解析机制"></a>依赖解析机制</h2><p>依赖解析的背后机制可以概括如下：</p><ol><li><p>依赖范围是 <code>system</code>，maven 就会从本地加载该 jar 包，完成构建。</p></li><li><p>正常解析依赖坐标，先去本地仓库找，找到就完成构建。</p></li><li><p>本地找不到，并且显示的指定了版本信息，就去远程仓库中遍历，找到并下载解析。</p></li><li><p>如果依赖的版本信息并没有指定，而是使用 <code>RELEASE</code>或者 <code>LATEST</code>，他会找到远程仓库的<strong>元数据</strong>和本地的元数据进行合并，然后计算出真正的版本号。元数据指的就是仓库中 <code>groupId/artifactId/maven-metadata.xml</code>文件，例如我们打开 guava 包的元数据。元数据位置就在 com.google.guava&#x2F;guava 包下，打开可以看到如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">metadata</span> <span class="hljs-attr">modelVersion</span>=<span class="hljs-string">&quot;1.1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">versioning</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">latest</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">latest</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">release</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">release</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r03<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r05<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r06<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r07<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r08<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r09<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lastUpdated</span>&gt;</span>20210319161151<span class="hljs-tag">&lt;/<span class="hljs-name">lastUpdated</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">versioning</span>&gt;</span><br>&lt;/metadata<br></code></pre></td></tr></table></figure><p> 上面的信息展示了 latest，release 对应的版本号，以及 guava 包的历代版本号，以及最近一次更新时间。例如我们引入 guava，并使用 latest 版本，maven 就会合并元数据，然后计算出 latest 对应的版本号，然后从本地仓库找到改版本的 guava，没有则去远程仓库下载。</p></li><li><p>依赖的版本是 SNAPSHOT，则同样获取远程元数据与本地合并，计算版本信息，获取对应版本的包。</p></li><li><p>如果依赖版本为时间戳的快照版本，就会先转换成非时间戳的快照版本，然后去解析下载。</p></li><li><p>maven 3 中如果不指定 version，则默认解析使用 RELEASE 版本。</p></li></ol><h2 id="插件解析机制"><a href="#插件解析机制" class="headerlink" title="插件解析机制"></a>插件解析机制</h2><p>我们常用的 maven 插件命令都是 <code>mvn dependency:tree</code> <code>mvn flyway:migrate</code>，诸如此类的，他们的格式都是 <code>mvn 插件前缀:目标</code>。</p><p>为了方便用户使用和配置插件，maven 不需要用户提供完整的坐标信息，就能解析得到正确的插件。那么问题来了，maven 是怎么确定插件的坐标和版本的呢？例如 <code>mvn dependency:tree</code> 他执行了什么插件，插件坐标版本信息是什么？</p><p>插件的解析机制和依赖解析机制基本一致，不同的是远程仓库不一样。配置插件的远程仓库地址需要使用 <code>&lt;pluginRepository&gt;</code> 标签配置，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了 <code>&lt;pluginRepositories&gt;</code>和 <code>&lt;pluginRepository&gt;</code>不同，其他的与依赖的仓库配置信息一致。</p><h3 id="默认的-groupId"><a href="#默认的-groupId" class="headerlink" title="默认的 groupId"></a>默认的 groupId</h3><p>在 pom 文件在红配置插件信息的时候，如果插件是 maven 官方的插件（groupId 为 org.apache.maven.plugins），就可以省略 groupId 的配置。如下是官方的 clean 插件配置，没有指定 groupId，但是解析坐标的时候会带上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在插件配置中，不推荐省略 groupId 的写法，但这与我们使用 maven 插件命令有关。</p><h3 id="省略版本信息"><a href="#省略版本信息" class="headerlink" title="省略版本信息"></a>省略版本信息</h3><p>maven 的核心插件都在超级 pom 中显示的声明了具体的版本信息，因此当这些插件未指定版本信息的时候，就会使用超级 pom 中指定的插件版本。</p><p>如果是非核心插件，且未指定版本信息。在 maven2 中默认解析至 latest，maven3 默认解析至 release，具体的解析过程与依赖解析一致，都是根据合并计算元数据，得到具体的版本信息。</p><h3 id="插件前缀解析"><a href="#插件前缀解析" class="headerlink" title="插件前缀解析"></a>插件前缀解析</h3><p>我们使用命令 <code>mvn dependency:tree</code> 插件前缀是 dependency，我们是如何根据这个前缀信息得到该插件的完整坐标呢？</p><p>这就需要结合上面的知识了，首先存在一个保存 groupId 和 artifactId 对应关系的文件 maven-metadata.xml，该文件存在 groupId &#x2F; maven-metadata.xml。由于上面的 dependency 是官方插件，因此 groupId 为 <code>org.apache.maven.plugins</code> ，我们去远程仓库找到该文件，如下图。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/91808d7d-667b-4874-bf53-33765521e002.png" alt="image.png"></p><p>我们可以找到插件前缀 dependency 对应的 articfactId 是 <code>maven-dependency-plugin</code>，因此插件的完整坐标可以确定了。</p><p><strong>获取 groupId</strong></p><p>这里还有个问题，因为我们是提前知道 dependency 是官方的插件，可以推出他的 groupId ，但是 maven 是怎么知道它的 groupId 呢？</p><p>maven 的主要插件都在 <code>[https://repo1.maven.org/maven2/org/apache/maven/plugins](https://repo1.maven.org/maven2/org/apache/maven/plugins)</code>和<code>[https://repository.codehaus.org/org/code-haus/mojo](https://repository.codehaus.org/org/code-haus/mojo)</code>下，他们对应的 groupId 分别是 <code>org.apache.maven.plugins</code> 和 <code>org.codehaus.mojo</code>。maven 解析插件的时候就会默认使用这两个 groupId 去匹配，检查 org&#x2F;apache&#x2F;maven&#x2F;plugins&#x2F;maven-metadata.xml，org&#x2F;codehaus.momjo&#x2F;maven-metadata.xml 文件，判断是否有匹配的插件前缀，如果有则获取对应的坐标信息，完成解析。</p><p>倘若想使用的插件是第三方的，就可以通过配置 setting.xml 文件，让 maven 也检查其他 groupId 上的仓库 metadata.xml 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>第三方仓库 groupId<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><p>解析 dependency:tree 命令</p><ol><li><p>先使用默认的和配置的第三方的  groupId 去找到对应的 <code>maven-metadata.xml</code>文件，然后检查是否包含 dependency 前缀信息。</p></li><li><p>包含前缀信息，获取对应 articfactId，不包含则使用下一个 groupId 的 maven-metadata.xml 文件。如果所有都获取不到，则报错。</p></li><li><p>获取到 articfactId 之后根据上面 <a href="#Ueudm">获取版本信息</a>，即可得到完整的坐标，完成解析执行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Maven 实战》笔记</title>
    <link href="/2021/08/20/%E3%80%8AMaven%20%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    <url>/2021/08/20/%E3%80%8AMaven%20%E5%AE%9E%E6%88%98%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>当项目需要被其他项目引用时，使用 <code>mvn clean install</code> 安装到本地仓库，其他项目就可以引用该项目。</p><p>我们打包的默认 jar 包不能直接运行的，因为带有 main 方法的信息类不会添加到 mainfest 中（ jar 文件中 META-INF&#x2F;MANIFEST.MF 文件，没有 <code>Main-Class</code>一行）。为了生成可执行的 jar 文件，需要借助 <code>maven-shade-plugin</code>，配置该插件。</p><h2 id="使用-Maven-命令快速创建一个-maven-项目"><a href="#使用-Maven-命令快速创建一个-maven-项目" class="headerlink" title="使用 Maven 命令快速创建一个 maven 项目"></a>使用 Maven 命令快速创建一个 maven 项目</h2><p>使用命令 <code>mvn archetype:generate</code> 根据提示选择需要的骨架，输入 groupId，artifactId，version 等信息，创建项目。需要注意的是：maven2 中使用上面的命令，会去下载最新的版本，而不是稳定的版本，可能导致运行失败。maven3 则默认是下载稳定的版本。</p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><ul><li><strong>groupId：命名通常为域名反向一一对应。</strong>比如 <code>google.com</code> 可以命名为 <code>com.google</code>。</li><li><strong>artifactId：</strong>命名推荐的做法是<strong>使用实际的项目名称作为 artifactId 的前缀</strong>。比如项目名是 <code>demo</code>，下面有个 <code>hello</code> 模块，就可以命名为 <code>demo-hello</code>。 </li><li><strong>version：</strong>定义当前项目的版本信息。</li><li><strong>packaging：定义元素打包方式，打包方式通常与所生成的构件文件扩展名对应</strong>。例如指定为 <code>jar</code> 则构件的文件扩展名为 .jar，war 也如此。<strong>不定义 packaging 时，默认打包为 jar</strong>。打包方式会影响到构建的生命周期，比如 jar 和 war 打包会使用不同的命令。</li><li><strong>classifier：定义构建输出的一些附属构建。例如项目打包生成 demo.jar 文件，打包过程中可能还需要 javadoc 文件，就可以配置对应的插件来生成 javadoc 文件。</strong></li></ul><h2 id="依赖的配置"><a href="#依赖的配置" class="headerlink" title="依赖的配置"></a>依赖的配置</h2><ul><li><strong>type：</strong>依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，默认为 jar。</li><li><strong>scope：</strong>依赖的作用范围。</li><li><strong>optional：</strong>标记依赖是否可选。</li><li><strong>exclusions：</strong>用来排除传递性依赖。</li></ul><h2 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h2><p>前置知识：Maven 编译项目主代码的时候使用一套 classpath，在编译执行测试的时候使用另一套 classpath，而实际运行 Maven 项目时候又会使用一套 classpath，因此总共有三套 classpath。</p><p><strong>依赖范围就是来控制与这三种 classath（编译 classpath，测试 classpath，运行 classpath）的关系</strong>。如果没有指定依赖范围，就会默认使用 <code>compile</code>依赖范围。</p><p><strong>依赖范围与 classpath 关系</strong></p><p>| <strong>依赖范围</strong></p><table><thead><tr><th><strong>（Scope）</strong></th><th><strong>对于编译 classpath 有效</strong></th><th><strong>对于测试 classpath有效</strong></th><th><strong>对于运行时 classpath 有效</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>spring-core</td></tr><tr><td>test</td><td>–</td><td>Y</td><td>–</td><td>JUnit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>–</td><td>servlet-api</td></tr><tr><td>runtime</td><td>–</td><td>Y</td><td>Y</td><td>JDBC 驱动实现</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>–</td><td>本地的 maven 仓库外的类库文件</td></tr></tbody></table><h2 id="传递性依赖和依赖范围"><a href="#传递性依赖和依赖范围" class="headerlink" title="传递性依赖和依赖范围"></a>传递性依赖和依赖范围</h2><p>传递性依赖：A –&gt; B –&gt; C，假设 A 依赖 B，B 依赖 C。称 A 对于 B 是<strong>第一直接依赖，</strong>B 对于 C 是<strong>第二直接依赖，</strong>A 对于 C 是<strong>传递性依赖。</strong></p><p>上面说了依赖范围不仅与三种 classpath 有关系，还对传递性依赖产生影响。如下表格所示，最左边的一行表示第一依赖范围，最上面一行表示第二直接依赖范围。</p><p><strong>依赖范围影响传递性依赖</strong></p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th><th>runtime</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td>–</td><td>–</td><td>runtime</td></tr><tr><td>test</td><td>test</td><td>–</td><td>–</td><td>test</td></tr><tr><td>provided</td><td>provided</td><td>–</td><td>provided</td><td>provided</td></tr><tr><td>runtime</td><td>runtime</td><td>–</td><td>–</td><td>runtime</td></tr></tbody></table><p>助记规律：</p><ul><li>当第二直接依赖范围是 <code>compile</code> 时，传递性依赖范围与第一直接依赖范围一致。</li><li>当第二直接依赖范围是 <code>test</code> 时，依赖不会得以传递。</li><li>当第二直接依赖范围是 <code>provided</code> 时，只传递第一依赖范围也为 <code>provided</code>的依赖。</li><li>当第二直接依赖范围是 <code>runtime</code> 时，传递性依赖范围与第一直接依赖范围一致，但 <code>compile</code> 除外，此时传递性依赖范围为 <code>runtime</code>。</li></ul><p><strong>依赖调节</strong></p><p>就近原则：A –&gt; B –&gt; C(1.0），A –&gt; B –&gt; D –&gt; C(2.0)，前者的路径长度为2，后者为3，因此 C(1.0) 被解析使用。</p><p>先声明先使用：遇到长度一样的，无法使用就近原则，就根据声明顺序，先声明的先解析使用。</p><h2 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h2><p>假设 A 依赖 B，B 依赖 X 和 Y，B 对于 X 和 Y 的依赖是可选依赖。A –&gt; B，B –&gt; X（可选），B –&gt; Y（可选），可选依赖不会得到传递，换句话说选择 X 或者 Y，对于 A 都不会有任何影响。</p><p>可选依赖在 <code>dependency</code>标签中需要添加 <code>&lt;optional&gt;true&lt;/optional&gt;</code>用来标记为可选依赖，因此 B 需要添加 X 和 Y 的依赖，并且分别在 <code>dependency</code>标签加上 <code>&lt;optional&gt;true&lt;/optional&gt;</code>。</p><p>当需要指定所使用的依赖时，需要在外层声明需要使用的依赖，上面的例子就需要在 A 中引入 X 或者 Y 的依赖。在理想的情况下，尽量避免可选依赖的使用。</p><h2 id="远程仓库认证"><a href="#远程仓库认证" class="headerlink" title="远程仓库认证"></a>远程仓库认证</h2><p>当我们使用 <code>&lt;repository&gt;&lt;/repository&gt;</code> 配置好一个远程仓库后，大部分情况下无需认证就可以直接访问，但是处于安全考虑，我们需要提供一些认证信息才能访问。此时，我们就需要配置认证信息，一般在 <code>setting.xml</code> 文件中配置，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>remoteRepository<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span><br></code></pre></td></tr></table></figure><p>文件中配置了认证信息，账号密码都是 <code>admin</code>，需要注意的是 <strong>id 的值要与配置的远程仓库的 id 一致。</strong></p><h2 id="部署至远程仓库"><a href="#部署至远程仓库" class="headerlink" title="部署至远程仓库"></a>部署至远程仓库</h2><p>编写项目的 <code>pom.xml</code> 文件，配置 distributionManagement 元素，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 distributionManagement 包含两个子元素，前者表示<strong>发布版本</strong>构件的仓库，后者表示<strong>快照版本</strong>的仓库。两个元素都需要配置 id，name，url，id 为远程仓库的唯一标识，name 为了方便阅读（取名），url 远程仓库地址。</p><p>发布到远程仓库的时候，往往需要认证，认证步骤与<a href="#G7puJ">远程仓库认证</a>一致。之后使用命令 <code>mvn clean deploy</code> maven 就会把项目构建输出到对应的远程仓库。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><strong>如果仓库 X 可以提供仓库 Y 存储的所有内容，那么就可以认为 X 是 Y 的一个镜像。</strong>换句话说，任何一个从 Y 仓库获取的构件，都可以从它的镜像中获取。由于地理原因，国内访问 maven 中央仓库很慢，因此就需要配置一个镜像，通常使用阿里云的镜像居多。配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>改配置文件中 <code>&lt;mirrOf&gt;</code> 的值为 central，表示任何访问该仓库的请求都会转到这个镜像中。如果镜像需要认证，也可以基于这个 <code>&lt;id&gt;</code> aliyunmaven，配置仓库认证。</p><p>Maven 的 <code>&lt;mirrOf&gt;</code> 标签还支持一些更<strong>高级的配置</strong>：</p><ul><li><code>&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</code>匹配所有远程仓库</li><li><code>&lt;mirrorOf&gt;external: *&lt;/mirrorOf&gt;</code>匹配所有不在本机上的远程仓库<strong>。</strong></li><li><code>&lt;mirrorOf&gt;repo1,repo2&lt;/mirrorOf&gt;</code>匹配仓库 rpeo1，repo2，使用逗号分隔多个远程仓库。</li><li><code>&lt;mirrorOf&gt;*,！repo1&lt;/mirrorOf&gt;</code>匹配所有远程仓库，repo1除外。</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>maven 的生命周期其实就是软件从初始化到发布上线经历的一系列过程。maven 将这个过程抽象化了，每个周期所执行的操作都是交给插件完成。</p><p>maven 拥有三套相互独立的生命周期，分别是 <strong>clean，default，site。</strong>clean 负责清理项目，default 负责构建项目，site 负责建立项目站点。</p><p>每个生命周期都包含一些阶段（phase），这些阶段都是有顺序的，并且后面的阶段依赖于前面的阶段。比如 clean 生命周期包含: <code>pre-clean</code>，<code>clean</code>，<code>post-clean</code> 阶段，当用户调用 pre-clean，只有 pre-clean 阶段会执行，当调用 post-clean 时，pre-clean，clean，post-clean 都会执行。<strong>由于三个生命周期互不影响，当调用某个生命周期的某个阶段时，对其他的生命周期没有任何影响。</strong></p><h3 id="clean-生命周期阶段"><a href="#clean-生命周期阶段" class="headerlink" title="clean 生命周期阶段"></a>clean 生命周期阶段</h3><ul><li>pre-clean 执行清理前需要完成的工作</li><li>clean 清理上一次构建生成的文件</li><li>post-clean 执行清理后需要完成的工作</li></ul><h3 id="default-生命周期阶段（主要）"><a href="#default-生命周期阶段（主要）" class="headerlink" title="default 生命周期阶段（主要）"></a>default 生命周期阶段（主要）</h3><ul><li>validate 验证项目是否正确并且所有必要的信息都可用</li><li>compile 编译项目的源代码</li><li>test 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求打包或部署代码</li><li>package 将编译后的代码打包成可分发的格式，例如 JAR。</li><li>verify 对集成测试的结果进行任何检查，以确保满足质量标准</li><li>install 将包安装到本地存储库中，作为本地其他项目的依赖项</li><li>deploy 在构建环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。</li></ul><h3 id="site-生命周期阶段"><a href="#site-生命周期阶段" class="headerlink" title="site 生命周期阶段"></a>site 生命周期阶段</h3><ul><li>pre-site 执行生成项目站点前需要完成的工作</li><li>site 生成项目站点文档</li><li>post-site 执行生成项目站点后需要完成的工作</li><li>site-deploy 将生成的项目站点发布到服务器上</li></ul><h3 id="命令行与生命周期"><a href="#命令行与生命周期" class="headerlink" title="命令行与生命周期"></a>命令行与生命周期</h3><p>一些常见的 Maven 命令，解释其执行生命周期：</p><ul><li><code>mvn clean</code> 调用 clean 生命周期的 clean 阶段，即执行 <code>pre-clean</code> 和 <code>clean</code>阶段。</li><li><code>mvn test</code> 调用 default 生命周期的 test 阶段，即执行 <code>validate</code>、<code>compile</code>、<code>test</code> 阶段。</li><li><code>mvn clean install</code> 调用 clean 生命周期的 clean 阶段，以及 default 生命周期的 install 阶段。即执行 <code>pre-clean</code>和 <code>clean</code>阶段，以及 <code>validate</code>到 <code>install</code>的所有阶段。</li><li><code>mvn clean deploy site-deploy</code> 调用 clean 生命周期的 clean 阶段，default 生命周期的 deploy 阶段，以及 site 生命周期的 site-deploy 阶段，实际执行过程按照上面类推。</li></ul><h2 id="插件目标和插件绑定"><a href="#插件目标和插件绑定" class="headerlink" title="插件目标和插件绑定"></a>插件目标和插件绑定</h2><h3 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h3><p>一个插件往往能执行多个任务，因此插件具有多个功能，插件的每个功能就是一个**插件目标 (goal)**。</p><p><code>maven-dependency-plugin</code>就有十多个目标，每个目标对应一个功能。例如：<code>dependency:list</code>、<code>dependency:tree</code>分别是不同的功能，这是一种通用的写法，冒号前面是插件前缀，冒号后面是该插件的目标。类似的，<code>compiler:compile</code>（这是 maven-compiler-plugin 的 compile 目标）和 surefire:test（这是 maven-surefire-plugin 的 test 目标）。</p><h3 id="插件绑定"><a href="#插件绑定" class="headerlink" title="插件绑定"></a>插件绑定</h3><p>maven 的生命周期与插件相互绑定，具体而言就是生命周期的阶段与插件的目标相互绑定。例如 <code>mvn compile</code>就是 default 生命周期 compile 阶段与 <code>maven-compiler-plugin</code> 插件的 <code>compile</code>目标绑定。</p><p><strong>内置绑定</strong></p><p>为了简化配置，maven 为一些核心的生命周期阶段绑定了很多插件的目标。当用户调用对于的生命周期阶段时，绑定的插件目标就会执行相应的任务。</p><p>例如：clean 生命周期的 clean 阶段，就绑定了 <code>maven-clean-plugin</code>插件的 <code>clean</code> 目标绑定。site 生命周期的 site 阶段绑定 <code>maven-site-plugin</code> 插件的 <code>site</code> 目标，site-deploy 阶段绑定到 <code>maven-site-pugin</code>插件的 <code>deploy</code>目标。</p><p>由于项目的打包类型会影响构建的具体过程，因此 default 的生命周期阶段与插件的目标绑定关系与打包类型有关系。<br>default 生命周期的内置插件绑定关系（打包类型为 jar）</p><table><thead><tr><th>生命周期阶段</th><th>插件目标</th><th>执行任务</th></tr></thead><tbody><tr><td>process-resources</td><td>maven-resources-plugin:resources</td><td>复制主资源文件至输出目录</td></tr><tr><td>compile</td><td>maven-compiler-plugin:compile</td><td>编译主代码至输出目录</td></tr><tr><td>process-test-resources</td><td>maven-resources-plugin:testResources</td><td>复制测试资源文件至测试输出目录</td></tr><tr><td>test-compile</td><td>maven-compiler-plugin:testCompile</td><td>编译测试代码至测试输出目录</td></tr><tr><td>test</td><td>maven-surefire-plugin:test</td><td>执行测试用例</td></tr><tr><td>package</td><td>maven-jar-plugin:jar</td><td>创建项目 jar 包</td></tr><tr><td>install</td><td>maven-install-plugin:install</td><td>将项目构建输出到本地仓库</td></tr><tr><td>deploy</td><td>maven-deploy-plugin:deploy</td><td>将项目构建输出到远程仓库</td></tr></tbody></table><p>上面只是列举了 default 生命周期绑定了插件的阶段，并非 default 的所有阶段。</p><p><strong>自定义绑定</strong></p><p>除了上面的内置绑定外，插件还支持自定义绑定，拿 <code>maven-compiler-plugin</code>插件举例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br> <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>diy-compile<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>testCompile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>上面代码将 <code>maven-compiler-plugin</code>插件的 <code>testCompile</code>目标绑定到 default 上面周期的 verify 阶段。当运行 mvn verify 时，该插件的 testCompile 目标就会执行。phase 表示绑定的声明周期阶段，因为插件可以在一个生命周期阶段运行多个方法，所以可以配置多个目标，即多个 goal。</p><p>有的时候，没有使用 phase，插件目标目标也能绑定到声明周期的阶段中去。这是因为很多插件在目标的编写时候已经定义好了默认绑定的阶段。可以使用命令查看 <code>mvn help:describe -Dplugin=compiler  -Ddetail</code> 查看插件的详细信息，默认绑定的阶段等。</p><p><strong>当一个阶段有多个插件目标绑定时，执行顺序与插件的声明顺序有关，先声明先执行</strong>。</p><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>插件目标像 Java 中的函数一样，执行相应的功能，并且还有参数，这些参数的具体值，我们可以配置，传递给插件目标。</p><h3 id="命令行插件配置"><a href="#命令行插件配置" class="headerlink" title="命令行插件配置"></a>命令行插件配置</h3><p>命令行插件配置算是比较经典的配置手段了，在 Java 中可以使用 <code>-D</code> 参数配置系统属性。Maven 简单的重用了该参数，在检查插件的时候检查系统属性，实现了插件参数的配置。</p><p>例如：<code>maven-compiler-plugin</code> 插件就提供了一个 <code>maven.test.skip</code>的系统属性，通过配置是否跳过测试。以下是该插件 <code>testCompile</code>目标的 skip 参数详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">skip<br>     User property: maven.test.skip<br>     Set this to &#x27;true&#x27; to bypass compilation of test sources. Its use is NOT<br>     RECOMMENDED, but quite convenient on occasion.<br><br></code></pre></td></tr></table></figure><p>可以看到该参数可以使用 <code>maven.test.skip</code>，因此可以编写命令 <code>maven install -Dmaven.test.skip=true</code> 用来跳过测试。</p><h3 id="POM-插件配置"><a href="#POM-插件配置" class="headerlink" title="POM 插件配置"></a>POM 插件配置</h3><p>对于一些固定常用的参数，可以直接在 pom 文件中配置，使用 <code>configuration</code> 配置 参数，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">warSourceExcludes</span>&gt;</span>WEB-INF/classes<span class="hljs-tag">&lt;/<span class="hljs-name">warSourceExcludes</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要插件在不同声明周期执行相同的目标，但是执行的参数不一样，就需要另外配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>diy-compile<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>install<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>testCompile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                  ...<br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                   <br>                      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>diy-test<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>testCompile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                  ...<br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上同一插件的同一目标绑定了不同的声明周期阶段，具体的参数配置只需要在各自的 <code>configuration</code> 配置即可。</p><h2 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>为了方便使用命令管理多个模块，就需要用到<strong>聚合。</strong>例如：项目中有 A，B 两个模块，需要对两个项目都执行清理 操作，因此你需要跑到 A 模块下执行 <code>mvn clean</code>命令，然后再跑到 B 模块下执行相同的命令。模块较多的话就比较麻烦。</p><p>使用聚合就可以解决上述问题。新建一个聚合模块，然后将聚合模块的打包方式修改成 pom，并使用标签 <code>modules</code>引入模块 A，B，然后对聚合模块操作即可。示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>A模块目录名称<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>B模块目录名称<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>聚合模块可以与其他模块同级，同级只需要将 module 改为 <code>&lt;module&gt;../A模块目录名称&lt;/module&gt;</code> ，特别注意的是聚合模块的打包方式一定要修改成pom。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的出现是为了消除重复，Java 如此，Maven 中的 pom 也是如此。假如有 A，B两个模块都需要 <code>spring-core</code> 2.0 版本的依赖，正常的做法就是在两个模块中分别声明同一个 <code>spring-core</code> 依赖。</p><p>使用继承消除重复配置，新建一个模块 <code>C</code>，修改打包方式为 pom (与聚合操作一致)，接着引入 <code>spring-core</code>依赖，即可。这时 A，B 模块只需要继承 C 的 pom 即可，代码如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>C 模块groupId<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>C 模块artifactId<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>C 模块version<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>C 模块pom.xml路径（相对路径）<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入 C 模块的坐标信息，并使用 <code>relativePath</code> 指向 C 模块的 pom 文件路径。Maven 会首先根据 <code>relativePath</code> 找 pom，找不到就去本地仓库找，如果不配置 realtivePath，那默认值是 <code>../pom.xml</code>，也就是说 Maven 默认父 模块在当前模块的上一层目录。</p><p>在上面的例子中 A，B 模块可以不用声明 gruopId 和 version，这些信息都从 C 模块中继承过来了，如果子模块要使用自己的 groupId 和 version 直接显示的声明即可。</p><h4 id="Maven-可继承的-POM-元素"><a href="#Maven-可继承的-POM-元素" class="headerlink" title="Maven 可继承的 POM 元素"></a>Maven 可继承的 POM 元素</h4><ul><li>groupId 项目组 ID ，项目坐标的核心元素。</li><li>version 项目版本，项目坐标的核心元素。</li><li>description 项目的描述信息。</li><li>organization 项目的组织信息。</li><li>inceptionYear 项目的创始年份。</li><li>url 项目的 url 地址。</li><li>develoers 项目的开发者信息。</li><li>contributors 项目的贡献者信息。</li><li>distributionManagerment 项目的部署信息。</li><li>issueManagement 缺陷跟踪系统信息。</li><li>ciManagement 项目的持续继承信息。</li><li>scm 项目的版本控制信息。</li><li>mailingListserv 项目的邮件列表信息。</li><li>properties 自定义的 Maven 属性。</li><li>dependencies 项目的依赖配置。</li><li>dependencyManagement 醒目的依赖管理配置。</li><li>repositories 项目的仓库配置。</li><li>build 包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等。</li><li>reporting 包括项目的报告输出目录配置、报告插件配置等。</li></ul><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>上面说到依赖可以继承，但是并不是每一个模块都需要引入父模块的依赖。例如一个工具模块，就不太需要 <code>spring</code>这些依赖包，但是因为继承关系，导致工具模块也引入了这些包，为了避免这种情况就需要使用新的元素 dependencyManagement。</p><p>dependencyManagement 可以让子类自行的选择继承父模块的依赖，只需要将父模块的依赖用元素 <code>dependencyManagement</code>包裹起来即可。例如父模块依赖代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子模块引用父模块依赖，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子模块 pom 直接引用所需要的依赖坐标即可，上面代码只引用了父模块的 junit 依赖，因此 spring-core 不会被引入。子模块还去掉了依赖的 version 和 scope 信息，这是因为继承了父模块的 pom，完整的依赖声明已经在父 pom 中了，因此子模块只需要 groupId 和 artifactId 就能获取对应的依赖信息，这样使用也能使所有子模块统一依赖版本，降低依赖冲突概率。</p><p><strong>import 和 dependencyManagement</strong></p><p>上面的章节说到过依赖范围 <code>import</code>，import 需要配合 dependencyManagement 使用。作用是将目标模块的 pom 中的 dependencyManagement 配置，导入并合并到当前模块的 pom 的 dependencyManagement 配置中。</p><p>例如想要在另一个模块中使用父模块完全一样的 dependencyManagement 配置，需要在 pom 编写如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>父模块 groupId<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>父模块 artifactId<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>父模块 version<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4><p>插件管理的思想和依赖管理一致。在父 pom 中使用 <code>pluginManagement</code> 包裹插件，即可达到与依赖管理一样的效果。</p><p>子模块使用插件只需要声明 <code>groupid</code> 和 <code>artifactId</code>即可。若子模块需要修改插件的配置信息，只需要在模块中覆盖父类的配置即可。</p><h3 id="继承和聚合关系"><a href="#继承和聚合关系" class="headerlink" title="继承和聚合关系"></a>继承和聚合关系</h3><p>都要将打包方式改为 pom，一个模块可以既是聚合模块，又是父模块。</p><h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>我们都知道 Maven 项目的源代码文件夹是 src&#x2F;main&#x2F;java，编译输出文件夹是 target&#x2F;classes&#x2F;，这是 maven 的约定，我们只需要准守即可。当然想要自己改变这些约定也可以做到，但是不推荐。我们准守的这些约定实际上是 maven 的超级 pom 帮我们配置了这些信息。</p><p>所有的 maven 项目都隐式地继承了超级 pom，这个超级 pom 配置了源代码目录路径，编译输出路径，测试代码路径等等，这些配置信息就是我们要准守的约定。超级 pom 可以到 maven 的安装目录下 <code>/lib/maven-model-builder-x.x.x.jar</code>文件（x.x.x 代表的是 maven 版本 ），解压之后找到 <code>org/apache/maven/pom-4.0.0.xml</code> 文件即可查看配置信息。这是我本机的超级 pom 的部分配置信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/test-classes<span class="hljs-tag">&lt;/<span class="hljs-name">testOutputDirectory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scriptSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/scripts<span class="hljs-tag">&lt;/<span class="hljs-name">scriptSourceDirectory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/java<span class="hljs-tag">&lt;/<span class="hljs-name">testSourceDirectory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- <span class="hljs-doctag">NOTE:</span> These plugins will be removed from future versions of the super POM --&gt;</span><br>     <span class="hljs-comment">&lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2-beta-5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-release-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h2><p>之前使用到聚合的知识，用一个聚合模块包含多个模块，只要对聚合模块操作即可影响到包含的模块。我们把包含的这一堆模块叫做<strong>反应堆。</strong>为啥叫反应堆呢，因为需要发生反应，在构建这些模块的时候肯定存在一个构建顺序，依次构建。</p><p>例如聚合模块 A，按顺序包含模块 B，C，D。按照正常理解，对 A 模块进行构建时，我们会认为，B，C，D 会按照顺序依次构建，但实际的构建顺序却不一定是我们预期的那样。</p><p>实际的构建顺序是这样的：<strong>Maven 先按照顺序读取 pom，如果 pom 没有依赖模块，那么就构建该模块，否则就构建其依赖模块，若依赖模块还依赖其他模块，则进一步构建依赖模块。</strong></p><p>在实际开发中可以使用一些参数，来决定需要构建的模块，或者指定模块构建的顺序。假设模块 A，模块 B 都依赖于模块 C。</p><ul><li>-am， 同时构建所列模块的依赖模块。例如：<code>mvn clean install -pl A -am</code>，结果顺序：C ，A。</li><li>-amd 同时构建依赖于所列模块的模块。例如：<code>mvn clean install -pl C -amd</code>，结果顺序：C，A，B</li><li>-pl 构建指定的模块，模块间用逗号分隔。例如：<code>mvn clean install -pl A，B</code></li><li>-rf  在完整的构建顺序基础上指定从哪个模块开始构建。例如：<code>mvn clean install -pl C -amd -rf B</code> 结果顺序：C，B，A</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection 笔记</title>
    <link href="/2021/08/18/Collection%20%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <url>/2021/08/18/Collection%20%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="判断线程安全类的准则"><a href="#判断线程安全类的准则" class="headerlink" title="判断线程安全类的准则"></a>判断线程安全类的准则</h2><p>当需要在多线程环境下，使用一些类时，我们首先就需要判断当前类是否是线程安全的，否则出现线程安全问题。</p><p><strong>准则一</strong></p><p>最直接，方便的准则就是查看类的源代码注释，上面提到的集合类都在注释声明了该类不是线程安全的。查找注释的时候可以直接搜索 <code>Thread</code>或者 <code>synchronize</code>关键字。</p><p><strong>准则二</strong></p><p>查看有没有使用同步语句：<code>java.util.concurrent.* / synchronize / Object.wait()</code></p><p>如果以上准则都不满足，几乎可以断定不是线程安全的类。</p><h2 id="多线程环境下使用-Collection"><a href="#多线程环境下使用-Collection" class="headerlink" title="多线程环境下使用 Collection"></a>多线程环境下使用 Collection</h2><p><strong>多线程换环境下使用 ArrayList</strong></p><ul><li>最好的办法是使用 <code>Collections.sysnchronized(new ArrayList())</code></li><li>慎用 CopyOnWriteArrayList，性能问题</li></ul><p><strong>多线程换环境下使用 HashSet &#x2F; HashMap</strong></p><ul><li>HashMap 无脑使用 <code>ConcurrentHashMap</code> 替换</li><li>HashSet 没有对应的 <code>ConcurrentHashSet</code>类，可使用以下方法<ul><li><code>Collections._newSetFromMap_(new ConcurrentHashMap&lt;&gt;());</code> 从一个 ConcurrentHashMap 获取 HashSet</li><li>Guava 提供的 <code>Sets._newConcurrentHashSet_();</code>方法，创建一个线程安全的 Set。</li></ul></li></ul><p><strong>多线程换环境下使用 TreeSet &#x2F; TreeMap</strong></p><ul><li>使用 <code>ConcurrentSkipListSet</code> 和 <code>ConcurrentSkipListMap</code> （很少使用到），都是基于 <a href="https://www.jianshu.com/p/9d8296562806">Skip List</a> 这一数据结构实现的。</li></ul><p><strong>多线程环境下新的 Collection 类</strong></p><ul><li>BlockingQueue 可以等待的队列。</li><li>当队列为空的时候，获取元素就会进入等待状态，直到队列中有元素。插入元素时相反。</li><li>使用场景很高级，很少使用到。一旦使用上，就要格外的小心。</li><li>常用的实现 ArrayBlockingQueue，SynchronousQueue。</li></ul><h2 id="Collection-工具方法集合"><a href="#Collection-工具方法集合" class="headerlink" title="Collection 工具方法集合"></a>Collection 工具方法集合</h2><p><strong>返回一个空集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.emptyList();<br>Collections.emptyMap();<br>Collections.emptySet();<br>...<br></code></pre></td></tr></table></figure><p>emptySet，emptyMap，emptyList，返回一个空集合。该空集合是全局唯一的，并且自动泛型化，在方法返回的时候很适用，节省时间和内存。</p><p><strong>将集合变成线程安全的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">unSafeList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-type">Set</span> <span class="hljs-variable">unSafeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br><span class="hljs-type">Map</span> <span class="hljs-variable">unSafeMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>Collections.synchronizedList(unSafeList);<br>Collections.synchronizedMap(unSafeMap);<br>Collections.synchronizedSet(unSafeSet);<br></code></pre></td></tr></table></figure><p>synchronizedList，synchronizedMap，synchronizedSet 把制定的集合变成线程安全的。实际上只是把对应的集合中的方法加锁，优先使用 <code>Concurret</code> 集合类。</p><p><strong>将集合变成不可变的（只读）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">modifiableList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-type">Set</span> <span class="hljs-variable">modifiableSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br><span class="hljs-type">Map</span> <span class="hljs-variable">modifiableMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>Collections.unmodifiableList(modifiableList);<br>Collections.unmodifiableSet(modifiableSet);<br>Collections.unmodifiableMap(modifiableMap);<br></code></pre></td></tr></table></figure><p>unmodifiableList，unmodifiableSet，unmodifiableMap 把指定的集合变成不可变的集合（也可以使用 Guava 的 Immutable ）。</p><h2 id="Queue-与-Deque"><a href="#Queue-与-Deque" class="headerlink" title="Queue 与 Deque"></a>Queue 与 Deque</h2><p>Queue 是数据结构中的经典的「队列」，一个方向进，一个方向出。</p><p>Deque 是「双端队列」，两个方向都可以进出。</p><p>Queue 和 Deque 的常用实现是 <strong>LinkedList。</strong></p><h2 id="Vector-和-Stack"><a href="#Vector-和-Stack" class="headerlink" title="Vector 和 Stack"></a>Vector 和 Stack</h2><p>Vector 就是 ArrayList 的前生。</p><p>Stack 是数据结构中经典的「栈」，使用它的好处就是能够让人一眼看出你的意图。</p><p>**Vector 和 Stack 都是 JDK 中非常古老的 class，并不是 interface! **两个类都不推荐使用，前者可以用 ArrayList 代替，后者可用 Deque 代替。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>优先级队列，根据优先级进行排列。基于数据结构<strong>二叉堆（特殊的二叉树）</strong>实现，根节点的元素比所有子节点的元素都小。因此可以快速获取最大和最小元素。</p><p>PriorityQueue 的实现必须提供比较器，在初始化队列的时候提供，或者由包含的元素提供。如果两个都不提供比较器，则报错。该优先级队列非线程安全。</p><p>与 TreeSet 区别：数据结构不同，检索速度非常快（复杂度 O(1)），移除元素调整比 TreeSet 更快，遍历不保证有序。</p><h2 id="Guava-对-Collection-体系的有力扩展"><a href="#Guava-对-Collection-体系的有力扩展" class="headerlink" title="Guava 对 Collection 体系的有力扩展"></a>Guava 对 Collection 体系的有力扩展</h2><p><strong>快速创建一个集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Sets.newHashSet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>Lists.newArrayList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>Lists &#x2F; Sets &#x2F; Maps，方便的工具方法 newArrayList() &#x2F; newLinkedList() &#x2F; newHashSet() &#x2F; newHashMap() 等，快速创建一个集合。</p><p><strong>快速创建一个不可变的 Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ImmutableMap.of(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>);<br>ImmutableMap.builder()<br>        .put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>)<br>        .put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>)<br>        .put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">3</span>)<br>        .put(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-number">4</span>)<br>        .put(<span class="hljs-string">&quot;key5&quot;</span>, <span class="hljs-number">5</span>)<br>        .build();<br></code></pre></td></tr></table></figure><p>ImmutableMap 快速创建一个不可变的 Map，如果 Map 中的元素较少，可以使用 of 方法，元素较多使用 builder 方法。</p><p><strong>创建特殊的 Set 和 Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Multiset</span> <span class="hljs-variable">multiset</span> <span class="hljs-operator">=</span> HashMultiset.create();<br>multiset.add(<span class="hljs-string">&quot;zz&quot;</span>);<br>multiset.add(<span class="hljs-string">&quot;zz&quot;</span>);<br>multiset.add(<span class="hljs-number">1</span>);<br>multiset.add(<span class="hljs-number">2</span>);<br>System.out.println(multiset);<br><br><span class="hljs-comment">// 打印结果</span><br>[zz x <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br><br><span class="hljs-type">Multimap</span> <span class="hljs-variable">multimap</span> <span class="hljs-operator">=</span> HashMultimap.create();<br>multimap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;z&quot;</span>);<br>multimap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>multimap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>multimap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>System.out.println(multimap);<br><br><span class="hljs-comment">// 打印结果</span><br>&#123;<span class="hljs-number">1</span>=[a, b, c], <span class="hljs-number">2</span>=[z]&#125;<br></code></pre></td></tr></table></figure><p>Multiset 可以记录重复插入元素的次数，MultiMap 支持同一个键插入多个元素。</p><p><strong>BiMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">BiMap&lt;String, Integer&gt; map = HashBiMap.create();<br>map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<br>map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<br>System.out.println(map.get(<span class="hljs-string">&quot;a&quot;</span>));<br>System.out.println(map.inverse().get(<span class="hljs-number">3</span>));<br><br><span class="hljs-comment">// 打印结果</span><br><span class="hljs-number">1</span><br>c<br></code></pre></td></tr></table></figure><p>BiMap 是一个双向 Map，既可以键映射到值，也支持值映射到键。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code Specification</title>
    <link href="/2021/08/16/Code-Specification/"/>
    <url>/2021/08/16/Code-Specification/</url>
    
    <content type="html"><![CDATA[<h2 id="使用条件语句"><a href="#使用条件语句" class="headerlink" title="使用条件语句"></a>使用条件语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>原则一：要使得正常情况执行代码过程清晰，优先考虑代码正常执行情况。</p><p>原则二：不要用 “&gt;” 代替 “&gt;&#x3D;” 或用 “&lt;” 代替 “&lt;&#x3D;”。</p><p>原则三：正常情况的处理放在 if 后面而不是 else 后面（保证能快速找到代码正常的执行过程）。</p><p>原则四：if 子句后面跟随一个有意义的语句，避免空语句。</p><h3 id="if-else-if-else-语句"><a href="#if-else-if-else-语句" class="headerlink" title="if-else if-else 语句"></a>if-else if-else 语句</h3><p>原则一：把常见的情况放在最前面（既提高了阅读效率，也变相的提高了系统执行效率）。</p><p>原则二：确保所有情况都考虑到，else 子句用作出错消息或者不考虑的情况。</p><h3 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h3><p>原则一：为 case 选择最有效的排列顺序，当 case 超过3个，排序就更为重要。以下是一些排序原则。</p><ul><li>按字母顺序或按数字顺序排列</li><li>把正常的情况放在前面</li><li>按执行频率排列，最近常执行的 case 子句放在最前面</li></ul><p>原则二：尽量简化 case 子句中的操作，避免逻辑嵌套，可以将要执行的子句抽取成一个方法，使得逻辑更清晰。</p><p>原则三：不要为了使用 switch 语句而刻意制造一个变量。</p><p>原则四：利用 default 子句来检测错误的情况，而不是代替一种 case 的情况。</p><p>原则五：避免代码执行执行越过 case，每条 case 都应该及时加 <code>break;</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="一个值得养成的测试习惯"><a href="#一个值得养成的测试习惯" class="headerlink" title="一个值得养成的测试习惯"></a>一个值得养成的测试习惯</h3><p>:::success<br>每当你遇见一个bug，先写一个测试来清楚地复现它。仅当测试通过时，才视为bug修完。只要测试存在一天，我就知道这个错误永远不会再复现。这个bug和对应的测试也会提醒我思考：测试集里是否还有这样不被阳光照耀到的犄角旮旯<br>:::</p><h3 id="推荐的测试方法"><a href="#推荐的测试方法" class="headerlink" title="推荐的测试方法"></a>推荐的测试方法</h3><p>方法一：对每一项相关的需求进行测试，以确保需求都已经被实现。</p><p>方法二：对每一个相关的设计关注点进行测试，以确保设计已经被实现。</p><p>方法三：用 <code>基础测试</code>来扩充针对需求和设计的详细测试用例。</p><p>方法四：使用一个检查表，记录项目迄今为止所犯的错误类型。</p><h3 id="测试技巧"><a href="#测试技巧" class="headerlink" title="测试技巧"></a>测试技巧</h3><p>技巧一：选择最有可能找到错误的测试用例。</p><p>技巧二：结构化的基础测试，需要去测试程序中每一条语句至少一次。所需基础测试用例的最少数量可以使用该方法计算：<code>程序本身记作1，每遇到关键字时加1，如：if,while,for,and,or,case</code> 。</p><p>技巧三：数据流测试，对于数据的状态进行测试。状态可以是：<code>已定义</code>，<code>已使用</code>，<code>已销毁</code>。还有一些术语用来描述对数据进行某种操作之前或之后的状态：<code>已进入</code>，<code>已退出</code>。对于所有已定义-已使用的组合进行测试是比较好的实践。</p><p>技巧四：边界值分析，对于边界值一般会遇到三种情况：大于边界值，等于边界值，小于边界值。为这些情况编写测试用例。</p><p>技巧五：使用几类坏数据测试，坏数据包括（数据太少，太多数据，错误的数据情况，长度错误的数据，未初始化的数据）。使用几类好数据测试，好数据包括（所期望的值，最小的正常情况，最大的正常情况，与旧数据的兼容性）</p><p>技巧六：采用容易的手工检查的测试用例。如计算薪水，可以输入一些自身能判断的数据123，根据薪水规则计算出的结果，判断是否符合自己的预期。</p><h2 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h2><h2 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h2><h3 id="返回真伪值的方法"><a href="#返回真伪值的方法" class="headerlink" title="返回真伪值的方法"></a>返回真伪值的方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Prefix</td><td>is</td><td>对象是否符合期待的状态</td><td>isValid</td></tr><tr><td>Prefix</td><td>can</td><td>对象<strong>能否执行</strong>所期待的动作</td><td>canRemove</td></tr><tr><td>Prefix</td><td>should</td><td>调用方执行某个命令或方法是<strong>好还是不好</strong>,<strong>应不应该</strong>，或者说<strong>推荐还是不推荐</strong></td><td>shouldMigrate</td></tr><tr><td>Prefix</td><td>has</td><td>对象<strong>是否持有</strong>所期待的数据和属性</td><td>hasObservers</td></tr><tr><td>Prefix</td><td>needs</td><td>调用方<strong>是否需要</strong>执行某个命令或方法</td><td>needsMigrate</td></tr></tbody></table><h3 id="用来检查的方法"><a href="#用来检查的方法" class="headerlink" title="用来检查的方法"></a>用来检查的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>ensure</td><td>检查是否为期待的状态，不是则抛出异常或返回 error code</td><td>ensureCapacity</td></tr><tr><td>validate</td><td>检查是否为正确的状态，不是则抛出异常或返回 error code</td><td>validateInputs</td></tr></tbody></table><h3 id="按需求才执行的方法"><a href="#按需求才执行的方法" class="headerlink" title="按需求才执行的方法"></a>按需求才执行的方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Suffix</td><td>IfNeeded</td><td>需要的时候执行，不需要的时候什么都不做</td><td>drawIfNeeded</td></tr><tr><td>Prefix</td><td>might</td><td>同上</td><td>mightCreate</td></tr><tr><td>Prefix</td><td>try</td><td>尝试执行，失败时抛出异常或是返回 errorcode</td><td>tryCreate</td></tr><tr><td>Suffix</td><td>OrDefault</td><td>尝试执行，失败时返回默认值</td><td>getOrDefault</td></tr><tr><td>Suffix</td><td>OrElse</td><td>尝试执行、失败时返回实际参数中指定的值</td><td>getOrElse</td></tr><tr><td>Prefix</td><td>force</td><td>强制尝试执行。error 抛出异常或是返回值</td><td>forceCreate, forceStop</td></tr></tbody></table><h3 id="异步相关方法"><a href="#异步相关方法" class="headerlink" title="异步相关方法"></a>异步相关方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Prefix</td><td>blocking</td><td>线程阻塞方法</td><td>blockingGetUser</td></tr><tr><td>Suffix</td><td>InBackground</td><td>执行在后台的线程</td><td>doInBackground</td></tr><tr><td>Suffix</td><td>Async</td><td>异步方法</td><td>sendAsync</td></tr><tr><td>Suffix</td><td>Sync</td><td>对应已有异步方法的同步方法</td><td>sendSync</td></tr><tr><td>Prefix or Alone</td><td>schedule</td><td>Job 和 Task 放入队列</td><td>schedule, scheduleJob</td></tr><tr><td>Prefix or Alone</td><td>post</td><td>同上</td><td>postJob</td></tr><tr><td>Prefix or Alone</td><td>execute</td><td>执行异步方法（注：我一般拿这个做同步方法名）</td><td>execute, executeTask</td></tr><tr><td>Prefix or Alone</td><td>start</td><td>同上</td><td>start, startJob</td></tr><tr><td>Prefix or Alone</td><td>cancel</td><td>停止异步方法</td><td>cancel, cancelJob</td></tr><tr><td>Prefix or Alone</td><td>stop</td><td>同上</td><td>stop, stopJob</td></tr></tbody></table><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Prefix</td><td>on</td><td>事件发生时执行</td><td>onCompleted</td></tr><tr><td>Prefix</td><td>before</td><td>事件发生前执行</td><td>beforeUpdate</td></tr><tr><td>Prefix</td><td>pre</td><td>同上</td><td>preUpdate</td></tr><tr><td>Prefix</td><td>will</td><td>同上</td><td>willUpdate</td></tr><tr><td>Prefix</td><td>after</td><td>事件发生后执行</td><td>afterUpdate</td></tr><tr><td>Prefix</td><td>post</td><td>同上</td><td>postUpdate</td></tr><tr><td>Prefix</td><td>did</td><td>同上</td><td>didUpdate</td></tr><tr><td>Prefix</td><td>should</td><td>确认事件是否可以发生时执行</td><td>shouldUpdate</td></tr></tbody></table><h3 id="操作对象生命周期的方法"><a href="#操作对象生命周期的方法" class="headerlink" title="操作对象生命周期的方法"></a>操作对象生命周期的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>initialize</td><td>初始化。也可作为延迟初始化使用</td><td>initialize</td></tr><tr><td>pause</td><td>暂停</td><td>onPause ，pause</td></tr><tr><td>stop</td><td>停止</td><td>onStop，stop</td></tr><tr><td>abandon</td><td>销毁的替代</td><td>abandon</td></tr><tr><td>destroy</td><td>同上</td><td>destroy</td></tr><tr><td>dispose</td><td>同上</td><td>dispose</td></tr></tbody></table><h3 id="与集合操作相关的方法"><a href="#与集合操作相关的方法" class="headerlink" title="与集合操作相关的方法"></a>与集合操作相关的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>contains</td><td>是否持有与指定对象相同的对象</td><td>contains</td></tr><tr><td>add</td><td>添加</td><td>addJob</td></tr><tr><td>append</td><td>添加</td><td>appendJob</td></tr><tr><td>insert</td><td>插入到下标 n</td><td>insertJob</td></tr><tr><td>put</td><td>添加与 key 对应的元素</td><td>putJob</td></tr><tr><td>remove</td><td>移除元素</td><td>removeJob</td></tr><tr><td>enqueue</td><td>添加到队列的最末位</td><td>enqueueJob</td></tr><tr><td>dequeue</td><td>从队列中头部取出并移除</td><td>dequeueJob</td></tr><tr><td>push</td><td>添加到栈头</td><td>pushJob</td></tr><tr><td>pop</td><td>从栈头取出并移除</td><td>popJob</td></tr><tr><td>peek</td><td>从栈头取出但不移除</td><td>peekJob</td></tr><tr><td>find</td><td>寻找符合条件的某物</td><td>findById</td></tr></tbody></table><h3 id="与数据相关的方法"><a href="#与数据相关的方法" class="headerlink" title="与数据相关的方法"></a>与数据相关的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>create</td><td>新创建</td><td>createAccount</td></tr><tr><td>new</td><td>新创建</td><td>newAccount</td></tr><tr><td>from</td><td>从既有的某物新建，或是从其他的数据新建</td><td>fromConfig</td></tr><tr><td>to</td><td>转换</td><td>toString</td></tr><tr><td>update</td><td>更新既有某物</td><td>updateAccount</td></tr><tr><td>load</td><td>读取</td><td>loadAccount</td></tr><tr><td>fetch</td><td>远程读取</td><td>fetchAccount</td></tr><tr><td>delete</td><td>删除</td><td>deleteAccount</td></tr><tr><td>remove</td><td>删除</td><td>removeAccount</td></tr><tr><td>save</td><td>保存</td><td>saveAccount</td></tr><tr><td>store</td><td>保存</td><td>storeAccount</td></tr><tr><td>commit</td><td>保存</td><td>commitChange</td></tr><tr><td>apply</td><td>保存或应用</td><td>applyChange</td></tr><tr><td>clear</td><td>清除数据或是恢复到初始状态</td><td>clearAll</td></tr><tr><td>reset</td><td>清除数据或是恢复到初始状态</td><td>resetAll</td></tr></tbody></table><h3 id="成对出现的动词"><a href="#成对出现的动词" class="headerlink" title="成对出现的动词"></a>成对出现的动词</h3><table><thead><tr><th>单词</th><th>意义</th></tr></thead><tbody><tr><td>get 获取</td><td>set 设置</td></tr><tr><td>add 增加</td><td>remove 删除</td></tr><tr><td>create 创建</td><td>destory 移除</td></tr><tr><td>start 启动</td><td>stop 停止</td></tr><tr><td>open 打开</td><td>close 关闭</td></tr><tr><td>read 读取</td><td>write 写入</td></tr><tr><td>load 载入</td><td>save 保存</td></tr><tr><td>create 创建</td><td>destroy 销毁</td></tr><tr><td>begin 开始</td><td>end 结束</td></tr><tr><td>backup 备份</td><td>restore 恢复</td></tr><tr><td>import 导入</td><td>export 导出</td></tr><tr><td>split 分割</td><td>merge 合并</td></tr><tr><td>inject 注入</td><td>extract 提取</td></tr><tr><td>attach 附着</td><td>detach 脱离</td></tr><tr><td>bind 绑定</td><td>separate 分离</td></tr><tr><td>view 查看</td><td>browse 浏览</td></tr><tr><td>edit 编辑</td><td>modify 修改</td></tr><tr><td>select 选取</td><td>mark 标记</td></tr><tr><td>copy 复制</td><td>paste 粘贴</td></tr><tr><td>undo 撤销</td><td>redo 重做</td></tr><tr><td>insert 插入</td><td>delete 移除</td></tr><tr><td>add 加入</td><td>append 添加</td></tr><tr><td>clean 清理</td><td>clear 清除</td></tr><tr><td>index 索引</td><td>sort 排序</td></tr><tr><td>find 查找</td><td>search 搜索</td></tr><tr><td>increase 增加</td><td>decrease 减少</td></tr><tr><td>play 播放</td><td>pause 暂停</td></tr><tr><td>launch 启动</td><td>run 运行</td></tr><tr><td>compile 编译</td><td>execute 执行</td></tr><tr><td>debug 调试</td><td>trace 跟踪</td></tr><tr><td>observe 观察</td><td>listen 监听</td></tr><tr><td>build 构建</td><td>publish 发布</td></tr><tr><td>input 输入</td><td>output 输出</td></tr><tr><td>encode 编码</td><td>decode 解码</td></tr><tr><td>encrypt 加密</td><td>decrypt 解密</td></tr><tr><td>compress 压缩</td><td>decompress 解压缩</td></tr><tr><td>pack 打包</td><td>unpack 解包</td></tr><tr><td>parse 解析</td><td>emit 生成</td></tr><tr><td>connect 连接</td><td>disconnect 断开</td></tr><tr><td>send 发送</td><td>receive 接收</td></tr><tr><td>download 下载</td><td>upload 上传</td></tr><tr><td>refresh 刷新</td><td>synchronize 同步</td></tr><tr><td>update 更新</td><td>revert 复原</td></tr><tr><td>lock 锁定</td><td>unlock 解锁</td></tr><tr><td>check out 签出</td><td>check in 签入</td></tr><tr><td>submit 提交</td><td>commit 交付</td></tr><tr><td>push 推</td><td>pull 拉</td></tr><tr><td>expand 展开</td><td>collapse 折叠</td></tr><tr><td>begin 起始</td><td>end 结束</td></tr><tr><td>start 开始</td><td>finish 完成</td></tr><tr><td>enter 进入</td><td>exit 退出</td></tr><tr><td>abort 放弃</td><td>quit 离开</td></tr><tr><td>obsolete 废弃</td><td>depreciate 废旧</td></tr><tr><td>collect 收集</td><td>aggregate 聚集</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2021/08/11/String/"/>
    <url>/2021/08/11/String/</url>
    
    <content type="html"><![CDATA[<p>首先我们要有一个概念，互联网基本上就只干一件事「处理字符串」。我们看的纷繁复杂的网页，都是通过字节传输的，然后经过一个指定的编码转化成人类能看懂的字符串。因此能处理好字符串是 Web 服务器的基本要求，像 Java，PHP，Python，Ruby等。</p><h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p>背过一些八股文面试题的人都知道 String 是不可变的，那么问题来了，「不可变的定义是什么？」，「String 是如何保证不可变的呢？」</p><p><strong>不可变性</strong>，当创建一个<code>String s = &quot;abcd&quot;</code>对象的时候，JVM 的堆内存就生成了一个 String 对象，并且它的值是 abcd，而 s 变量只是指向这个对象。我们说的不可变性指的就是 JVM 生成的对象值不可变，比如刚才的 abcd，创建出来之后它就一直都是 abcd，无法被改变。</p><p>经常使用字符串的人开始疑惑了，那我 <code>String s = &quot;abcdel&quot;</code>不是也可以吗？String 的值不是改变了吗？</p><p>的确，我们是可以给 s 这个变量重新赋值。但是我们给他赋值实际上是 JVM 新创建了一个值为 abcdel 的 String 变量，然后变量 s 从指向值为 abcd 的对象，改为指向值为 abcdel 的对象。原来值为 123 的对象还是存在 JVM 中，并且值并没有改变，只是暂时没有变量指向这个对象罢了。上面的操作，可以用如图所示。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/String/ea0bb048-f46d-4e83-abb9-de31bd9a694d.png" alt="image.png"></h3><p>了解上面的知识后，回到新的问题上来，<strong>String 是如何保证不可变性呢？</strong></p><p>打开 String 的源代码，我们可以发现，String 类以及它的字符数组变量都是被 final 关键词修饰的。这就意味着 String 无法被继承，并且 char[] value 的地址指向无法修改，而且 String 所有的公开 API 都没有修改 char[] value 的方法，这就保证了 String 的不可变性。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/String/632458ad-4ea5-42bf-b25a-9c0262d646c4.png" alt="image.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>线程安全</strong>，不可变的对象天生就是线程安全的，可以随心所欲的在线程之间传递。</p><p><strong>存储安全，</strong>为什么说是存储安全呢？因为遵守了 hashCode 的约定。</p><p>正是因为 Stirng 的不可变性，才能实现存储安全。我们可以想象一下有一个 <code>Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</code>，假如 String 是可变的话，那么就违反了 hashCode 的约定，想了解 hashCode 的相关约定<a href="https://www.yuque.com/alipayygdprovgrb/uc535m/mdqx4t">访问这里</a> 。</p><p>如图所示，有三个字符串 “a”，”c”，通过计算分别得到了对应的 hashCode。如果 String 是可变的行不行呢？我们可以通过反证法来证明。现在假如 String 是可变的，那么当字符串从 a 变成了 c（即 <code>String a = &quot;a&quot; 到 a = &quot;c&quot;</code> ），他的 hashCode 要不要改变呢？分两种情况。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/String/1304755d-ad8a-4838-8262-6e408d0c7787.png" alt="image.png"></p><p>如果<strong>不改变 hashCode</strong>，那就违反了 hashCode  的第二条约定「两个对象 equals 方法为 true，则生成的 hashCode 相等」。显然 <code>a.equals(c)</code> 为true，按照约定 a 和 c 的 hashCode 应该相等。但我们的前提是 a 的 hashCode 不改变，因此 a 和 c 的 hashCode 并不相等，前后矛盾。</p><p>如果<strong>改变 hashCode</strong> ，那么就违反了 hashCode 的第一条约定「两个对象相等，hashCode 也相等」。例如我们通过如下代码让 a 和 c 为同一个对象，此时的 a &#x3D;&#x3D; c。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>如果此时 a 改变了值，hashCode 也会跟着变化。但是 a &#x3D;&#x3D; c 依然为 true，因为他们所引用的内存地址都是相同的。hashCode 规定对象相等返回相同的 hashCode ，而我们的前提是值改变，hashCode 改变，也是前后矛盾。</p><p>通过反证法，证明了 String 必须是不可变的，才能达到存储安全的目的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每当想修改字符串的时候，都必须创建新的对象来维持它的不可变性。比如下面这个循环，循环 10 次，就创建了 10 个对象，当循环次数上升到一定程度，就会给内存管理带来巨大的压力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text + i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当我们想创建值相同的两个 String 对象，有以下三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>我们分别用 &#x3D;&#x3D; 和 equals 方法来判断 a，b是否相等，三种方式输出的结果分别会是什么呢？</p><p>方法一，a，b 的值都是 “123”，因此很简单，<code>a.equals(b)</code>肯定为 true，那么 <code>a == b</code> 呢？答案是 true。因为有「字符串常量池」的存在，当 a 创建出来，字符串常量池创建 “123” 这个字符串常量，当 b 赋值的时候，发现字符串常量池中已经有相同的对象，因此直接让 b 指向这个对象，此时 a 和 b 都指向同一个对象。如图</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/String/990942c9-60db-42ef-99c4-370f76819ce7.png" alt="image.png"></h3><p>方法二，a 和 b 都是通过 new 方法，各自声明了一个值为 “123” 的对象，因此这是两个不同的对象。所以，a &#x3D;&#x3D; b 为 false，a.equals(b) 为 true。此时的 a 和 b 是指向不同的对象的，虽然他们的值都是 123。</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/String/d40d7eb9-b7c9-4f13-8720-de56aa0a2859.png" alt="image.png"></h3><p>方法三，a 赋值 b，把 a 的地址指向给 b一份。因此，a，b 两个变量都是引用同一个对象，因此 a&#x3D;&#x3D;b 为 true，a.equals(b) 也为 true。图中就是 a 指向的内存地址是 0x45，然后通过 <code>String b = a</code> b 得到 a 传来的地址，所以也指向 0x45 这个内存。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/String/2bb22221-4e5c-47cd-a667-e5f2eeec841e.png" alt="image.png"></p><h3 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h3><p>虽然 String 是不可变的，但是在实际生产中我们还是需要可变字符串，这要怎么解决呢？就拿上面那段循环代码来说，每次都要创建一个新的变量，循环次数多了必然占用过多内存。**StringBuilder **就是个可变字符串，因此我们可以使用 StringBuilder 来改进这段代码，这样就避免了创建多个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text.append(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuffer 也是可变字符串，与 StringBuilder 的区别是：StringBuilder 线程不安全，但是速度快；StringBuffer 线程安全，速度相对较慢。因此，要根据实际生产环境，选择合适的类，大多数情况优先使用 StringBuilder。</p><p>String，StringBuffer 和 StringBuilder 更多 API，请参考 Java 官方文档。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串与编码</title>
    <link href="/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <url>/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，在网络通信和存储的都是字节流，都是一大串的 0 和 1。不知道大家有没想过，存储既然是 0 和 1，为什么我们看到得都是一个个字符，汉子，英文？是不是计算机在背后偷偷的把字节转化成我们人类能看懂的语言？答案是肯定的。</p><h2 id="字符集相关概念"><a href="#字符集相关概念" class="headerlink" title="字符集相关概念"></a>字符集相关概念</h2><p>既然计算机帮我们把字节转成人类的语言，那么肯定存在着一种映射关系「字节 –&gt; 人类语言的映射」，我们把这种关系称为<strong>字符集</strong>。把字节转化成人类看懂的字符，这一过程称为<strong>编码</strong>，反之称为<strong>解码</strong>。</p><p>假如世界都用同一份字符集，同一种编码和解码方式那么就不会存在我们常见的「乱码」问题了。但正是因为世界多样性，也导致了字符集的多样性，每个国家语言不同，所使用的字符集，编解码方式也可能不同。</p><p>假如我们把阿拉伯数字看作字节，把不同语言的翻译看做编解码方式。因此，1，2，3 翻译成汉字就成了一，二，三；翻译成英文就成了 one，two，three。假如，本应该使用中文编码的字节，却使用了英文编码，这就会让没有学过英语的人看不懂，不懂 one，two，three 是什么，对于他们来说这就是<strong>乱码</strong>。</p><h2 id="字符集-Unicode"><a href="#字符集-Unicode" class="headerlink" title="字符集 Unicode"></a>字符集 Unicode</h2><p>在字符集群魔乱舞时代，有人站了出来。他把所有的地区性编码方案废弃，重新搞了一个<strong>包括了地球上所有文化、所有字母和符号的编码 Unicode</strong>。其中 uni 是英文前缀，表示「单一，一个」，因此 Unicode 的字面意思也很好理解，百度百科上翻译成「统一码，也叫万国码、单一码」。</p><p>Unicode 的设计非常的简单：<strong>从一个数字映射到一个字符</strong>。图中简单地演示了 unicode 的映射关系，实际上的对应关系并非如此。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/7fb15bf0-053f-43e0-97cf-d914e64d4df8.png" alt="image.png"></h2><p>图中所示，把左边的数字编号称作<strong>码点</strong>（code point）。</p><h3 id="Unicode-数据类型"><a href="#Unicode-数据类型" class="headerlink" title="Unicode 数据类型"></a>Unicode 数据类型</h3><p>现在换位思考下，如果让你来设计 Unicode 码表，你会用什么数据类型来存储上面的数字编号呢？</p><p>现在来对比下这些数据类型关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> --&gt; <span class="hljs-number">0</span>~<span class="hljs-number">255</span> --&gt; <span class="hljs-number">256</span><br>    <br><span class="hljs-type">short</span> --&gt; <span class="hljs-number">2</span> bytes --&gt; <span class="hljs-number">65536</span><br>    <br><span class="hljs-type">int</span> --&gt; <span class="hljs-number">4</span> bytes --&gt; 约 <span class="hljs-number">42</span> 亿<br></code></pre></td></tr></table></figure><p>很显然 byte 不合适，256个数，存中文都不够。short 存中文可能勉强够用，但是这还要包含其他国家的文字啊，加起来肯定不够用。int 42 亿个，足够全世界的文字使用， 因此选用 int 类型，实际上 Unicode 也是这么做的。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>上面提到为了包含全世界所有的文字，Unicode 使用了 int 类型。int 4个字节，对于编号在前面的字符，就会造成空间浪费。例如编号为 1 的字符，把编号转换成字节就变成 “00000000  00000000  00000000 00000001”，我们会发现前三个字节都是 0，这样造成了空间浪费。本来一个字节就能表示的编号，硬是多占用了3个字节，编号靠后的还好，靠前的大多都浪费流量，浪费空间。</p><p>如图我们把前四位编码成 4 个字节，编码后的前三个字节都是 0。更何况Unicode 兼容了 ASCII 码表，前128 位都是常用的一些字符，本来字母 “a” 只需要占用一个字节，经过 Unicode 编码后需要占用 4 个字节，不利于传输和存储。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/59ab9ba5-2ffa-416c-b1e8-2eef2d58c538.png" alt="image.png"></p><h2 id="常见的两种编码方案：UTF-8，UTF-16"><a href="#常见的两种编码方案：UTF-8，UTF-16" class="headerlink" title="常见的两种编码方案：UTF-8，UTF-16"></a>常见的两种编码方案：UTF-8，UTF-16</h2><p>正是因为 Unicode 对于靠前的码位太占空间了，所以就有了 UTF-8，UTF-16 等编码方案，用来解决空间占用问题。其实我们也很容易想到一种解决方案：把常用的字符用一个字节存储，不常用的用多个字节存储，这样就避免了 Unicode 缺陷</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 根据码位所处的范围进行不同编码。</p><p><strong>U+0000 至 U+D7FF 以及从 U+E000 至 U+FFFF 的码位</strong></p><p>第一个 Unicode 平面（码位从 U+0000 到 U+FFFF ）包含了最常用的字符。只要处于这个范围内，UTF-16 就使用两个字节存储它。我们的汉字基本上都是处于该范围，因此在 UTF-16 中，汉字大多都是两个字节。</p><p><strong>U+10000 至 U+10FFFF 的码位</strong></p><p>当处于码点处于该范围时，UTF-16 就使用 4 个字节进行存储。因此，UTF-16 将常用的字符用 2 个字节存储，不常用的用 4 个字节存储，相比 Unicode 空间节省了不少。</p><p><strong>一个简单的 UTF-16 编码过程</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">21608</span>  --&gt;  <span class="hljs-string">&quot;周&quot;</span>  <span class="hljs-comment">// 已知「周」字在 Unicode 的码位是 21608</span><br>------------------<br><span class="hljs-number">5468</span>     <span class="hljs-comment">// 转换成 16 进制</span><br></code></pre></td></tr></table></figure><p>「周」字的码位，转成 16 进制得到 5468，然后判断所属范围，很显然属于上面的第一种范围，因此「周」字需要两个字节存储 <code>54</code> <code>68</code>。我们可以在程序中打印出来 <code>System._out_.println(&#39;\u5468&#39;)</code>。</p><p><strong>BOM</strong></p><p>两个字节代表一个字符，在存储传输过程中存在着顺序问题。拿刚才的「周」字举例，虽然我们认为在传输过程中都是按照 <code>54 68</code>的顺序，但实际并非如此。在有的系统他是反过来传输的 <code>68 54</code>，为了解决这个问题，<strong>在文件的开头加入了几个不可见的字符，来声明字节顺序。这几个特殊字符称作 BOM（byte order mark），即字节顺序标记。</strong></p><p>上面的字节存储传输的方式，也有专业的名称<strong>。</strong>这个在编码中叫做大端（<strong>Big Endian 简写 BE</strong>）和小端（<strong>Little Endian 简写 LE</strong>）。在很多文本编辑器也有出现，比如我在使用的 Notepad2，就支持 UTF-16 LE BOM 和 UTF-16 BE BOM 编码方式。</p><p>顺带一说的是，Java 程序内部的存储编码方式就是 UTF-16。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>先说一个结论：<strong>如果没有意外，所有的编码方案都改成 UTF-8，UTF-8 是对多语言支持最好的一种解决方案</strong>。在 Mac&#x2F;Linux 默认编码就是 UTF-8，由于历史原因，Windows 默认的中文编码是 GBK。</p><p>UTF-8 是一种可变长的编码方式，那它是怎么做的呢？他对所有的码表进行分区，第一个分区占用一个字节，第二个占用两个字节，以此类推，最多支持到 6 个字节。UTF-8 兼容了 ASCII 码表，因此 ASCII 码表的字符在UTF-8 中占用一个字节，属于下面第一行的范围。我们使用的汉字，属于第三行的范围，因此汉字在 UTF-8 中编码占 3 个字节。下面展示了从 1 到 4分区范围。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">U+ <span class="hljs-number">0000</span> ~ U+  <span class="hljs-number">007</span>F<span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>XXXXXXX<br>U+ <span class="hljs-number">0080</span> ~ U+  <span class="hljs-number">07</span>FF<span class="hljs-punctuation">:</span> <span class="hljs-number">110</span>XXXXX <span class="hljs-number">10</span>XXXXXX<br>U+ <span class="hljs-number">0800</span> ~ U+  FFFF<span class="hljs-punctuation">:</span> <span class="hljs-number">1110</span>XXXX <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX<br>U+<span class="hljs-number">10000</span> ~ U+<span class="hljs-number">10</span>FFFF<span class="hljs-punctuation">:</span> <span class="hljs-number">11110</span>XXX <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX<br></code></pre></td></tr></table></figure><p>例如：「周」字的码位 21608，转换成 16 进制 5468 属于第三行的范围，根据他的编码规则会生成 3 个字节，编码过程如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">5</span>     <span class="hljs-number">4</span>     <span class="hljs-number">6</span>     <span class="hljs-number">8</span><br> <span class="hljs-number">0101</span>  <span class="hljs-number">0100</span>  <span class="hljs-number">0110</span>  <span class="hljs-number">1000</span>    对应的二进制<br>---------------------------<br> <span class="hljs-number">0101</span>    <span class="hljs-number">010001</span>   <span class="hljs-number">101000</span>   根据第三行的模板，每个字节中 <span class="hljs-string">&quot;x&quot;</span> 的数量分成三组<br><span class="hljs-number">1110</span>XXXX  <span class="hljs-number">10</span>XXXXXX <span class="hljs-number">10</span>XXXXXX   第三行模板<br><span class="hljs-number">11100101</span>  <span class="hljs-number">10010001</span> <span class="hljs-number">10101000</span>   代入模板<br>   E5        <span class="hljs-number">91</span>       A8     <br></code></pre></td></tr></table></figure><p>不知道大家有没思考过一个问题：UTF-8 编码之后，计算机怎么知道该读几个字节？例如上面的 <code>11100101  10010001 10101000</code>计算机怎么知道这 3 个字节是一起的，而不是分 3 次读单个字节呢？</p><p>其实仔细观察分区之后的模板就能发现端倪，第一分区首字节的第一位是 0，第二分区首字节前两位两个 1，第三个分区有三个1，计算机就是根据这个特点来进行读取的，当读到第一个字节前几位有几个 1 就读几个字节。刚才的「周」第一个字节有三个 1，因此计算机就连续读三个字节。由于这一特性，UTF-8 是不需要 BOM 的，但是 windows 的记事本默认都会加上 BOM，不支持不带 BOM 的编码（最近好像支持了），UTF-8 带</p><p>这个模板是如何设计生成的呢？编解码的算法是如何实现的呢？这里不展开（主要是我也不会），<a href="https://www.wikipedia.org/">维基百科</a>搜 UTF-8 就好了（推荐），或者访问<a href="https://taoshu.in/c-utf-8.html">他人博客</a>，了解相关内容。</p><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>GBK（国标扩展） 字符集，简称国标扩。GBK 完全不鸟 Unicode 标准，对于中文统一采用 2 个字节编码，因此在 GBK 编码中汉字是占用两个字节。</p><p>乱码的来源也与 GBK 有关，如果文件是用 Unicode 字符集编码，而你却使用 GBK 去解码，就会导致乱码问题。比如「周」字，在 Unicode 的码位是 21608，而在 GBK 的码位是 55004，通过去查 GBK 码位 21608 对应的字符就不是 「周」这个字了。</p><p>现在互联网的主流都是使用 UTF-8 编码，GBK 只适合给国人使用的网站上，局限性太大。</p><h2 id="简单的测试"><a href="#简单的测试" class="headerlink" title="简单的测试"></a>简单的测试</h2><p><strong>测试 1</strong>：一份用 UTF-16 编码的全英文文本，更改编码方式为 UTF-8，存储占用会减少吗？答案是会，因为 UTF-16对英文用两个字节编码，而 UTF-8 中英文属于第一分区，因此占用一个字节，所以改为 UTF-8 之后差不多减少一半的空间占用。</p><p><strong>测试 2</strong>：一份用 UTF-8 编码的全汉字文本，更改编码方式为 UTF-16，和 GBK，存储占用会发生什么变化？答案是都会减少占用，GBK 对中文是两个字节编码，UTF-16 对大多数中文也是两个字节编码，而 UTF-8 对中文是 3 个字节编码，因此占用会减少。</p><h2 id="一些小感悟"><a href="#一些小感悟" class="headerlink" title="一些小感悟"></a>一些小感悟</h2><p>写这篇博客的时候，遇到很多问题，本来只是想写 UTF-8 和 Unicode 的，越往下写的时候发现还有很多东西没有掌握，因此一边消化（幸运的是消化难度还能接收），一边写了这篇博客，终于是把字符，乱码相关的搞明白了。</p><p>当我感叹 UTF-8 编解码算法的时候，搜了下发明者<a href="https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A"> Ken Thompson</a>，这么多优秀的作品都与他有莫大的关联，Unix，正则，UTF-8，以及现在火热的 Go 语言，还获得图灵奖，我也只能顶礼膜拜。了解的越多，发现了计算机领域基本上所有伟大的东西，都是那么一小撮人发明的。如图是 Ken Thompson 相关的简介，想具体了解可以去维基百科搜索。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%BC%96%E7%A0%81/61ce26eb-3169-4168-bb62-c1a1929f4bcb.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常体系</title>
    <link href="/2021/05/27/Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <url>/2021/05/27/Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，离开方法的手段可以 靠 return 方法返回，而<strong>异常是 return 方法之外，离开方法的手段</strong>。</p><p>在实际工作中，经常会遇到空指针、找不到、文件找不到，等等不计其数的异常情况。那么 Java 中如何处理这些异常呢？</p><h2 id="try-x2F-catch-x2F-finally"><a href="#try-x2F-catch-x2F-finally" class="headerlink" title="try &#x2F; catch &#x2F; finally"></a>try &#x2F; catch &#x2F; finally</h2><p>当对一个文件进行写入操作的时候，所使用的 IDE 就会提醒，可能存在异常，需要处理。于是我们按照 IDE 的提示，编写了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\1.txt&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>     &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>代码主要分成两部分：try 包裹的部分，以及 catch 包裹部分，其中 catch 专门用来捕获异常。</p><p>其中 try 包裹的，表示可能运行会出错的代码。上面的代码通过 File，构建一个输出流，由于 File 对应的文件不一定存在，导致构建输出流失败，出现异常。因此，构建输出流的代码就要放到 try 中包裹起来。</p><p>catch 包裹的代码，就是对异常进行处理的流程。上面的代码是将错误信息打印到<strong>标准错误流</strong>中。</p><p>一般异常处理使用 try-catch 语句就足够了，但有遇到加载文件资源的情况，使用完之后就需要及时关闭。也许你会想把关闭资源操作放在 try-catch 语句之后，这也是可以的。但是，一旦 try-catch 中有return 操作，导致代码无法往下执行，关闭资源也就失效了。</p><p><code>finally</code>就是解决这个问题的，无论 try-catch 中如何返回，如何调用，它包裹的代码块都会执行。在 catch 语句后加上 finally，以及包裹的代码，这样就完成了一套标准的异常处理流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">//执行资源清理操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：如果 try 中可能存在多种类型异常，我们就需要多个 catch 来捕获他们。</p><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>在上面的代码中提到资源清理操作，在生产过程中，可能不止一个资源需要清理，我们需要进行多个资源关闭操作，难免会忘记对些资源清理。因此，在 Java 7 中就引入了 <code>try-with-resources</code>这个语法糖。</p><p>原先我们关闭资源操作写在 finally 中，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            os.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在我们把 <code>OutputStream os = new FileOutputStream(file)</code>声明在 try 后面的括号里，声明在里面的东西它会帮我们自动关闭，因此 <code>finally</code> 语句也不用写了。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file)) &#123;<br><br>       &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           e.printStackTrace();<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>那么问题来了，什么类型的资源会自动关闭呢 ？</p><p>答案就是<strong>所有实现了</strong> <code>AutoCloseable</code> <strong>这个接口的类</strong>，都能被自动关闭。比如上面的 <code>FileOutputStream</code>就实现了这个接口。当然智能的 IDE 在我们写 try-catch 的时候都会 给与提示，告诉你可以转成 try-catch-resources模式 </p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>上面使用 try-catch 捕获异常，但实际生产环境中也需要抛出异常，不在当前方法处理。手动抛出异常，需要用到关键字 <code>throw</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br> &#125;<br></code></pre></td></tr></table></figure><p>上面代码抛出了一个异常，但没有使用 try-catch 捕获处理。仔细观察的话，你会发现 openFile 方法后面多出了<code>throws Exception</code>，它的意思声明 openFile 方法可能会抛出异常。</p><p>那为什么要声明异常呢？直接抛出异常不行吗？</p><p>这就源于 Java 的「保护机制」，如果你的方法中可能存在异常，要么使用 try-catch 将它捕获处理，要么就使用 throws 给当前方法声明异常。任何调用了声明异常的方法，都需要处理传过来的异常，与前面一样，要么 try-catch，要么继续声明异常等待其他方法调用处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       A();<br>   &#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，B 调用 A 方法，A 方法没有 try-catch，而是使用 throws 声明异常。因此，B 方法就有两种选择，要么 try-catch 处理 A 抛出的异常，要么选择像 A 一样，声明一个异常继续向上抛出。显然 B 是同 A 一样，选择声明异常向上抛出，当其他方法调用 B 方法，也会面临 B 方法的两种选择。如果一直向上抛异常，而不使用 try-catch 处理，那么抛出的异常会击穿所有的栈帧，直到有方法将它 catch 住。</p><p><strong>Tips：throw 是抛出一个异常，而 throws 则是声明方法可能要抛出的异常</strong>，切勿混淆。</p><h2 id="Java-异常体系"><a href="#Java-异常体系" class="headerlink" title="Java 异常体系"></a>Java 异常体系</h2><ul><li>Throwable - 可以被抛出的东⻄（有毒）<ul><li>Exception - checked execption（受检异常，有毒，代表⼀种预料之中的异常）<ul><li>RuntimeException （运⾏时异常，⽆毒，代表⼀种预料之外的异常，因此不需要声明）</li></ul></li><li>Error （错误，无毒）</li></ul></li><li>catch 的级联与合并</li></ul><p>Throwable 是所有 Exception 和 Error 的父类，只要是 Throwable 类型就可以使用 throw 抛出。由于 Error 和 Exception 是他的子类，因此也能被抛出。</p><p>上面的继承体系中提到 「有毒」和「无毒」的概念，有毒指的是方法会<strong>传染</strong>，而无毒不会。「有毒」同前面的 A 方法和 B 方法一样，任何声明了有毒类型的方法，被调用之后，需要再次声明或者自己处理。任何声明了「无毒」类型的方法，被调用之后方法中无需做任何处理。「有毒」的代码实例，参考「抛出异常」章节的 A 和 B 方法。下面展示「无毒」的类型代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>    A();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们抛出了一个「无毒」类型异常 <code>RuntimeException</code>，当 B 方法调用 A 方法的时候，无需 try-catch，也无需声明异常。</p><p>这就是「有毒」和「无毒」的区别，它们有专业的术语 <code>checked</code>和<code>unchecked</code>，表示「受检」和「非受检」。「受检」表示写的代码会被检查，IDE 一般都会提示你做相应的处理。「非受检」表示写的代码不会被检查，无需做处理。</p><p>Exception 是预料之内异常，正因为在预料之内，所以 IDE 才会提示我们去处理这个异常。常见的有 <code>IOException</code>、<code>FileNotFonudException</code> 。RuntimeException 预料之外的异常，也正因为预料之外，因此 IDE 并不会对抛出的异常进行检验，因为根本无法检验。常见的有 <code>NullPointerException</code>，即空指针异常。</p><p>Error 代表一种严重的错误，他与 Exception 的区别是，前者代表不能恢复的异常，后面代表可以恢复的异常。大多数情况下，Error 代表一种不正常的情况，像内存错误（OutOfMemoryError）等。而像网络超时重连就是可恢复异常的表现。</p><p><strong>catch 的级联与合并</strong></p><p>前面我们提到过，方法中存在多个异常，就需要多个 catch 来处理，如下分别对几种不同类型的异常进行处理，进来的异常会从上到下一次比对，进入到对应的 catch 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>但上面代码存在一个问题，Exception 下面的 catch 都不会执行。因为 Exception 是他们的父类，所以每次进来都是第一个 catch 被执行，所以我们应该调整顺序从小到大排列，这样才能根据不同异常类型，做不同处理，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>      &#125;<br></code></pre></td></tr></table></figure><p>在 Java 7 之后引用了新的语法，对于处理方法完全一致的异常可以进行合并。如下，都是将错误信息打印到标准错误流中，因此我们可以对它进行合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>     &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125; <span class="hljs-keyword">catch</span> (EOFException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure><p>合并之后我们的代码就会变成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException | EOFException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="异常的一些原则"><a href="#异常的一些原则" class="headerlink" title="异常的一些原则"></a>异常的一些原则</h2><h3 id="抛出原则"><a href="#抛出原则" class="headerlink" title="抛出原则"></a>抛出原则</h3><ul><li><p>能⽤ if &#x2F; else处理的，不要使⽤异常</p><ul><li>无法保证抓出的异常是你想抓住的</li><li>相比 if 判断，异常的创建是非常昂贵的操作</li></ul></li><li><p>尽早抛出异常</p></li><li><p>异常要准确、带有详细信息</p></li><li><p>抛出异常也⽐悄悄地执⾏错误的逻辑强的多</p></li></ul><h3 id="处理原则"><a href="#处理原则" class="headerlink" title="处理原则"></a>处理原则</h3><ul><li><p>本⽅法是否有责任处理这个异常？</p><ul><li>不要处理不归⾃⼰管的异常</li></ul></li><li><p>本⽅法是否有能⼒处理这个异常？</p><ul><li>如果⾃⼰⽆法处理，就抛出</li></ul></li><li><p>如⾮万分必要，不要忽略异常</p></li></ul><h3 id="使⽤-JDK-内置的异常"><a href="#使⽤-JDK-内置的异常" class="headerlink" title="使⽤ JDK 内置的异常"></a>使⽤ JDK 内置的异常</h3><ul><li>NullPointerException</li><li>ClassNotFoundException&#x2F;NoClassDefFoundError</li><li>IllegalStateException</li><li>IllegalArgumentException</li><li>IllegalAccessException</li><li>ClassCastException</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识多线程</title>
    <link href="/2021/05/12/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/12/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在编程学习中，我们都要接触到多线程，多线程会帮系统性能带来很大提升，但是这种提升是风险与收益并存的。因此，学习并掌握多线程原理至关重要。</p><h2 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h2><p>既然有多线程，那肯定是有单线程的。那单线程是什么呢？单线程就是在特定时间系统只做一件事，这就和人一样只能「一心一意」，不能「三心二意」。</p><p>平时开发中跑的 Java 程序大多都是单应用，对于一些没有什么访问量的系统来说，能勉强支撑。反之，访问量较大的话，一个线程难以处理，很影响用户的体验。就像一片麦子一个人割，和10个人一起割时间完全不同的。因此，我们就需要用到多线程来解决性能问题。</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><p>在 Java 设计之初，就考虑到了线程，因此「多线程」在 Java 中是提供了语言级别的支持。在 Java 中使用多线程也很方便。创建线程最简单的方法就是使用 <code>new Thread()</code>，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wheatHarvest</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始割麦子&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hoeing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始锄地&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面创建两个线程，一个给他 <code>wheatHarvest()</code>割麦子的任务，另一个给他 <code>hoeing()</code>锄地的任务。创建了两个线程之后，这两件事是同时执行的，并不会说非要割完麦子，才去锄地。但上面只是创建了线程，分配了要执行的任务，线程并没有执行，要让线程执行必须调用线程的 <code>start()</code>方法，线程才会执行。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).start();<br></code></pre></td></tr></table></figure><h3 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start 和 run 的区别"></a>start 和 run 的区别</h3><p>刚开始学习多线程的时候经常将这两个方法搞混，现在重新复习一下。</p><p><strong>start 方法就是让线程开始执行，而 run 是要等待线程执行完才往下执行。</strong>如下，start 方法可以让割麦子和锄地同时运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).start();<br></code></pre></td></tr></table></figure><p>而 run 方法则是，先割麦子，等麦子割完了，然后再去锄地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).run();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).run();<br></code></pre></td></tr></table></figure><p>在这个方法上实现中，run 方法和我们的单线程基本没区别，而且还额外增加了线程的开销。</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>既然多线程能给系统性能带来提升，那我们就可以无脑使用吗？答案肯定不是的。既然享受了多线程给我们带来性能上的提升，同时我们也要承担多线程带来的安全问题。</p><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>多线程问题的来源就是，所有被线程共享的变量。当多个线程去操作一个共享变量的时候，线程安全问题就会出现。我们看如下代码，我们使用多线程操作，把共享变量 i 自增1，把结果打印看看会发生什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码，肯定会有人认为程序会按顺序输出 1~100，实际上不是如此。你可以把代码复制到自己的环境中运行，得出的结果可能会出乎你的意料，输出的顺序都乱了，并且可能会出现重复输出。为什么会出现这种情况呢？这是因为 <code>i++</code>操作并非是一个<strong>原子操作</strong></p><p>那什么是原子操作呢？原子操作就是一个不可分割的操作，之所以称作「原子操作」，我猜想和高中学的化学有关，原子是不可再分割的粒子，因此计算机就引用了这一概念。<strong>在多线程中，一个事情在某一时刻只能被一个线程操作，称作原子操作</strong></p><p>回到刚才的 <code>i++</code>操作，表面上我们以为是一步操作，实际上它包含了三个步骤：第一步，取 i 的值。第二步，把 i 的值加 1。第三步，把修改后的值写回 i。</p><p>我们使用两个线程来举例，线程1，线程2。线程1先执行，执行到 i ++的第二步操作，先取 i 的值，取到 i 的值为 0，然后把值加1，这个时候值变为 2，但是请注意，这个值并没有写回 i 中。这时，线程2开始执行了，它把 i++ 操作执行完了。由于线程1并没有把值写回 i 中，因此线程2 取到 i 的值依然为 0，把值加 1，写回到 i 中，完成 i++ 操作，并执行输出语句，打印 i 的值为1，到此线程2完成了。此时线程1继续执行刚才未完成的步骤，把值写回到 i 中，刚才线程1计算的值为1，因此把 1 写回到 i 中，完成 i++操作，打印 i 的值仍然为1。经过上面的操作，会发现 i 被重复写入了，因此我们无法保证输出的结果是 1~100。</p><p><strong>你可能会有疑问，为什么线程1执行的好好的，线程2突然就插一脚呢？</strong></p><p>这是因为，在微观上（cpu 眼中），<strong>多线程问题来源就是 cpu 的上下文切换，每个线程都会占用固定的时间周期，超过时间换线程执行。</strong>上面的例子就刚好是 cpu 的上下文切换，导致了1 这个值重复写入到 i 中。</p><p>我们打开 QQ，打开微信，打开浏览器，我们都认为他们是在同时运行的。但实际上都是 cpu 在进行切换，一会切换到微信，一会切换到浏览器，一会到 QQ，由于这个速度很快，我们就主观的认为他们是在同时运行的。多线程也是如此。</p><h3 id="线程不安全的表现（死循环，死锁，哲学家用餐）"><a href="#线程不安全的表现（死循环，死锁，哲学家用餐）" class="headerlink" title="线程不安全的表现（死循环，死锁，哲学家用餐）"></a>线程不安全的表现（死循环，死锁，哲学家用餐）</h3><blockquote><p>著名的 HashMap 的死循环问题可以点击该<a href="https://coolshell.cn/articles/9606.html">链接</a>，了解详情。</p></blockquote><h4 id="死锁详解"><a href="#死锁详解" class="headerlink" title="死锁详解"></a>死锁详解</h4><p>以下是一个简单的死锁 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread2</span>().start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;拿到lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;拿到lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上这段代码运行之后，控制台并没有输出，但是程序还在一直执行。代码最初声明了两把锁 lock1 和 lock2，使用synchronized 关键字，去获取锁。例如 <code>synchronized(lock1)</code>表示，需要拿到 lock1 才会执行后面的代码块，执行完<code>&#123;&#125;</code>包裹的代码块，锁才会释放。需要注意的是，<strong>一把锁同时只能有一个线程拿到</strong>。</p><p>因此上面的程序执行流程是，主线程开辟了两个线程，Thread1 和 Thread2，并开始执行。其中 Thread1 需要先获取 lock1，获取之后线程休眠 500ms，然后再去获取 lock2。Thread2 则是先去拿到 lock2，休眠 100ms，然后再去拿 lock1。当 Thread1 去拿 lock2 时，发现 lock2 被拿了，于是 Thread1 等待；Thread2 准备去拿 lock1 的时候发现，lock1 被拿走了，于是 Thread2 等待。Thread1 和 Thread2 都在等待彼此释放自己需要的锁，于是产生了死锁等待。</p><h4 id="简单的死锁排查"><a href="#简单的死锁排查" class="headerlink" title="简单的死锁排查"></a>简单的死锁排查</h4><p>既然死锁了，我们就要需要先拿到死锁的进程 id</p><p>在 Linux 中使用 <code>ps aux | grep java</code>，列出所有 java 进程的 id。或者使用 java 自带的 <code>jps</code> 命令，列出所有 java 进程。</p><p>之后使用 jstack 命令打印进程的栈信息，通过输出的栈信息来排查死锁。</p><blockquote><p>一个经典的多线程问题<a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin">哲学家用餐</a></p></blockquote><p><strong>预防死锁产生的原则：所有的线程按照相同的顺序获取资源的锁。</strong>上面的例子 Thread1 和 Thread2 获取锁的顺序不不一致，Thread1 先拿 lock1，Thread2 先拿 lock2。假如两个线程都先去拿 lock1 或者 lock2，那就不会产生死锁了。</p><h2 id="实现线程安全的基本手段"><a href="#实现线程安全的基本手段" class="headerlink" title="实现线程安全的基本手段"></a>实现线程安全的基本手段</h2><p>为了规避和解决线程带来的安全问题，我们可以采取一些措施</p><h3 id="使用不可变类"><a href="#使用不可变类" class="headerlink" title="使用不可变类"></a>使用不可变类</h3><p>使用 Integer &#x2F; String 这些不可变类。</p><h3 id="使用-synchronized-同步块"><a href="#使用-synchronized-同步块" class="headerlink" title="使用 synchronized 同步块"></a>使用 synchronized 同步块</h3><p><strong>方法一：</strong>synchronized（一个对象）把这个对象当成锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>            i++;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是上面的代码，我们把声明了一个锁，并在 <code>modifySharedVariable</code>方法体中使用 <code>synchronized</code>关键字。这样线程每次执行这个方法的时候，都会先去获取 lock1，当代码块中的代码执行后，lock1 被释放，其他的线程才能继续拿 lock1 去执行。</p><p><strong>方法二：</strong>static synchronized 方法，把 Class 对象当成锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次不声明锁，而是直接在 <code>modifySharedVariable</code>方法上使用 <code>synchronized</code>关键字。在 static 方法上使用 synchronized，实际上是把这个类的 Class 对象当成锁。因此每次访问这个方法都要去拿到 Class 对象，也保证了 i++ 顺序执行。</p><p><strong>方法三：</strong>实例的 synchronized 方法把该类的实例当成锁。（调用的对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 synchronized 声明在普通的方法上，实际上是把调用的对象当成锁。上面的代码是通过 Demo 类的一个实例 object 来调用 modifySharedVariable 方法的。因此，object 就被当成锁，也保证了 i++ 顺序执行。上面的代码也可以改成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            i++;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接用 <code>synchronized (this)</code>，这与 synchronized 声明在实例方法，功能是等价的。</p><h3 id="使用-Collections-工具类"><a href="#使用-Collections-工具类" class="headerlink" title="使用 Collections 工具类"></a>使用 Collections 工具类</h3><p>我们可以使用 Java 给我们提供的 Collection 的工具类，把不安全的 Collection 变成安线程全的。像 Collections.<em>synchronizedList</em>()，Collections.<em>synchronizedSet</em>() 等等</p><p>例如将普通的 Map 变成线程安全的 Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><h3 id="使用-JUC（java-util-concurrent）-包"><a href="#使用-JUC（java-util-concurrent）-包" class="headerlink" title="使用 JUC（java.util.concurrent） 包"></a>使用 JUC（java.util.concurrent） 包</h3><p>juc 包提供了很多线程安全的类，遇到线程安全问题，我们都可以把不是线程安全的类，换成线程安全的。</p><p><strong>原子操作类：AtomicInteger、AtomicBoolean..，</strong>之前的我们得 i++ 操作不是原子的，可以使用原子操作类 AtomicInteger，来进行替换。使用 AtomicInteger 的 <code>incrementAndGet</code>方法，就可以实现原子自增1的操作。</p><p><strong>线程安全集合：</strong>ConcurrentHashMap，ConcurrentLinkedQueue 等。在任何使用 HashMap 有线程安全问题的地方，都可以无脑使用ConcurrentHashMap 替换</p><h3 id="ReentrantLock-（可重入锁）"><a href="#ReentrantLock-（可重入锁）" class="headerlink" title="ReentrantLock （可重入锁）"></a>ReentrantLock （可重入锁）</h3><p>ReentrantLock 所做的事情和 synchronized 几乎一样。</p><p><strong>区别在于 ReentrantLock 可以自己定义加锁和解锁时机。</strong>使用 synchronized 关键字，执行完代码块中的代码，锁就会释放，但是有的时候我们需要在其他地方释放锁，而不是执行完就释放。因此可以使用 ReentrantLock 加锁，在适当的时机解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        reentrantLock.lock();<br>        i++;<br>        reentrantLock.unlock();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是之前的例子，如果你对输出结果并不关心的话，进入到 <code>modifySharedVariable</code>方法后，先使用 reentrantLock.lock() 获取锁，等 i++ 操作结束之后，使用 reentrantLock.unLock() 释放锁。reentrantLock 获取锁和释放锁的操作时机，都可以根据实际情况自己定义。</p><p><strong>Tips：可重入锁相关概念。</strong>如下 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        object.a();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        b();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>a 和 b 方法都使用 synchronized 声明了，主线程调用声明了一个实例调用 a 方法。根据前面学的知识，调用 a 方法需要拿到实例锁，然后执行 a 方法。a 方法中又调用了 b 方法，b 方法也需要拿到实例锁，但是因为 a 已经拿到了实例锁，并且 synchronized 也是可重入锁，所以调用 a 方法中调用 b 方法无需再去获取实例锁，这就是可重入锁的概念。</p><blockquote><p>可以点击查看 StackOverflow 上的大牛对于可重入锁的概念的理解<a href="https://stackoverflow.com/questions/16504231/what-is-the-meaning-of-reentrantlock-in-java/16504266#16504266">链接</a></p></blockquote><h2 id="Object-类里的线程方法"><a href="#Object-类里的线程方法" class="headerlink" title="Object 类里的线程方法"></a>Object 类里的线程方法</h2><p>说方法之前，了解下 Java 线程中的 6 种状态</p><ol><li><strong>初始（NEW），</strong>创建一个线程对象，但没有调用 start 方法</li><li><strong>运行（RUNNABLE），</strong>开始执行操作（得到 CPU 使用权）</li><li><strong>阻塞（BLOCKED），</strong>线程阻塞与锁</li><li><strong>等待（WAITING），</strong>需要其他线程唤醒，或中断</li><li><strong>超时等待（TIMED_WAITING），</strong>可以指定时间后，自行返回</li><li><strong>终止（TERMINATED），</strong>线程执行完毕</li></ol><p>使用代码解释这几个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            i++;<br>            System.out.println(i);<br>            lock.wait();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 new 一个线程的时候就是<strong>初始状态，</strong>调用了 start 方法，线程进入<strong>运行状态</strong>。假如第一个线程更快一步拿到 lock，这时其它两个线程就处于<strong>阻塞状态，</strong>当 lock 调用 wait() 方法，拿到 lock 的线程就进入<strong>等待状态，</strong>然后释放 lock，当线程方法执行完之后<strong>，</strong>线程进入<strong>终止状态</strong></p><p><strong>wait() 方法</strong></p><p>让当前线程进入<strong>等待状态</strong>。调用 wait 方法之前，必须先拿到锁。当调用 wait 方法之后，拿到的锁也就会释放。</p><p><strong>notify()</strong></p><p>随机唤醒一个处于等待状态的线程。</p><p><strong>notifyAll()</strong></p><p>唤醒所有处于等待状态的线程。</p><blockquote><p>实现生产者消费者模型 <a href="https://github.com/greek-zzf/my-demo/tree/main/example/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">demo</a>，可点击查看。</p></blockquote><h2 id="线程池与-Callable-x2F-Future"><a href="#线程池与-Callable-x2F-Future" class="headerlink" title="线程池与 Callable &#x2F; Future"></a>线程池与 Callable &#x2F; Future</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>在前面提到，我们每次使用线程都要先创建一个线程，然后使用给他分配任务，最后调用他的 start 方法执行这个任务。上面的步骤看起来没多大问题，仔细想想看，要是任务一多，每次分配任务的时候都要创建一个新的线程，这个创建线程的<strong>花销</strong>在 Java 世界中是很「昂贵的」。</p><p>类比到生活中，公司每次新接一个项目都去招一些人，做完项目就炒了，然后下次又来一个新的项目，又要去招人，这对于 HR 来说很麻烦。市面上的策略大多都是，招一群有潜力的人才，然后公司培养，有项目来就参与项目开发，下次再遇到新项目还是用之前招的人，这样就减少了公司频繁找人的开销。</p><p><strong>线程池就是预先定义好若干个线程，每次需要线程的时候就去调用，避免了每次创建线程的开销</strong>，这与公司找人的策略是一样的。</p><h3 id="定义线程池"><a href="#定义线程池" class="headerlink" title="定义线程池"></a>定义线程池</h3><p>使用 Executors 类去创建相应的线程池，并且可以配置线程的信息，使用 <code>newFixedThreadPool</code>方法，创建固定数量的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="Runable-与-Callable"><a href="#Runable-与-Callable" class="headerlink" title="Runable 与 Callable"></a>Runable 与 Callable</h3><p>在线程池中，都是使用 submit 方法提交并执行任务。使用 submit 方法的时候可以发现，它接收两个不同类型的参数。一个是与之前多线程相同的参数 Runable，而另一个则是 Callable。通过查看两者源代码可以发现，前者是没有返回值的，而 Callable 则有返回值。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/60ed335c-4bda-4b0b-9b00-7aa0ae60dbe3.png" alt="image.png"></p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/c8717165-05fe-4a6f-b7da-95f2d9ca2265.png" alt="image.png"></p><p>我们可以发现 submit 方法返回了一个 Future 对象，Future 泛型的值与 Callable 里 call 方法返回的值是一样的。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><strong>Future 表示异步计算的结果，也可以理解未来返回的结果。</strong>例如：我们让一个工人去割麦子，他去执行之后，我们只需要看看仓库是否增加了这么多麦子即可。工人割麦子的时候，我们可以去干其他事情，只需最后看结果就行。这个 Future 就是工人割的麦子总量。</p><p>Future 的常用 API</p><ul><li>get() 方法即可拿到返回的数据（拿到麦子）</li><li>get(long timeout, TimeUnit unit) 给定等待时间，拿到结果（在规定时间内，检查割了多少麦子）</li><li>cancel() 方法取消当前线程的任务（不让工人割麦子）</li><li>isCancelled() 方法判断当前线程是否在正常结束之前被取消（不让工人割麦子之后，检查麦子是否割完）</li><li>isDone() 判断当前线程是否执行完成（检查麦子是否割完）</li></ul><h3 id="使用多线程实现-Word-Count"><a href="#使用多线程实现-Word-Count" class="headerlink" title="使用多线程实现 Word Count"></a>使用多线程实现 Word Count</h3><p>WordCount 就是给定一段或者多段文本（假设每个单词之间都是用空格分隔），记录每个单词出现的次数。</p><p><strong>实现思路</strong>：可以定义一个线程池，线程池中线程的数量可以根据参数传递。每个线程的任务就是读取文件的一行，然后统计该行每个单词出现的次数。最后把每个线程执行的结果汇总，这样就完成了。</p><p>先把整个思路的代码写好，通过参数 <code>threadNum</code>定义了线程池中线程的数量。使用 Map&lt;String,Integer&gt; 记录单词出现的次数，Future&lt;Map&lt;String, Integer&gt;&gt; 表示线程返回的结果， List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; 就表示多个线程返回的集合。</p><p>由于有多个文件，因此使用 for 循环对每个文件都要进行统计操作。<code>threadPool.submit(() -&gt; workJob(file))</code> 提交了任务并执行，任务就是 <code>workJob</code>，即统计一行，单词出现的次数，返回的结果是<code>Future&lt;Map&lt;String,Integer&gt;&gt;</code>，再用刚才定义好的集合 futures，把所有线程返回的结果收集起来。</p><p>futures 收集完成后，开始遍历这个集合，把线程返回的结果进行统计合并，使用 <code>mergeWorkResultIntoFileResult</code>得到一个最终的结果，然后把最终的结果返回，程序执行结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span> threadNum, List&lt;File&gt; files)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadNum);<br><br>        List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            futures.add(threadPool.submit(() -&gt; workJob(file)));<br>        &#125;<br><br>        Map&lt;String, Integer&gt; finalResult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Future&lt;Map&lt;String, Integer&gt;&gt; workResult : futures) &#123;<br>            mergeWorkResultIntoFileResult(workResult.get(), finalResult);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> finalResult;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来是具体的方法实现，首先是 workJob() 方法。统计一行文本中，单词出现的次数。</p><p>先读取一行文本保存到字符串，然后 split() 方法对单词进行分割，得到单词数组 words。把单词数组遍历，map 记录单词出现的次数。其中 <code>result.getOrDefault(word, 0) + 1</code> 方法表示：<strong>从 map 中拿到 key 为 word 的值，如果存在这个 key，就对这个 key 的值进行 +1 操作，然后 put 进去。如果不存在这个 key，就使它的值默认为 0，然后再进行 +1 操作，put 进去。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">workJob</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file));<br><br>     Map&lt;String, Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     String line;<br>     <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br><br>         String[] words = line.split(<span class="hljs-string">&quot; &quot;</span>);<br>         <span class="hljs-keyword">for</span> (String word : words) &#123;<br>             result.put(word, result.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>最后的工作 <code>mergeWorkResultIntoFileResult()</code>，把线程返回的结果，合并统计，得到最终结果。统计的操作和 workJob() 方法类似。把合并的结果返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">mergeWorkResultIntoFileResult</span><span class="hljs-params">(Map&lt;String, Integer&gt; workResult, Map&lt;String, Integer&gt; fileResult)</span> &#123;<br>    <br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entrySet : workResult.entrySet()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> entrySet.getKey();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mergerResult</span> <span class="hljs-operator">=</span> fileResult.getOrDefault(word, <span class="hljs-number">0</span>) + entrySet.getValue();<br>        fileResult.put(word, mergerResult);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fileResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，一个使用多线程的 wordcount 功能实现。代码可以点击看<a href="https://github.com/greek-zzf/my-demo/tree/main/example/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20WordCount">源代码</a>，后续会在代码中更新其他方法实现 WordCount。</p><h2 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h2><ul><li><p>不推荐：对于 cpu 密集型应用稍有折扣。cpu 密集型操作会把 cpu 跑满，因此再使用多线程去操作，性能上很那有提升。</p></li><li><p>推荐：IO 密集型操作（文件 IO，网络 IO），这两个操作相比 cpu 的执行速度慢如蜗牛，因此用多线程来执行，性能上会有很大提升。</p></li><li><p>多线程性能提升的上限：单核 cpu 100%，如果是多核就是 N*100%。当 cpu 跑满的时候，就很难有「闲工夫」去处理其他请求。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 获取 GitHub PR 消息</title>
    <link href="/2021/05/11/Java%20%E8%8E%B7%E5%8F%96%20GitHub%20PR%20%E4%BF%A1%E6%81%AF/"/>
    <url>/2021/05/11/Java%20%E8%8E%B7%E5%8F%96%20GitHub%20PR%20%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/greek-zzf/get-github-pr">链接</a></p><h2 id="使用-GitHub-API-获取-PR"><a href="#使用-GitHub-API-获取-PR" class="headerlink" title="使用 GitHub API 获取 PR"></a>使用 GitHub API 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jackson Databind 将返回的字符串解析转化成所需对象</li></ul><h3 id="访问-GitHub-API"><a href="#访问-GitHub-API" class="headerlink" title="访问 GitHub API"></a>访问 GitHub API</h3><p>访问 Github API <a href="https://docs.github.com/cn/rest/reference/pulls">文档</a>，找到 List pull requests 该项，根据 API 说明，应当使用 GET 方法，路径中还需要带上 owner 和 repo 参数，还需要设置 request header 中的 accept 为 <code>appliccation/vnd.github.v3+json</code>，这样就建立了一个正确的请求</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%25E8%258E%25B7%25E5%258F%2596GitHubPR%25E4%25BF%25A1%25E6%2581%25AF/5857265f-3856-46c9-ba85-2a75f935b4a1.png" alt="image.png"></p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ol><li><p>创建一个类来封装获取到的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GitHubPullRequest</span> &#123;<br>        <span class="hljs-comment">// Pull request的编号</span><br>        <span class="hljs-type">int</span> number;<br>        <span class="hljs-comment">// Pull request的标题</span><br>        String title;<br>        <span class="hljs-comment">// Pull request的作者的 GitHub 用户名</span><br>        String author;<br><br>        GitHubPullRequest(<span class="hljs-type">int</span> number, String title, String author) &#123;<br>            <span class="hljs-built_in">this</span>.number = number;<br>            <span class="hljs-built_in">this</span>.title = title;<br>            <span class="hljs-built_in">this</span>.author = author;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>新建一个方法，使用 HttpClient 工具包发起 HTTP 请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://api.github.com/repos/&quot;</span> + repo + <span class="hljs-string">&quot;/pulls&quot;</span>);<br>httpGet.setHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/vnd.github.v3+json&quot;</span>);<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br></code></pre></td></tr></table></figure><p>首先创建一个<strong>默认的可关闭的客户端</strong>，使用 HttpGet 创建一个 GET 请求，repo 是我们要接收的参数。再刚才创建的 GET 请求中设置他的请求头信息，与 GitHub 规定的 API 一致。然后使用刚才创建的客户端，去执行 get 请求，将返回的结果用 CloseableHttpResponse 接收。</p></li><li><p>由于返回的结果是字节流，因此我们需要把字节流转换成我们需要的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">responseEntity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> responseEntity.getContent();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>getEntity()</code> 方法获取返回的 body 实体信息，获取到的实体信息调用 <code>getContent()</code> 方法获取内容，接着使用 IOUtils 工具把获取的内容从字节流以 UTF-8 的格式转化为字符串。 </p></li><li><p>把字符串转化成 json 对象或实体对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-type">JsonNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> objectMapper.readTree(result);<br><br>List&lt;GitHubPullRequest&gt; gitHubPullRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> number;<br>        String title;<br>        String author;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; node.size(); i++) &#123;<br>            number = node.get(i).get(<span class="hljs-string">&quot;number&quot;</span>).asInt();<br>            title = node.get(i).get(<span class="hljs-string">&quot;title&quot;</span>).asText();<br>            author = node.get(i).get(<span class="hljs-string">&quot;user&quot;</span>).get(<span class="hljs-string">&quot;login&quot;</span>).asText();<br><br>            gitHubPullRequests.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GitHubPullRequest</span>(number, title, author));<br>        &#125;<br></code></pre></td></tr></table></figure><p>使用 Jackson 工具，以树的形式反序列化 json 字符串得到 JsonNode，然后使用 for 循环将我们需要的数据封装到GitHubPullRequest 对象中，即可。</p></li></ol><h2 id="解析-HTML-获取-PR"><a href="#解析-HTML-获取-PR" class="headerlink" title="解析 HTML 获取 PR"></a>解析 HTML 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jsoup 将 html 字符串转化为 document</li></ul><h3 id="找到要获取的仓库-PR-地址，发起请求"><a href="#找到要获取的仓库-PR-地址，发起请求" class="headerlink" title="找到要获取的仓库 PR 地址，发起请求"></a>找到要获取的仓库 PR 地址，发起请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://github.com/&quot;</span> + repo + <span class="hljs-string">&quot;/pulls&quot;</span>);<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br></code></pre></td></tr></table></figure><p>发起请求并执行请求，获得返回的 response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpEntity</span> <span class="hljs-variable">responseEntity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> responseEntity.getContent();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>获取返回的数据中，body的内容，并把它转化成字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> Jsoup.parse(result);<br></code></pre></td></tr></table></figure><p>由于得到的是 html 字符串，使用 Jsoup 解析工具解析成 Document 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Element&gt; elements = doc.select(<span class="hljs-string">&quot;.js-issue-row&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 document 的 css 选择器，获取页面中的元素。此处可以根据具体页面采用不同的选择器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> number;<br>      String title;<br>      String author;<br>      List&lt;GitHubPullRequest&gt; gitHubPullRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (Element e : elements) &#123;<br>          title = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">0</span>).text();<br>          author = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">3</span>).child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).text();<br>          String[] str = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">3</span>).child(<span class="hljs-number">0</span>).text().split(<span class="hljs-string">&quot; &quot;</span>);<br>          number = Integer.parseInt(str[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>));<br>          gitHubPullRequests.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GitHubPullRequest</span>(number, title, author));<br>      &#125;<br></code></pre></td></tr></table></figure><p>根据元素之间的层级关系，拿到对应元素的信息，把信息封装到 GitHubPullRequest 类中存储。一个简单的 HTML 爬虫实现。</p><h2 id="使用第三方-SDK-获取-PR"><a href="#使用第三方-SDK-获取-PR" class="headerlink" title="使用第三方 SDK 获取 PR"></a>使用第三方 SDK 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jackson Databind 将返回的字符串解析转化成所需对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 正则表达式</title>
    <link href="/2021/04/17/Java%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/04/17/Java%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>定义</strong>：用于描述文本&#x2F;字符串的一组规则</p><p><strong>作用</strong>：使用一些自定义的规则来批量处理文本，提取信息</p><p><strong>优点</strong>：使用很少的代码完成复杂的文本提取工作，提高工作效率</p><p><strong>缺点</strong>：难学，难懂。在 java 对于正则表达式的支持不太友好，频繁使用会有性能问题。</p><h2 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h2><p><strong>元字符</strong></p><table><thead><tr><th>^</th><th>开始位置</th></tr></thead><tbody><tr><td>$</td><td>结束位置</td></tr><tr><td>.</td><td>单个任意字符</td></tr><tr><td>\w</td><td>单个”word”字符 字母&#x2F;数字&#x2F;下划线&#x2F;汉字</td></tr><tr><td>\s</td><td>单个空白字符</td></tr><tr><td>\d</td><td>单个数字字符</td></tr><tr><td>\b</td><td>单词的开始或结束</td></tr></tbody></table><p><strong>重复</strong></p><table><thead><tr><th>*</th><th>0次或多次</th></tr></thead><tbody><tr><td>+</td><td>1次或多次</td></tr><tr><td>?</td><td>0次或1次</td></tr><tr><td>{n}</td><td>n次</td></tr><tr><td>{n,}</td><td>&gt;&#x3D;n次</td></tr><tr><td>{n,m}</td><td>n到m次</td></tr></tbody></table><p><strong>选择</strong></p><table><thead><tr><th>[aeiou]</th><th>单个的a&#x2F;e&#x2F;i&#x2F;o&#x2F;u字符之一</th></tr></thead><tbody><tr><td>[0-9]</td><td>单个数字字符</td></tr><tr><td>[A-Z]</td><td>单个大写字母</td></tr><tr><td>[A-Z0-9_]</td><td>大写字母或者数字或者下划线</td></tr><tr><td>Hi&amp;#124;hi等价于[Hh]i</td><td>Hi或者hi</td></tr></tbody></table><h2 id="Java-世界中的正则表达式"><a href="#Java-世界中的正则表达式" class="headerlink" title="Java 世界中的正则表达式"></a>Java 世界中的正则表达式</h2><p>Java 中的正则表达式是比较「昂贵」的</p><ul><li><p>正则表达式需要解析</p><ul><li>Java 需要将正则表达式字符串，转换成自己内部的数据结构，这个转换过程代价较大</li><li>在写代码中可以将正则表达式预编译好，需要的时候再调用就行了，减少了多次编译的开销。例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;0\\d&#123;2&#125;-[1-9]\\d&#123;7&#125;|0\\d&#123;3&#125;-[1-9]\\d&#123;6&#125;&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>匹配过程非常「昂贵」</p><ul><li>Java 的匹配算法并不高效，用到的是<a href="https://www.google.com/search?q=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95&oq=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95&aqs=chrome..69i57j0l9.2220j0j4&sourceid=chrome&ie=UTF-8">回溯算法</a>。就像机器人走迷宫一般，一直尝试，遇到墙就换一条路线继续试，直到走出迷宫</li></ul></li></ul><p>Java 中使用到正则表达式的方法：String 类中的 split，replaceAll，replacefirst，matches，以及 Matches 中的方法。可以查看相关的 demo 链接：<a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%99%AE%E9%80%9A%E7%BB%83%E4%B9%A0/PhoneNumberMatcher.java">判断是不是合法的固定电话号码</a>，<a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%99%AE%E9%80%9A%E7%BB%83%E4%B9%A0/LogProcessor.java">移除文件中的时间戳</a></p><h2 id="分组与捕获"><a href="#分组与捕获" class="headerlink" title="分组与捕获"></a>分组与捕获</h2><p>前面的正则表达式用法，都是用来判断字符串是否满足条件。然而，实际工作中用到较多的都是从一堆字符串中提取所需的信息，那么 Java 又是怎么做的呢？</p><p>想要将所有符合正则表达式的⽂本抓出来处理，需要先了解如下规则：</p><ul><li>使⽤括号来指定⼀个被捕获的分组</li><li>分组的编号从1开始</li><li>分组的编号计算只看左括号</li><li>(?:)不捕获和分配编号，括号只⽤于分组或标记优先</li><li>分组编号为0表示整个匹配的字符串</li></ul><h3 id="Java-中捕获数据"><a href="#Java-中捕获数据" class="headerlink" title="Java 中捕获数据"></a>Java 中捕获数据</h3><p>在 Java 中可以使用 <code>Pattern 类的 matcher() 方法生成 Matcher 对象</code> ，然后我们可以对 <code>Matcher对象进行操作</code>。</p><p>假设有如下数据，我们需要将时间以及消费金额提取出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">2020-01-02 在家玩游戏消费0元<br>2020-01-03 在家敲代码消费3元<br>2020-02-02 出门旅游消费1000元<br></code></pre></td></tr></table></figure><p>我们可以先将该数据读取出来，保存成一个 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">gcLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;message.log&quot;</span>);<br>List&lt;String&gt; lines = Files.readAllLines(gcLog.toPath());<br></code></pre></td></tr></table></figure><p>然后我们可以在类中声明 Pattern，把对匹配时间和事件的正则表达式预编译。经过在线正则表达式测试，我们可以编写如下正则 <code>\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;(.*)?\d</code> 这个可以匹配时间和金额。我们要提取，就需要给时间部分加上括号，金额部分也加上括号。正则表达式变成 <code>(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)(.*)?(\d)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_REGEX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)(.*)?(\d)&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(MESSAGE_REGEX);<br></code></pre></td></tr></table></figure><p>接着对所有字符串进行匹配，匹配过程中会生成 Matcher。调用 Matcher 的 find 方法，判断是否匹配成功。因为分组编号为 0 代表匹配的全部信息，即日期+金额，group(1) 代表匹配的第一组信息，即时间，group(2）就代表金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String line : lines) &#123;<br>          <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(line);<br>          <span class="hljs-keyword">if</span>(matcher.find())&#123;<br>              System.out.println(matcher.group(<span class="hljs-number">0</span>));<br>              System.out.println(matcher.group(<span class="hljs-number">1</span>));<br>              System.out.println(matcher.group(<span class="hljs-number">2</span>));<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><p>一个更为复杂的 GC 日志文件信息提取操作可查看 <a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%88%86%E7%BB%84%E4%B8%8E%E6%8D%95%E8%8E%B7/GCLogAnalyzer.java">Demo</a></p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析URL</title>
    <link href="/2021/04/03/%E6%B5%85%E6%9E%90%20URL/"/>
    <url>/2021/04/03/%E6%B5%85%E6%9E%90%20URL/</url>
    
    <content type="html"><![CDATA[<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>ip 主要约定了两件事：如何定位一台设备？如何封装数据报文，以跟其他设备交流？</p><p>只要我们处在互联网中我们就至少有一个独特的 IP</p><h3 id="内网与外网-IP"><a href="#内网与外网-IP" class="headerlink" title="内网与外网 IP"></a>内网与外网 IP</h3><p>当我们通过家里的路由器进行上网时，实际上网络返回的请求是先到路由器，路由器再转发给我们的设备，路由器就充当我们与外界网络交互的工具。路由器分配给我们设备的 IP 就是<strong>内网 IP</strong>，一般来说这个 IP 格式都是 <code>192.168.xxx.xxx</code> 。内网中的设备都可以相互访问。而外网 IP 就是电信&#x2F;联通之类的运营商给你分配的 IP，只要路由器连上网就会有一个外网 IP。这个外网 IP 不是固定的，当我们重启路由器和光猫，得到的 IP 很有可能就会不一样</p><h3 id="几个特殊的-IP"><a href="#几个特殊的-IP" class="headerlink" title="几个特殊的 IP"></a>几个特殊的 IP</h3><ul><li>127.0.0.1 表示自己</li><li>localhost 通过 hosts 指定为自己<ul><li>可以通过修改 hosts 文件将自己定义的名称指定为 <code>自己</code> ，例如：可以将 zzf 指定为自己</li></ul></li><li>0.0.0.0 不表示任何设备</li></ul><h2 id="端口-port"><a href="#端口-port" class="headerlink" title="端口 port"></a>端口 port</h2><p>我们已经知道一台机器的 IP，但是还不能访问它，我们还需要<strong>端口</strong>。</p><p>一台机器可以提供多种服务，并且每个服务都对应一个号码，这个号码就是我们所说的端口。</p><h3 id="一个简单的比喻"><a href="#一个简单的比喻" class="headerlink" title="一个简单的比喻"></a>一个简单的比喻</h3><p>麦当劳提供两个窗口，一号快餐，二号咖啡。当我们去一号窗口点咖啡，会被拒绝，让你去二号点咖啡。去咖啡窗口点快餐也是一样。</p><h3 id="一台机器可以提供多种服务"><a href="#一台机器可以提供多种服务" class="headerlink" title="一台机器可以提供多种服务"></a>一台机器可以提供多种服务</h3><ul><li>HTTP 服务默认 80 端口</li><li>HTTPS 服务默认 443 端口</li><li>FTP 服务默认 21 端口</li><li>一共有 65535 个端口</li></ul><p>要只要应该用什么端口，可以去维基百科搜索，他会告诉你每个端口该做什么。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>0~1023 端口是留给系统使用的</li><li>只有拥有管理员权限才能使用这预留个系统的端口</li><li>其他端口可以给普通用户使用</li></ul><p>更多端口的详细信息，可以访问<a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">链接</a></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>知道 IP 和端口之后，可以正确的享受相应的 <code>服务</code> 了。但是，我们每次都通过 IP 和端口去访问很麻烦，毕竟IP 这串数字太难记了。因此，域名诞生了，<strong>域名就是对 IP 的别称。</strong></p><p>我们访问百度的 IP，就不用找它的 IP了，可以直接使用 baidu.com 来替代。我们也可以使用 <code>ping badu.com</code> 命令，根据域名获取到它对应的 IP。</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>一个域名可以对应不同的 IP，这样是负载均衡，防止一台机器扛不住</li><li>一个 IP 也可以对应不同的域名，这个叫做共享主机，穷开发者才会这样做</li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名和 IP 的关系是如何绑定起来的呢？这个就要靠 DNS 了，它相当于过去的电话本，你要找「张三」的手机号码，就需要找到「张三」这个人，手机号码也同时找到了。</p><p>我们默认使用的 DNS 就是电信&#x2F;联通之类的运营商为我们提供的，我们也可以自己修改 DNS。</p><p><strong>过程：</strong>当我们使用浏览器访问 <code>baidu.com</code> ，DNS 会返回它对应的 IP，然后浏览器向对应的 IP 的 80&#x2F;443 端口发送请求，然后返回百度首页的内容。</p><h2 id="获取网页内容规则"><a href="#获取网页内容规则" class="headerlink" title="获取网页内容规则"></a>获取网页内容规则</h2><ul><li>我们可以通过改变访问地址路径做到，获取不同的内容，假设有该 <code>zzf.com</code>  域名<ul><li><code>zzf.com/docs</code> 获取文档内容</li><li><code>zzf.com/images</code> 获取图片内容</li></ul></li><li>根据修改参数可以达到，同一页面不同内容<ul><li><code>www.baidu.com/s?wd=hi</code> </li><li><code>www.baidu.com/s?wd=hello</code></li></ul><p> </p></li><li>可以使用锚点做到，同一内容不同位置<ul><li><code>zzf.com#教程</code> ，定位到该页面的「教程」位置</li><li><code>zzf.com#参考书</code> ，定位到该页面的「参考书」位置</li></ul></li></ul><p><strong>注意事项：虽然锚点是在请求地址中的，但是锚点不会传给服务器。</strong></p><h2 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h2><ul><li><code>curl -v http://baidu.com</code> 输出通信的整个过程，包括获取 IP，建立 tcp 连接，发送请求，响应内容，关闭 tcp 链接，结束访问。</li></ul><p>更详细的使用规则可以访问<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 常用标签</title>
    <link href="/2021/04/01/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/04/01/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><strong>href</strong>（指定要跳转的链接），取值如下<ul><li>网址（<a href="https://google.com,http//google.com%EF%BC%8C//google.com%EF%BC%89">https://google.com，http://google.com，//google.com）</a></li><li>路径（&#x2F;a&#x2F;b&#x2F;c，a&#x2F;b&#x2F;c&#x2F;，index.html）</li><li>伪协议（javascript:代码;，tel:手机号，mailto:邮箱）</li></ul></li><li><strong>target</strong>（指定打开链接的窗口），取值如下<ul><li>_blank（新窗口打开）</li><li>_top（顶级窗口打开）</li><li>_parent（父级窗口打开）</li><li>_self（默认值，表示在当前页面打开）</li></ul></li></ul><h2 id="table-标签"><a href="#table-标签" class="headerlink" title="table 标签"></a>table 标签</h2><h3 id="相关的标签"><a href="#相关的标签" class="headerlink" title="相关的标签"></a>相关的标签</h3><ul><li>table</li><li>thead（表头）</li><li>tbody（表内容）</li><li>tfoot（表尾）</li><li>tr，table row 缩写，表示一行。</li><li>td，table data 缩写,表示内容</li><li>th，table header 缩写，表示标题</li></ul><p>我们可以用如下代码的来实现，一个简单的表格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小红<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>246<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>279<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>297<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>小明</th><th>小红</th><th>小白</th></tr></thead></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>246<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>279<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>297<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/b13bb768-2d4b-4038-aa44-e996452c2c6f.png" alt="image.png"><br>其中 <code>小明，小红，小白</code> 为表头的标题，所以使用 <thead> 标签包裹，并使用 <th> 标签表示表头。 <code>数学，语文，英语，总分</code> 也为标题，因此也要用 <th> 标签包裹，总分在 <tfoot> 中，使用 <th> 包裹。这样就实现一个简单的表格。</p><h3 id="相关样式"><a href="#相关样式" class="headerlink" title="相关样式"></a>相关样式</h3><ul><li><strong>table-layout</strong><ul><li>auto，根据内容的宽度展示</li><li>fixed，固定的宽度</li></ul></li><li><strong>border-collapse</strong>（border 是否合并）<ul><li>collapse 表示合并</li></ul></li><li><strong>border-spacing</strong>（合并 border 之间的距离）**</li></ul><h2 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>发出 get 请求，展示一张图片</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>alt（图片加载失败时展示的内容）</li><li>height（图片高度，直接使用数字。支持自适应，高度固定则宽度自适应）</li><li>width（图片宽度，直接使用数字。支持自适应，宽度固定则高度自适应）</li><li>src（引用图片地址，可以使用绝对路径，相对路径，网络地址）</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>onload（图片加载成功事件）</li><li>onerror（图片加载失败页面），通常可以做一些处理，例如当图片加载失败之后，可以使用默认的错误图片来展示。</li></ul><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>max-width:100%，自适应不同屏幕分辨率。可以使图片根据不同屏幕大小完整显示。</li></ul><h2 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>发 <strong>get</strong> 或 <strong>post</strong> 请求，然后<strong>刷新页面。</strong></p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul><li>action（请求的地址）</li><li>method（请求方法）</li><li>autocomplete（比如输入账号有自动填充）</li><li>target（指定刷新页面）</li></ul><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><ul><li>onsubmit（表单提交）</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>form 里面放一个 type &#x3D; submit 才能触发事件。</li><li>可以是 <code>&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;</code> ，或者 <code>&lt;input type=&quot;submit&quot;/&gt;</code></li></ul><h2 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>让用户输入内容</p><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul><li>type<ul><li>button，按钮</li><li>checkbox，复选框，提交多个选项将 input 的 name 属性设置为相同的值</li><li>file，上传单个文件，上传多个需要在 input 中加入 multipart 即可</li><li>hidden</li><li>password，密码类型</li><li>radio，单选框，实现单选需要将两个 input 的 name 设为相同的值</li><li>submit，提交表单</li><li>text，文本类型</li></ul></li></ul><h3 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h3><ul><li>onchange，输入框中改变的事件</li><li>onfocus，输入框焦点事件</li><li>onblur，输入框移出事件</li><li>一般不监听 input 的 click 事件</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件与 IO</title>
    <link href="/2021/03/28/%E6%96%87%E4%BB%B6%E4%B8%8E%20IO/"/>
    <url>/2021/03/28/%E6%96%87%E4%BB%B6%E4%B8%8E%20IO/</url>
    
    <content type="html"><![CDATA[<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p><strong>1.I&#x2F;O流是什么?</strong></p><p>对于陌生的东西，最好通过类比的方法去了解。我对于流的理解：<strong>流就是一系列数据</strong>。通过生活中常见的现象进行类比，比如：流中全部是水，我们称为“水流”，流中全是电子，我们称为“电流”。那我们可以根据流中的数据类型，来给流命名。再回到计算中，流中是字节的我们叫“字节流”，是字符的叫“字符流”，等等。</p><p>对于笔者来说，在Java开发中需要用到获取文件信息，经常需要用到流。那个时候不理解流，只知道抄着代码，这里改改那里修修。以至于，每当需要操作文件的时候不知道如何开始下手，对于整个流程不清楚。每当去百度文件操作的时候，又发现很多种实现方法，用的流都不一样，实现起来也有细微差别，搞得笔者也是心态爆炸，于是下决心把这块内容梳理好，方便以后使用。</p><p>关于这部分内容目前存在以下几个问题：</p><ul><li>如何理解文件在流中的角色？</li><li>文件操作的整个流程？</li><li>文件操作选用什么流？</li><li>不同的流的差异与特点</li></ul><p>**流的一些补充:**上面粗略解释了流，现在需要对流进行一个补充。我们说的电流和水流都是从一端流向另一端（可能并不是很准确），比如：电池的电子从负极流向正极，电池的负极像一个电子的生产者一样，而正极就像一个消费者或者接收者一般；还有地下水到你家的水龙头一样，地下水通过加工提取到人引用。通过这两个例子，可以得出一个结论，流的操作或者使用至少需要一个生产对象和一个接受对象。在计算机世界中已经为这两个对象命名，输入对象和输出对象。</p><p><strong>2.流的分类</strong></p><p>关于流的分类，在Java中有如下3种分类标准：</p><ol><li>按照流的流向分，可以分为输入流和输出流。</li><li>按照操作单元划分，可以分为字节流和字符流。</li><li>按照流的角色划分，可以分为节点流和处理流</li></ol><p>流的分类解读：</p><ul><li>根据流向分类：在上面的内容补充中，说流都是从一端流向另一端，说明了流有方向。所以根据流的方向可以分为输入流和输出流，辨别输入流和输出流需要选参照中心。我们以程序作为参照中心，读取本地磁盘上的文件，程序端接收，就说明该是输入流；将程序产生的数据保存到磁盘，程序段输出，就说明是输出流。在Java中所有的IO流的类都是从以下4个抽象类基类中派生出来的：InputStream&#x2F;Reader所有输入流的基类，前者是字节输入流，后者是字符输入流；OutputStream&#x2F;Writer所有输出流的基类，前者是字节输出流，后者是字符输出流</li><li>根据操作单元划分：首先需要理解什么是操作单元，我把他理解为所操作数据的最小单位。我们知道一个字符等于两个字节，字节流取数据按照一个一个字节取，字符流取数据就是一个字符一个字符取。就好比，我们用调羹喝汤，一调羹的量就好比字节，而用勺子喝汤，一勺子的量就好比字符，只不过一勺子比一调羹的量多很多，而字符是一个字节的两倍。</li><li>根据流的角色划分：节点流和处理流。节点流：<strong>可以从一个特定的数据源(称作节点)读写数据</strong>，如：内存，硬盘，文件等。处理流：<strong>可以理解为，根据实际需求在节点流的基础上进行的二次开发和封装。</strong><br>       <strong>例子1</strong>：说明处理流和节点流的关系：想象一个场景，计算机每一次读写的时候都访问硬盘，如果访问次数很频繁的话，性能表现就不佳，而且硬盘的寿命也会减少。所以为了满足这种场景，就设计了缓存流，一次读取较多数据到缓存中，以后的每一次读取都从缓存中访问，直到缓存中的数据读取完毕。用一个生活的例子解释缓存流，吃饭的时候我们不用碗装饭(缓存流)的话，每吃一口都要去电饭锅里面铲，有了碗(缓存流)之后，我们可以把饭装进碗里，吃完了碗里的，我们再去电饭锅里铲。这样就大大减少了去电饭锅里装饭的次数，提高了效率。<br>                  <strong>例子2</strong>：因为我们的流的操作最小单位是字节或者字符，为了方便Java程序员使用对象，我们就需要在原来节点流的基础上进行二次开发和封装。比如我们读取一个本地的文本文件，需要一个字节流，又由于流里面是字节，而我们希望方便程序员使用对象来保存这些数据，就在该流的基础上进行开发(具体如何实现，本人暂时也不清楚)，原来的字节流就变成了一个对象流，流里面的内容不在是字节，而是对象，这样就方便了程序员对于该信息的获取。</li></ul><p>以下是关于字节流和字符流，以及节点流和处理流的详细分类图</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E6%96%87%E4%BB%B6%E4%B8%8EIO/983978b9-ae5d-4ea0-ac1b-6f502f183a77.png"></p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/%E6%96%87%E4%BB%B6%E4%B8%8EIO/22c1ab11-4426-47fc-92d4-aae5b175bba3.png"></p><p><strong>3.关于字符流和字节流的选择</strong></p><p>之前在学校做课设的时候，每次做到文件关于文件读取的时候，关于选择字节流还是字符流的选择都是含糊不清，每次都是去网上找代码，这部分知识不是很清楚。现在重新把知识捡起来好好梳理一遍。首先不管是文件读写还是网络发送接收，信息的最小存储的单位是字节。由此可能读者又会问了，既然最小存储单元是字节，那么有了字节流为什么还要字符流呢?</p><p>**解答:**在编程领域中，由于语言的不同，中文等一些其他语言一个字就需要两个字节表示，即一个字符，所以如果不使用字符流的话，就会出现乱码等问题。在日常使用中遇到图片，音频等媒体文件采用字节流比较好，而涉及到字符操作的使用字符流比较好。</p><h2 id="使用文件对象"><a href="#使用文件对象" class="headerlink" title="使用文件对象"></a>使用文件对象</h2><p>说明： 一个File对象就是一个具体的文件或者文件夹目录（作用：指定文件或文件夹保存的路径）。让然，指定的文件或文件夹目录在电脑上不一定存在。以下代码演示了文件对象的用法以及常用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个文件对象，指定他的目录：D盘目录下的java文件夹</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\java\\test&quot;</span>);<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">()</span>  <span class="hljs-comment">//判断文件或者文件夹是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isDirectory</span><span class="hljs-params">()</span>  <span class="hljs-comment">//判断是否是文件夹</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isFile</span><span class="hljs-params">()</span>  <span class="hljs-comment">//判断是否是文件</span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>  <span class="hljs-comment">//获取文件的长度</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">lastModified</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取文件最后修改时间</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">setLastModified</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span>  <span class="hljs-comment">//设置文件最后修改时间</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">renameTo</span><span class="hljs-params">(File dest)</span>  <span class="hljs-comment">//文件重命名</span><br>    <br>注：renameto方法重新命名，指的是在磁盘上文件<span class="hljs-string">&quot;1.txt&quot;</span>变成<span class="hljs-string">&quot;2.txt&quot;</span>但是通过file.getName()获得的文件名还是“<span class="hljs-number">1.</span>txt”,无论是命名前还是命名后。<br><br>String[] list()  <span class="hljs-comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹)</span><br>File[] listFiles() <span class="hljs-comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span><br>      <br>String <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span>   <span class="hljs-comment">// 以字符串形式返回当前文件所在文件夹</span><br>File <span class="hljs-title function_">getParentFile</span><span class="hljs-params">()</span> <span class="hljs-comment">// 以文件形式返回当前文件所在文件夹</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 创建文件夹，如果父文件夹不存在，创建就无效。举例：使用第一行的file对象，如果D盘   // 根目录下没有java文件夹,则目录创建失败，java目录，test目录都没有创建。</span><br>    <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>   <span class="hljs-comment">// 创建文件夹，如果父文件夹不存在，就会创建父文件夹。举例：如果D盘根目录下没有java   // 文件夹,就会连同java文件夹一并创建，java目录和test目录都创建成功。 </span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">createNewFile</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 创建一个空文件,如果父文件夹不存在，就会抛出异常。</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">由于创建文件，父文件夹不存在就会抛出异常，所以创建文件的时候需要先创建父文件夹。使用上面提到的方法创建文件夹。例如:file.getParentFile().mkdirs();</span><br><span class="hljs-comment">*/</span><br>File[] listRoots()  <span class="hljs-comment">// 列出电脑上所有的盘符c: d: e: 等等</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>    <span class="hljs-comment">//删除文件或者文件夹</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteOnExit</span><span class="hljs-params">()</span> <span class="hljs-comment">// JVM结束的时候，刪除文件，常用于临时文件的删除</span><br></code></pre></td></tr></table></figure><h2 id="流与文件"><a href="#流与文件" class="headerlink" title="流与文件"></a>流与文件</h2><p>        在做课设的时候经常会遇到文件的读取等功能，在还没弄清楚流的时候就已经强迫使用文件操作，导致每次遇到文件读取问题都是网上copy类似代码，却不能很好的理解代码执行流程，或者理解了也很快就忘记了，因为这个记忆点并不深。所以现在打算简单的梳理下文件的读取操作。</p><p>        开始之前，我们需要思考下几个问题：1.先要搞清楚”流向”，我们把我们的程序作为参照物，我们的程序是要读取文件还是写入文件？2.是哪个文件？(即文件所在的位置)3.根据文件的类型，我们该选用什么类型的流？通过思考这几个问题，使得我们对于文件的读取流程就会很清晰了。</p><ol><li><p>假设我们程序需要读取D盘根目录下的<code>zzf.txt</code>文本文件,通过使用File构建一个对象file,并告诉我们的程序文件位于<code>D:\\zzf.txt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zzf.txt&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>告诉程序文件的位置之后，我们就需要构建一个流了。让文件数据通过流，流向程序。构建流的时候我们又需要考虑了，是输入流还是输出流，显然我们在流的章节中说道，数据是流向程序，所以我们要选用输入流。选用输入流之后还要思考,是要字节流还是字符流呢?这个问题我们要确定文件类型，显然我们这里是文本类型的，对于文本前面也提到了最好使用字符流，防止文本里面有中文字符。所以综合来说我们选用<strong>字符输入流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*try后面加括号是Java7中的技术，这样的好处是：把流定义在try()里,try,catch或者finally结束的时候，会自</span><br><span class="hljs-comment">*动关闭流。这样就不要像以前一样，需要自己写代码关闭了。</span><br><span class="hljs-comment">* 1.首先我们要使用上面生成的文件对象file，用来构建一个输入字符流fis。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file)) &#123;<br><span class="hljs-comment">//2.因为我们选用的是字符流，所以我们新建一个字符数组用来保存流中的数据，数组长度就是文件的长度</span><br>    <span class="hljs-type">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) file.length()];<br><span class="hljs-comment">//3.使用read方法把流中的数据全部保存到content字符数组中。</span><br>    fis.read(content);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过上面的步骤，我们就完成了把D盘目录下的<code>zzf.txt</code>文件内容保存到了<code>content</code>数组中，接下来我们可以   对这个数组进行很多操作，比如将数据写入一个txt文件等等。</p></li><li><p>继续完善我们的操作，我们把刚才读取的文件数据重新写入到一个新的文件中。根据步骤2中关于选择流的思考，这里我们同样需要思考，流的选择。在了解步骤2的基础下，我们可以快速的得出，我们是需要一个<strong>字符输出流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zzf.txt&quot;</span>);<br><span class="hljs-comment">//这里我们告诉程序，我们的文件是D盘根目录下的zz.txt文件</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zz.txt&quot;</span>);<br><span class="hljs-comment">//通过file1对象构建字符输出流</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file1)) &#123;<br>            <span class="hljs-type">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) file.length()];<br>            fis.read(content);<br><span class="hljs-comment">//将从zzf.txt文件中读取保存的数据content，写入到新文件zz.txt中</span><br>            fileWriter.write(content);<br><br>     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>这样我们就简单的实现了一个文件的读取。有人或许会问，你前面说的节点流和处理流你咋没     用到呢？其实回去看第一部分,再仔细分析的话我们这个字符输入输出流就是一个节点流,所       以我们可以把效率提高一点,在这个基础上我们使用缓存流。</p></li><li><p>加上缓存流，提高效率。前面也说了处理流是在节点流上进行二次开发和封装的，所以用到处理流肯定就需要节点流。就像通过文件对象构建流一样，处理流通过节点流来进行构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zzf.txt&quot;</span>);<br>     <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\zz.txt&quot;</span>);<br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file1)) &#123;<br>         <span class="hljs-type">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) file.length()];<br>         <span class="hljs-comment">//使用节点流FileReader对象构建处理流BufferedReader</span><br>         <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fis);<br>         <span class="hljs-comment">//读取文件数据</span><br>         bufferedReader.read(content);<br><span class="hljs-comment">//使用节点流FileWriter对象构建处理流BufferedWriter</span><br>         <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fileWriter);<br>         <span class="hljs-comment">//写入文件数据</span><br>         bufferedWriter.write(content);<br>         <span class="hljs-comment">//有的时候，需要立即把数据写入到文件，而不是等缓存满了才写出去,这时候就需要用到flush</span><br>         bufferedWriter.flush();<br><br>     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>注意事项:</strong></p><ol><li>我们使用流的时候一般都是需要手动关闭的，上面的代码都没有写出关闭的代码，是因为我们把流的构建这一步写进了<code>try()</code>里面，所以不需要手动关闭代码，自己写的话，要么和我代码一样，要么就在流使用完之后就写一行代码关闭流。</li><li>还有一个大家可能没有考虑到的情况，我们刚才使用了缓冲流之后，如果手动关闭的话是不是需要关闭两个流呢？实际上，我们只需要关闭节点流就行了，因为处理流是在节点流的基础上构建的，我们关闭了节点流，处理流就失去了节点流，就会自动销毁。</li><li>最后说一个关于缓存流写入的问题，因为缓存流是有缓存空间的，只有缓存空间满了，缓存空间的数据才会写入到文件中。通过查看源代码发现默认设置的缓存空间是8kb。因此，当你使用缓存流读取文件的时候，如果文件大小小于8kb,没有使用flush方法的话，要写入的文件就没有数据，因为数据都在缓存区中。我们使用flush方法就可以将缓存区的数据强制写入到文件中，无论缓冲区的数据大小。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie</title>
    <link href="/2021/03/17/Cookie/"/>
    <url>/2021/03/17/Cookie/</url>
    
    <content type="html"><![CDATA[<p>不知道大家是否想过这样一个问题，比如说我们登陆淘宝之后，点击订单，点击购物车，这些都是自己的信息。通过前面的学习，我们也知道 HTTP 协议是无状态的，我们与淘宝的服务器之间，只是通过一串串字节在交流。我们发送请求，就是发给服务器一串字节流，服务器收到后作出响应，也返回一串字节流。当我们点击「购物车」，点击「订单」他怎么知道是「我」在查看购物车信息，而不是张三在查看购物车呢？</p><p>我们想到一种笨拙的解决办法：当我们点击购物车的时候，系统让你登陆账号密码，登陆之后就能正确访问你的信息了。当我们点击其他信息时，比如「订单」，系统也让你输入账号密码，这样订单信息也能正确访问了。这种方法是一种解决办法，但是给用户带来的体验很不好。cookie 就是用来维持登陆状态的东西。</p><p><strong>Cookie 是什么</strong> </p><p>简单来说就是一串字符串数据，用来区分和辨别不同用户。可以理解为「身份证」，通过身份证这一串数据，我们就能知道是谁在访问服务器。当然这一字符串可能还会包含，Cookie 的过期时间，以及一些安全协议等等。</p><p><strong>Cookie 如何维持状态</strong>当我们第一次登陆一个网站的时候，我们填写好自己的账号密码信息，向服务器发送登陆请求。服务器根据你传过来的账号密码进行判断，倘若账号密码正确，服务器就会返回登陆成功的信息，并且在返回的 response header 中使用 <code>Set-Cookie</code>  参数，设置一段随机字符串 Cookie。</p><p>当我们有了 Cookie 之后，我们发出去的所有请求，浏览器都会帮我们把 Cookie 字符串带上，服务器就根据 Cookie 信息来辨别用户，返回正确的用户信息。</p><p><strong>使用 Java 代码获取 Cookie 信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Crawler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">COOKIE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://47.91.156.35:8000/auth/login&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://47.91.156.35:8000/auth&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">loginAndGetResponse</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(COOKIE_URL);<br>        httpPost.addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>        httpPost.addHeader(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;</span>);<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, username);<br>        map.put(<span class="hljs-string">&quot;password&quot;</span>, password);<br><br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(JSON.toJSONString(map));<br>        httpPost.setEntity(entity);<br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">loginResponse</span> <span class="hljs-operator">=</span> httpclient.execute(httpPost);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getMessageByCookie(loginResponse.getFirstHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>).getValue());<br>        loginResponse.close();<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getMessageByCookie</span><span class="hljs-params">(String cookie)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(MESSAGE_URL);<br>        httpGet.addHeader(<span class="hljs-string">&quot;Cookie&quot;</span>, cookie);<br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br><br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity1</span> <span class="hljs-operator">=</span> response.getEntity();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> entity1.getContent();<br>        <span class="hljs-comment">// 设置解析编码为UTF-8</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> IOUtils.toString(is, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        EntityUtils.consume(entity1);<br>        response.close();<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用给定的用户名 username 和密码 password 进行模拟登录，然后获取服务器返回的 <code>Cookie</code>的值，并把获取到的 Cookie 带到下一次的请求中去访问个人信息。</p><p>首先新建一个 HttpPost 对象，添加所需的头部信息。 <code>Content-type</code> 告诉服务器我们要给服务器发送的数据类型。 <code>User-Agent</code> 让我们模拟浏览器的方式去访问，避免被服务器屏蔽请求。</p><p>使用 Map 对象将我们得账号密码存储起来，接着使用 JSON 工具转化为字符串，放到请求体中，执行 POST 请求，把返回的头部信息 <code>Set-Cookie</code> 的值拿到。</p><p>使用 <code>getMessageByCookie</code> 方法，把获取到的 Cookie 值当做参数传入。方法中发送了一个 HttpGet 请求，把Cookie加到请求头中，发送到服务器，并把返回的 body 数据转化为字符串，返回去。</p><p>这样就是一次使用获取 Cookie ，并使用 Cookie 的简单访问。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cookie</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection</title>
    <link href="/2021/03/15/Collection/"/>
    <url>/2021/03/15/Collection/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Collection"><a href="#什么是-Collection" class="headerlink" title="什么是 Collection"></a>什么是 Collection</h1><p><code>Collection</code> 是 Java 世界中最重要的类库，是这个类库的顶级接口。它的实现有 Set，List。而 Set 的实现又有 <strong>HashSet</strong>，TreeSet……。List 的实现有 <strong>ArrayList</strong>，LinkedList ……。也就是说我们日常使用的集合类都基本是 <code>Collection</code> 接口的实现。</p><h1 id="Collction-常用方法"><a href="#Collction-常用方法" class="headerlink" title="Collction 常用方法"></a>Collction 常用方法</h1><p><strong>C：</strong>new ArrayList()  &#x2F; new LinkedList() &#x2F; new HashSer() &#x2F;…<br><strong>R：</strong>size() &#x2F; isEmpty() &#x2F; contains() &#x2F; for() &#x2F;stream<br><strong>U：</strong>add() &#x2F; addAll() &#x2F; retainAll()<br><strong>D：</strong>clear() &#x2F; remove() &#x2F; removeAll()</p><ul><li>其中 <strong>contains()</strong> 判断 collection 是否包含某一元素</li><li><strong>retainAll()</strong> 表示<strong>当前集合只保留与指定集合的公共元素</strong>，比如下面的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCollection</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    collection1.add(<span class="hljs-number">1</span>);<br>    collection1.add(<span class="hljs-number">2</span>);<br>    collection1.add(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    collection2.add(<span class="hljs-number">2</span>);<br>    collection2.add(<span class="hljs-number">3</span>);<br>    collection2.add(<span class="hljs-number">3</span>);<br><br>    collection2.retainAll(collection1);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 <strong>collection2</strong> 进行 <strong>retainAll()</strong> 操作之后得到的结果就是与** collection1** 相同的元素，即：2，3。</p><ul><li><strong>removeAll() <strong>正好与</strong> retinAll() 相反，</strong>表示**移除当前集合移除与指定集合相同的元素，比如下面代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCollection</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>     collection1.add(<span class="hljs-number">1</span>);<br>     collection1.add(<span class="hljs-number">2</span>);<br>     collection1.add(<span class="hljs-number">3</span>);<br><br>     <span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>     collection2.add(<span class="hljs-number">2</span>);<br>     collection2.add(<span class="hljs-number">3</span>);<br>     collection2.add(<span class="hljs-number">4</span>);<br><br>     collection2.removeAll(collection1);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>collection2</strong> 进行 <strong>removeAll() <strong>操作之后，</strong>collection2</strong> 中的元素为：4。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 是<strong>有序且元素可重复</strong>的集合</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>ArrayList 底层是个数组实现</strong>，具有动态扩容的特点。说到数组，我们印象中的数组都是有容量限制的，都有一个固定大小，那 ArrayList 的动态扩容是怎么实现的呢？</p><p><strong>ArrayList 动态扩容原理</strong>：当 ArrayList 满了的时候，会自动扩容。ArrayList 会创建一个新的更大的空间的 List ，把原来满了的 List 的数据，复制到新的 List 中，并把原来满的 List 丢弃。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>LinkedList 底层是链表实现</strong>，LinkedList 在日常使用中很少使用到。</p><h2 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h2><p>ArrayList 是 Java 世界中，最常用的实现。既然是最常用的实现，为什么我们还需要 LinkedList? 既然有两种实现方式，那么两者的的区别和优缺点又是什么？</p><p>通过两者的底层实现可以发现他们各自的优势和区别。</p><p>因为 <code>ArrayList</code> 底层是数组实现，根据数组这一数据结构的特点，可以知道，数组用于查询，速度非常快。但是，数组做增删的操作就很比较慢。</p><p>而 <code>LinkedList</code> 的底层是链表实现，根据链表这一数据结构的特点，也很容易知道，链表的增删速度非常快，而对于查询来说就比较慢。</p><p>因此，综上所诉。对于查询需求较多的，我们可以使用 <code>ArrayList</code> 的实现，对于增删需求较多的，就使用 <code>LinkedList</code></p><h2 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h2><p>我们经常往 ArrayList 中添加元素，在们看来 ArrayList 好像是一个无限容量的空间一样，可以一直往里面丢东西。实际上是 ArrayList 的扩容机制在搞鬼，每当容量不足的时候，他就会在背后帮我们自动扩容，而我们是感知不到这个过程的，扩容机制给我们造成了无限容量的假象。</p><p>我们直接查看 ArrayList 的 add 方法源代码，如下。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Collection/7f8d3ac4-c857-44f1-8059-0f25f5d926df.png" alt="image.png"><br>可以发现在添加元素前，使用了 ensureCapacityInternal 方法，来确保可以添加。我们可以在 ensureCapacityInternal 的实现方法中找到 grow 方法，这个方法就是 ArrayList 扩容的秘密。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Collection/5b73daa1-eb23-4706-b5a4-67b333140334.png" alt="image.png"><br>可以看到代码中的 newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1)，表示的扩容后，新容量等于旧容量加上旧容量右移一位。右移可以理解为除以 n^2，此处就是旧容量除以1的2次方，相加之后新容量就是旧容量的1.5倍。<strong>ArrayList 扩容机制简述就是：创建一个更大的空间，空间容量为原来容量的1.5倍，然后把所有元素拷贝过去，完成扩容。</strong></p><p>说到这里还有个问题没有解决，既然 ArrayList 容量是有限的，那么<strong>我们直接 new 一个 ArrayList 的初始容量是多少呢？</strong>其实源代码已经给出答案了。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Collection/dd0e6e82-2b84-4a18-a78d-b61ffa2ad050.png" alt="image.png"><br>构造方法注释中标明，初始化容量是10。但我用 debug 调试的时候，发现初始容量并不是我们 new 的时候就创建好了，而是当我们往里面添加第一个元素时，触发了 ArrayList 的扩容机制，扩容成一个容量是10的新空间，再把我们要添加的元素放进新空间中。这属于懒加载机制，当我们需要添加元素时，才真正开辟空间。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 是<strong>无序且元素不可重复</strong>的集合。在 java 世界中，判断两个元素是否相同使用 <code>equals</code>  方法。</p><h2 id="简单的-Set-实现"><a href="#简单的-Set-实现" class="headerlink" title="简单的 Set 实现"></a>简单的 Set 实现</h2><p>我们可以顺着 List 的特性，以及 Collection 的 Contains() 方法来简单实现一个 Set。因为 Set 不包含重复元素，而且 Contains 方法就是判断元素是否重复。因此，只要往 List 中添加元素时，进行 Contains 判断，元素不重复就往 List 中添加，这样就能得到一个不包含重复元素的 List，也就是一个手写的简单 Set 实现。</p><h2 id="Java-世界的高效-Set-实现-HashSet"><a href="#Java-世界的高效-Set-实现-HashSet" class="headerlink" title="Java 世界的高效 Set 实现 HashSet"></a>Java 世界的高效 Set 实现 HashSet</h2><p>虽然我们手写的 Set 也能用，但是相比 Java 中其它的 Set 实现，性能差距不知差了多少。Java 世界中最高效的 Set 实现当属于 <code>HashSet</code> 。</p><h3 id="一、HashSet-实现简述"><a href="#一、HashSet-实现简述" class="headerlink" title="一、HashSet 实现简述"></a>一、HashSet 实现简述</h3><p>HashSet 之所以高效是因为他的背后是 HashBucket，即：哈希桶。每个哈希桶对应一个 hashCode。因此，每次往 HashSet 中添加元素的时候，首先通过 hash 运算，计算出它的 hashCode，再与哈希桶的 hashCode 进行比对，相同就把元素加入该哈希桶中。</p><h3 id="二、hashCode"><a href="#二、hashCode" class="headerlink" title="二、hashCode"></a>二、hashCode</h3><p>在了解 HashCode 之前，先了解下 <strong>Hash 运算</strong>。Hash 运算就是把我们数据变成一个哈希值，是一个单向映射操作。例如：假设 Hash 运算把名字变成姓氏，于是就是有「张三」-&gt;「张」、「李四」-&gt; 「李」，以此类推。Java 世界中的 Hash 运算有它<strong>自己的一套运算规则</strong>，我们只需要知道经过 Hash 运算会返回一个 int 值就行了。</p><p>hashCode 是数据通过 Hash 运算得到的值。我们可以通过 hashCode 来初步判断是否同一元素。</p><p>在 Java 世界中对象返回的 HashCode 都遵守以下约定：</p><ul><li><strong>同一个对象得到的 hashCode 相等</strong></li><li><strong>两个对象 <code>equals</code> 为 true，hashcode 相等</strong></li><li><strong>两个对象不等，hashcode 可能相等</strong></li></ul><h2 id="判断对象是否相等"><a href="#判断对象是否相等" class="headerlink" title="判断对象是否相等"></a>判断对象是否相等</h2><p>假设存在一个 Person 对象，它有 name 属性。现在我们要使得名字相同的对象为同一对象，应该怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面提到过判断是否重复我们可以使用 equals 方法，因此我们可以该方法来解决。假如我们初始化 person1，person2，他们的名字都是「张三」。然后我们再调用 equals 方法判断 <code>person1.equals(perons2)</code> ，结果返回的却是 false，为什么？</p><p>在我们看来，名字相同的人就是同一个对象，可是计算机却不是这么认为的，我们查看 Object 的 equals 方法发现，它比较的实际上是内存地址。因为是两个对象，所以他们指向的内存地址不同。尽管内存中的值相等，也没用。</p><p>因此，我们就需要重写 equals，hashCode 方法来达到相同名字为同一对象的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name.hashCode();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) obj;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(person.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 equals 中比较两个对象的名字是否相等，相等返回 true。同时遵守「两个对象 <code>equals</code> 为 true，hashcode 相等」的约定，所以我们再 hashCode 方法中根据 name 来返回 HashCode，当 name 相同时就会返回相等的 HahsCode。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 前世今生</title>
    <link href="/2021/03/11/HashMap%20%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <url>/2021/03/11/HashMap%20%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>要了解 HashMap 首先要先了解哈希表这种数据结构。哈希表是根据关键码值进行访问的数据结构。我们可以类比成现实生活中的电话本，如图所示。<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/9f0909d6-6a84-4b32-bdc3-fc840bdea650.png" alt="未命名绘图.png"><br>假设这个人交际能力特别强，他保存了很多人的电话，这个电话本就会很厚，当你想要查找某个人的电话时，就会非常费时。因此我们可以根据姓的首字母，分类排序，把张三放到 Z 里面，李四放到 L 里面，以此类推。通过这种方法，我们得找人效率就会大大提高。</p><p>我们已经按照刚才的方法分好类了，可以看到 Z 分类下面有多个名字，我们把这样一组称作<strong>哈希桶，</strong>把 Z 叫做** 哈希值，<strong>整个电话本就是一个</strong>哈希表，<strong>我们还把一个哈希值对应多个数据，这种现象叫做</strong>哈希碰撞。**<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/844b1fe2-e394-408f-844a-70aaae894537.png" alt="image.png"></p><p>使用哈希表的好处就是 O(1) 的平均查找，插入和删除时间。致命缺陷就是哈希值的碰撞（哈希碰撞）。在 Java 世界中对于 哈希表的实现就是 <strong>HashMap</strong>。</p><h2 id="Java-7中的-HashMap"><a href="#Java-7中的-HashMap" class="headerlink" title="Java 7中的 HashMap"></a>Java 7中的 HashMap</h2><p><strong>经典的哈希表实现：数组 + 链表，</strong>其中链表采用<strong>头插法（每次有新元素都放到第一位）</strong></p><h3 id="HashMap-构造方法"><a href="#HashMap-构造方法" class="headerlink" title="HashMap 构造方法"></a>HashMap 构造方法</h3><p>查看 HashMap 源代码，它默认的初始大小是 <code>1 &lt;&lt; 4 </code> ，表示位运算，等价于 1 * 2^4 即等于16，因此默认大小就是16。且注释中规定容量必须是2的幂。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/cbc5cd9a-5515-4432-8e2d-009399f03b07.png" alt="image.png"><br>源代码中定义了默认的 <code>DEFAULT_LOAD_FACTOR</code> （负载系数）是 0.75</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/33561655-26c8-42db-8bc5-cd58b28182b1.png" alt="image.png"><br>默认的构造函数，把默认的初始容量，以及默认的负载系数当参数传递给重载的构造函数。<strong>注意事项</strong>：当我们调用 HashMap 的构造函数时，哈希桶并没有开辟出来，只有第一次往里面 put 元素进去的时候，空间才会开辟出来，这样避免了空间浪费。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/97b7180f-0e42-461d-9e0a-be42e49e50dd.png" alt="image.png"><br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/61f58587-73d5-4448-9fff-b9592330c383.png" alt="image.png"></p><h3 id="HashMap-put-方法"><a href="#HashMap-put-方法" class="headerlink" title="HashMap put 方法"></a>HashMap put 方法</h3><p><strong>inflateTable 方法</strong></p><p>put 方法首先是一个判断，判断表是否是一个空表，如果是就调用 <code>inflateTable</code> 方法，把 threshold 参数传进去。因为使用 HashMap 构造方法时，以及将初始化容量赋值给 threshold，所以他的值就是容量的值。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/9a9c2b27-f7df-4bad-ac91-137539e78dec.png" alt="image.png"><br>执行 <code>inflateTable</code> 方法，我们可以看到该方法对于我们传来的容量值进行了一个向上取2次幂的操作。前面注释规定容量必须为2次幂，当我们自定义容量不为2次幂时，他就帮我们向上转为2次幂。例如：我们定义初始容量为17，他就会帮我们转化成32；初始容量定为5，帮我们转成8，这样就达到了容量必须为2次幂的要求。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/4c056e17-e2f0-4412-b312-286bf845742b.png" alt="image.png"></p><p><strong>hash 方法</strong></p><p>hash 方法把我们输入的 key 值，通过他特定的算法，返回一个 int 值。既然我们知道了元素对应的 hash 值，那么我们应该如何设计一个映射，把元素放到它对应的哈希桶里呢？就像「张三」对应 “Z” 这个桶一样。</p><p>数据结构课程中提到过<a href="https://baike.baidu.com/item/%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/10739384?fr=aladdin">取模运算</a>，我们把 hash 值通过取模运算得到的结果，跟哈希桶编号进行比对，一致就放在该哈希桶里。但是这样做存在两个缺点：由于 hash 值可能得到负数，负数取模运算还是负数，而哈希桶编号是正数。因此遇到 hash 是负数的情况，需要转化成正数；其次，使用取模运算较慢。</p><p>让我们看看源代码中 <code>indexFor</code> 方法，是如何设计其中的映射关系的。</p><p><strong>indexFor 方法</strong> </p><p>我们可以在 put 方法中找到这一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br></code></pre></td></tr></table></figure><p>其中把 hash 值和表的长度（表的长度为哈希桶个数，即为初始容量大小）当做参数，调用 indexFor 方法计算出该元素对应哈希桶的编号。</p><p>我们点进去查看具体的方法实现</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5dd68aec-3c81-4527-91d8-8fc3ac1d7acf.png" alt="image.png"><br>如图所示，他把 hash 值 length - 1 进行了<strong>按位与运算</strong>，得到的结果就是索引坐标。它这样做的目的在于提高效率，与运算比我们刚才说的取模运算要快很多。</p><p><strong>为什么容量必须是2的幂呢？</strong>我们前面一直说到容量必须是2的幂，是因为方便这里进行与运算。2的正数次幂的二进制值首位是1其它全部都是0，例如：2^3 &#x3D; 1000，2^4 &#x3D; 10000。因此当他们再减1时，得到的值都会变成1，例如：2^3 -1 &#x3D; 111，2^4 -1 &#x3D; 1111。使用这种都是1的数与 hash 值进行与运算，得到的坐标就与 hash 值有关了。假设我们初始容量是 2^4，减1之后与 hash 值进行按位与运算得到的坐标如下。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/89bb8103-15da-48af-9562-e9c28389b990.png" alt="QQ图片20210310211257_看图王_看图王.jpg"><br>假如我们不用2次幂来设定容量，我们设定容量为7，与 hash 进行与运算得到的坐标如下。你可能会想，这样不是也可以得到坐标吗？这样可以得到没错，但是会发现有些桶永远是空着的。如下图所示，当我们的 hash 值无论为多少，和110进行与运算后，最后一位一定是0，因此必然得不到101，001，011坐标，所以哈希桶坐标为5，1，3的桶永远都是空着的。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/36c09fd7-7821-4941-96b2-0289ef6bb055.png" alt="QQ图片20210310212221_看图王.jpg"></p><p><strong>addEntry 方法</strong> </p><p>接着 put 方法往下看，addEntry 方法往指定坐标的哈希桶里面添加元素。具体的实现方法如下</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/06ecc0c9-a6fc-49da-aea2-053f3a014339.png" alt="image.png"><br>可以看到，添加元素前前。进行了一个判断，当哈希桶中的元素 size 大于等于 threshold（初始化容量 * 负载系数，即默认的为 16*0.75 &#x3D; 12），并且指定的桶不能为空时，执行 resize 操作，新的容量是原来容量的2倍。</p><h3 id="HashMap-扩容操作"><a href="#HashMap-扩容操作" class="headerlink" title="HashMap 扩容操作"></a>HashMap 扩容操作</h3><p>以下是 resize 方法的具体实现<br><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/8f2d9003-c2fb-4b5e-b296-f838b51900a9.png" alt="image.png"><br>扩容的时候容量为原来的2倍，然后把原来所有的元素全部迁移到新的中去。元素的迁移过程使用了 transfer 方法</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/6532fd0a-4f7b-4d61-ad23-afa4e8517beb.png" alt="image.png"><br>transfer 方法遍历旧表中每一个桶里面的元素，重新进行 hash 运算，得到新的值，再把该元素放到新表中，对应的哈希桶中。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>在多线程环境中，java7中 HashMap 的实现容易成环，形成死锁，详见<a href="https://coolshell.cn/articles/9606.html">文章</a>。</li><li>可以通过精心构造的 HTTP 请求，使得所有元素都落入到同一个桶中，引发 DOS。</li></ul><h2 id="Java-8中的-HashMap"><a href="#Java-8中的-HashMap" class="headerlink" title="Java 8中的 HashMap"></a>Java 8中的 HashMap</h2><p><strong>实现：数组 + 链表&#x2F;红黑树，</strong>其中链表采用<strong>尾插法（每次有新元素都放到最后一位）</strong></p><h3 id="链表转为红黑树"><a href="#链表转为红黑树" class="headerlink" title="链表转为红黑树"></a>链表转为红黑树</h3><p>java 8中使用了新的数据结构，红黑树。但并不全是红黑树，原来的链表也是存在的。java 8中给链表中的元素设定了一个阈值，大于等于这个阈值就会转化成红黑树，如下图所示。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5290d35d-3571-4bf1-bf6e-4747f2405511.png" alt="image.png"><br>java 8 设定这个树形化的阈值 <code>TREEIFY_THRESHOLD</code> 为8，当链表中元素个数大于等于8时，就会转化为红黑树。 </p><p><strong>那么为什么要数量大于等于8时，才转化为红黑树呢？</strong>这个在源代码中也有解释，下图截取自 java 8的源代码注释。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/841cce86-ee23-43cf-9a79-b8b53fd24c69.png" alt="image.png"><br>通过图中的解释可以知道，我们的 hash 值是遵循<a href="https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/1442110?fr=aladdin">泊松分布</a>的。每个桶中有0个元素的概率是 0.60653066，以此类推，可以看到桶中有8个元素的概率是 0.00000006，超过8的概率小于十万分之一，这个概率已经非常小了。因此树形化阈值才会设定为8。</p><h3 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h3><p>java 8在原来 HashMap 扩容的基础上改进了一点，原来的 HashMap 扩容之后不保证顺序，java 8则保持了扩容之前与之后的元素插入顺序一致，这样降低了线程出现问题的概率，但还是没有彻底解决线程安全问题。在多线程环境下请使用 <strong>ConcurrentHashMap。</strong></p><p>java 7中旧表中的元素要重新进行 hash 运算得到 hash 值，再把它放到新表中，而 java 8对这一方法进行了优化。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/d6b6b55c-a0d7-4ab5-b969-c1117d960eba.png" alt="image.png"><br>假设图左边的初始容量为16，扩容之后诚意2得到的容量为32。 <code>1001001......11011</code> 这个哈希值，计算出它对应的坐标，因此与16 - 1的二进制，进行与运算，得到1011。而扩容到32时，按照原来的方法重新计算坐标得到 11011。从中我们可以发现，扩容之后，hash 值由原来的4位参与运算，变成了5位，我们把新增加的那一位称作<strong>高位</strong>，其他不变的称作<strong>低位。</strong>对应图中的高位就是标红的1，低位就是1011。进而我们也可以知道，扩容之后元素对应的坐标他的低位是不会变的，<strong>新坐标就取决于高位的值。</strong></p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/HashMap%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/49cbfaf9-6121-4e26-9d7a-099817a264f3.png" alt="image.png"><br>如图，高位为1时，原来的坐标 1011对应十进制是11，扩容之后新坐标 11011对应十进制是27，坐标发生了改变。高位为0时，原来的坐标还是1011，新坐标也是1011，新坐标与原来坐标相等。因此可以总结规律：<strong>高位为0，扩容之后新旧坐标相等；高位为1，新坐标 &#x3D; 1 + 旧坐标。</strong></p><p>java 8中 HashMap 就是根据这一规律进行扩容，这样计算新坐标比 java7重新进行坐标运算要快上不少。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/03/04/Git/"/>
    <url>/2021/03/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p>了解一门新的技术或者工具都要问这几个问题：它是什么？它有什么用？</p><p><code>Git</code> 是世界上最先进的<code>分布式</code>版本控制系统。这里又有两个小问题：什么是「分布式」？「版本控制」又是什么？</p><p>首先讲一下「版本控制」。什么是版本控制呢，只要玩过游戏就能很好的理解，「版本控制」就像游戏的「存档」一样。一般我们打 boss 前都会存档，我们可能存在多个存档，每次想回到哪个时间点都能回去。我们遇到很难打的 boss ，可以借号给朋友，让朋友帮你过，朋友打完也可以存档，这样你玩的时候已经通关了。这就是「多人协作」的好处，同样 Git 也是支持多人协作的。相比游戏「存档」，Git 还可以清楚的知道每个存档你做了什么事，比如：你在存档 A 过了新手村，存档 B 击杀了 boss。游戏就不同了，「存档」和「事件」的对应关系，需要自己去记忆，存档多了就会很不方便。 </p><h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><p>git add</p><p>git commit</p><p>git status</p><p>git diff</p><p>git log –pretty&#x3D;oneline</p><p>git reset –hard head^</p><p>git reflog</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>远程仓库熟悉的有 <code>GitHub</code>，<code>Gitee</code>。我们可以把我们的本地仓库推送到远程仓库上去，接下来都以 GitHub 仓库举例，练习。</p><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><p>由于本地的 Git仓库和 GitHub 的传输是通过 SSH 加密的，我们需要做一些简单设置。在用户主目录下，先检查电脑是否有 <code>.ssh</code> 文件夹，如果有，在看下有没有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 这两个文件。如果有，就跳到第二步。</p><p>一， 打开 <code>Git Bash</code>，输入如下命令命令，创建 SSH Key，记得把邮箱换成自己的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<br></code></pre></td></tr></table></figure><p>过程中出现提示，一直回车即可。成功的话，就可以在用户主目录下看到 <code>.ssh</code> 文件夹，以及该文件夹下的 <code>id_rsa</code>，<code>id_rsa.pub</code> 两个文件。</p><p>二，在 GitHub 添加 SSH Key。把刚才的 id_rsa.pub 文件里的内容复制到 GitHub 要添加 SSH Key 的地方，完成添加即可。GitHub 添加 SSH Key 的位置自行搜索。</p><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>使用如下命令关联远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote add origin 仓库地址<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 前后端基础架构原理</title>
    <link href="/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>当我们打开浏览器去访问一个网站时，发生了什么？在了解整个过程之前，我们应该先了解一些基本概念</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>首先我们需要明确一点的是，当我们访问一个网站的时候，实际上是在与一个主机进行交互。就像去商店购物一样，只要你不差钱，商店有的，它都能提供给你。</p><h3 id="主机（Host）"><a href="#主机（Host）" class="headerlink" title="主机（Host）"></a>主机（Host）</h3><p>主机简单来说就是一台电脑，只不过它的作用更多，可以响应浏览器发送的请求。我们平时所用的电脑也可以充当一台服务器，只不过需要一些专业的操作，才能把它变成主机。</p><p>那么问题来了，世界上有很多台主机，我们在浏览器输入 <a href="http://www.taobao.com/">www.taobao.com</a> 的时候，它是怎么帮我们找到淘宝的主机的？</p><h3 id="IP-与域名"><a href="#IP-与域名" class="headerlink" title="IP 与域名"></a>IP 与域名</h3><p>每个 IP 对应一个主机，因此只要我们知道 IP 地址就可以正确地找到对应的主机了。说到这里可能还有个疑问，我们明明输入的是一个网址，也没有看见 ip 地址啊，他怎么知道我访问的是那一台主机？这个就要说到 DNS 的功劳了。首先用 ip 去找对应的主机是没问题的，我们输入的网址本质上就对应一个 ip，只是我们没有察觉。DNS 就是把输入的网址，找到对应的 ip ，然后返回给我们。这样我们就本能的以为，只要输入网址就能找到对应的网站了，这是 DNS 给我们的错觉。</p><p>DNS 是个网络上的服务，他包含了域名和 ip 地址的映射关系。windows 本机上有个 hosts 文件，可以自己添加和修改网址和 ip 的对应关系，假如我们把 <a href="http://www.taobao.com/">www.taobao.com</a> 对应的 ip 改成 127.0.0.1，这样在浏览器再次输入<a href="http://www.taobao.com/">www.taobao.com</a> 就找不到原本的淘宝网站了，而是映射到本机。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>现在请假设一个场景：你有一台电脑，电脑连了一根网线，同时电脑上开了好几个程序，像 QQ、淘宝、微信。你有没想过，一根网线传的数据，他怎么知道哪个是 QQ 要的数据，哪个是淘宝返回的数据呢？</p><p>区分不同应用的数据，我们就用到了<strong>端口</strong>，不同应用他所对应的端口不一样的。网线中传输的数据，每个数据包都有对应的端口信息，就像一列火车一样，每个人的目的地不一样，有的在广州下车，有的在深圳下车，目的地不一样。数据也是这样，根据端口到达不同的应用中去。</p><p>我们可以经常看到网址前面有 http 或 https，他们都对应着不同的端口号。HTTPS 协议的默认端⼝是443，HTTP协议的默认端口是80。别看我们访问网站的时候没有看到端口号，其实浏览器已经在后面偷偷帮我们补上了。</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>当我们向远程的服务器发起请求时，TCP 协议就开辟了一条双车道的「高速公路」，不过在这条路上跑的是数据。同时数据也是一个一个的字节，所以也叫字节流，<strong>TCP是基于流的协议</strong>。由于是双车道，所以我们可以和服务器同时接受和发送数据，这叫做<strong>全双工协议，</strong>tcp就是全双工协议。半双工协议就是类似生活中的「对讲机」，只有对方说完，我们才能说话。</p><p><strong>TCP 协议本质上就是规定字节流如何发送和接收</strong></p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>Http 是在 TCP 协议之上的一层协议。Http 定义了文本之外的东西如何被传输。我们把发送给服务器的字节流叫做 <strong>HTTP Request</strong>，比如我们访问豆瓣首页。我们就会向服务器发送如下字节流。</p><p><strong><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/a46104e5-ab13-4c06-8d67-fc25533364f0.png" alt="image.png"></strong><br>服务器收到请求之后就会返回一个 <strong>HTTP Response <strong>字节流，除了 Headers 之外，还返回了</strong> HTTP Response Body（响应体）</strong>，response body 可以是文本，也可以是及二进制数据，包括图片、声音、下载的文件等。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/d1b5fc66-e420-4974-a253-2d14fc46da93.png" alt="image.png"><br>刚才访问的豆瓣网站，就返回了一个 response body，一个 html 文件。我们得浏览器收到这个 html 文件，就会根据他的结构，标签去解析和展示他。我们看到的页面就是浏览器解析之后的样子。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/b594a1c8-ea35-46ee-9093-5ff9fe6ae319.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 包冲突解决过程</title>
    <link href="/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>记录一次 maven 包冲突解决过程，项目地址<a href="https://github.com/hcsp/resolve-package-conflict">链接</a>。</p><h2 id="查看错误方法"><a href="#查看错误方法" class="headerlink" title="查看错误方法"></a>查看错误方法</h2><p>首先要将项目克隆到本地，然后运行，找到出错的位置，以及出错的信息。<br> <img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb20e3c-d218-44f4-a995-61be864a19e4.png" alt="image.png"><br>如图所示，错误的位置在 MainTest.java 文件第六行，错误信息 <code>NoSuchMethod</code> ，表示没有找到这个方法。根据位置提示，一层一层往下找，发现原来是 A.java 这个类中调用的 <code>getJsonpFunction</code> 方法找不到</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb93ac6-bf86-4f27-8f3f-5b0e0f6978ce.png" alt="image.png"></p><h2 id="查看包冲突"><a href="#查看包冲突" class="headerlink" title="查看包冲突"></a>查看包冲突</h2><p>通过使用 maven helper 插件查看包的依赖树。如图所示，spring-web:5.1.8.RELEASE 版本和 spring-web:4.3.6.RELEASE 版本冲突了。图上的 4.3.6 版本为红色，可知，maven 使用的是 5.1.8 版本。我们根据 maven 解决包冲突的就近原则来看，5.1.8 离项目的距离为1，4.3.6 的距离为2，因此保留5.1.8版本，再次证实了这一点。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/bcd7d3b1-5625-4466-9bff-4d7fa1cf4a7c.png" alt="image.png"></p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>既然知道了是 spring-web 这个包的问题。我们就访问 maven 仓库，找到对应的版本，访问他的 github 主页。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/529dcfcc-07f4-4315-b0bc-e1fc3b11c480.png" alt="image.png"><br>找到了 github 仓库，进入报错的那个类，通过切换 tags 来切换不同版本对应的源代码，两者进行比较。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/cb13c43d-19fe-41db-9552-443f008f598a.png" alt="image.png"><br>对比发现在5.1.8版本 org.springframework.http.converter.json.MappingJacksonValue 中不存在 <code>getJsonpFunction</code>  这个方法。而 4.3.6 中却有。因此可以断定，我们项目本该使用 4.3.6 版本，而 maven 帮我们剔除了 4.3.6 版本，保留了 5.1.8 版本，导致找不到 <code>getJsonFunction</code> 而报错。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/a26925af-9758-4767-8e5a-107165edd81b.png" alt="image.png"></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>知道了冲突的原因，我们就只需要把 5.1.8 版本的依赖注释掉就行，这样 maven 就会帮我们加载 4.3.6 版本的包了。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/4efcceb9-a459-4eb2-bda3-58ab8f6dda90.png" alt="image.png"><br>同时也可以将 5.1.8 版本的依赖改成 4.3.6 版本，解决冲突。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 与命令行</title>
    <link href="/2021/03/01/Java%20%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2021/03/01/Java%20%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>在日常写 Java 程序的工作中，运行，debug 等等操作，本质上都是在进行命令行操作。我们在 IDE 上点击运行，Java 程序就会运行，实际上 IDE 在背后帮我们进行了命令拼接。</p><p>我们可以在 IDEA 中编写一个简单的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> zzf;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zzf</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/2/28/028 21:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 zzf 包下面有个 Main.java 类，里面有个 main 方法输出了 “Hello World”。在 IDEA 中点击了运行按钮之后，控制台会有一串命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">D:\java\jdk\bin\java.exe -javaagent:D:\software\Idea\ideaIU-2019.2.3.win\lib\idea_rt.jar=56956:D:\software\Idea\ideaIU-2019.2.3.win\bin -Dfile.encoding=UTF-8 -classpath D:\Java\jdk\jre\lib\charsets.jar;D:\Java\jdk\jre\lib\deploy.jar;D:\Java\jdk\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk\jre\lib\ext\cldrdata.jar;D:\Java\jdk\jre\lib\ext\dnsns.jar;D:\Java\jdk\jre\lib\ext\jaccess.jar;D:\Java\jdk\jre\lib\ext\jfxrt.jar;D:\Java\jdk\jre\lib\ext\localedata.jar;D:\Java\jdk\jre\lib\ext\nashorn.jar;D:\Java\jdk\jre\lib\ext\sunec.jar;D:\Java\jdk\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk\jre\lib\ext\sunmscapi.jar;D:\Java\jdk\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk\jre\lib\ext\zipfs.jar;D:\Java\jdk\jre\lib\javaws.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\lib\jfxswt.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\management-agent.jar;D:\Java\jdk\jre\lib\plugin.jar;D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\idea-work\testDemo\out\production\testDemo zzf.Main<br></code></pre></td></tr></table></figure><p>当我们把该命令复制到 CMD 窗口运行的时候，同样控制台会打印 “Hello World”</p><h2 id="Java-执行过程"><a href="#Java-执行过程" class="headerlink" title="Java 执行过程"></a>Java 执行过程</h2><p>我们平时写的源代码（.java 文件），需要编译成字节码（.class 文件），然后再给到 jvm 去解释执行。jvm 只认识字节码，多个 class 文件可以打包成 jar 包来执行。</p><h3 id="args-参数"><a href="#args-参数" class="headerlink" title="args 参数"></a>args 参数</h3><p>我们写 Java 程序，main 方法里面都有一个 args 参数，实际上这个参数是可以从命令行获取的。编写以下程序获取打印 args 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>System.out.println(java.util.Arrays.toString(args));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令编辑和运行该程序</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/cb5a1ca0-47b2-4f27-adf4-23b88ff755c8.png" alt="image.png"><br>可以看到使用 <code>java Main</code> 运行时，打印为空字符串，而在后面添加 <code>1 2 3</code> 三个参数时，打印 <code>[1,2,3]</code> 。</p><p><code>java Main 1 2 3</code> 表示，调用 java 这个可执行程序，然后把 <code>Main 1 2 3</code> 这四个参数传递个 java。java 把 Main 这个类名拿出来，并且运行这个类，后面的参数 <code>1 2 3</code> 当做这个类的参数，传递给这个类的 main 方法。</p><h3 id="jvm-中的系统属性和环境变量"><a href="#jvm-中的系统属性和环境变量" class="headerlink" title="jvm 中的系统属性和环境变量"></a>jvm 中的系统属性和环境变量</h3><p>系统属性和环境变量是完全不同的东西，系统属性只在 jvm 中有效，不像环境变量可以继承属性。</p><p>我们可以在代码中使用 <strong>System.getenv()</strong> 来获取当前环境变量，使用 <strong>System.getProperty()</strong> 获取系统属性。我们可以编写如下代码（其中 java.version 是 jvm 自带的系统属性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>    <span class="hljs-comment">// 打印 args 参数</span><br>System.out.println(<span class="hljs-string">&quot;args: &quot;</span> +java.util.Arrays.toString(args));<br>    <span class="hljs-comment">// 打印名为 zzf 的环境变量</span><br>System.out.println(<span class="hljs-string">&quot;env: &quot;</span> +System.getenv(<span class="hljs-string">&quot;zzf&quot;</span>));<br>    <span class="hljs-comment">// 打印名为 zzf 的系统属性</span><br>System.out.println(<span class="hljs-string">&quot;System Property: &quot;</span> +System.getProperty(<span class="hljs-string">&quot;zzf&quot;</span>));<br>    <span class="hljs-comment">// 打印名为 java.version 的系统属性</span><br>System.out.println(<span class="hljs-string">&quot;Java version: &quot;</span> +System.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先使用 <code>export zzf=helo</code> 给当前环境添加环境变量 zzf，值为 hello，然后运行。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/f9e53a89-e89f-4f30-ae14-bf89b7712e10.png" alt="image.png"><br>可以发现系统属性 zzf 并没有，打印为 null。而由于 jvm 存在系统属性 java.version，所以正确打印出版本号。要传入系统属性给 jvm 我们需要使用 <strong>-D</strong> 参数，如图所示。</p><p><img src="https://zzfpicture.oss-cn-shenzhen.aliyuncs.com/image/picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/38903da7-6c08-4b00-bbe3-39cc1fb23f9a.png" alt="image.png"></p><h3 id="java-代码中的包"><a href="#java-代码中的包" class="headerlink" title="java 代码中的包"></a>java 代码中的包</h3><p>假设有如下代码 zzf.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">zzf</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">0</span>]));<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">1</span>]));<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">2</span>]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码引用了第三方的包 <code>org.apache.commons.lang3.StringUtils</code> ，当我们使用 javac 编译的时候会报错，找不到这个包。因此，就需要指定这个包的目录，假设 <code>commons-lang3-3.9.jar</code> 文件和 zzf.java 文件在同一目录下，我们就可以使用 -classpath（简写 -cp），指定文件的位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -cp commons-lang3-3.9.jar zzf.java<br></code></pre></td></tr></table></figure><p>这样就可以编译通过。但是在运行 java 程序的时候，需要同时指定引用的包的位置，还需要指定 zzf.class 文件位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ./commons-lang3-3.9.jar:. zzf 1 2 3<br></code></pre></td></tr></table></figure><p> 该命令指定了第三方包的位置，以及 zzf.class 文件的位置。由于 zzf.class 文件是在当前目录，所以用 “.” 来表示。在 Linux 中多个目录用 “:” 隔开，Windows 使用 “;” 隔开。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到这个命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">D:\java\jdk\bin\java.exe -javaagent:D:\software\Idea\ideaIU-2019.2.3.win\lib\idea_rt.jar=56956:D:\software\Idea\ideaIU-2019.2.3.win\bin -Dfile.encoding=UTF-8 -classpath D:\Java\jdk\jre\lib\charsets.jar;D:\Java\jdk\jre\lib\deploy.jar;D:\Java\jdk\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk\jre\lib\ext\cldrdata.jar;D:\Java\jdk\jre\lib\ext\dnsns.jar;D:\Java\jdk\jre\lib\ext\jaccess.jar;D:\Java\jdk\jre\lib\ext\jfxrt.jar;D:\Java\jdk\jre\lib\ext\localedata.jar;D:\Java\jdk\jre\lib\ext\nashorn.jar;D:\Java\jdk\jre\lib\ext\sunec.jar;D:\Java\jdk\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk\jre\lib\ext\sunmscapi.jar;D:\Java\jdk\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk\jre\lib\ext\zipfs.jar;D:\Java\jdk\jre\lib\javaws.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\lib\jfxswt.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\management-agent.jar;D:\Java\jdk\jre\lib\plugin.jar;D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\idea-work\testDemo\out\production\testDemo zzf.Main<br></code></pre></td></tr></table></figure><p>先不管 <code>-javaagent</code> ，从 <code>-Dfile.encoding=UTF-8</code> 给 jvm 设置一个系统属性 file.encoding&#x3D;UTF-8，然后使用 <code>-classpath</code> 指定引用的包路径，要运行的文件的位置。最后只剩需要执行的文件名称 <code>zzf.Main</code> 。把上述这些都交给 <code>D:\java\jdk\bin\java.exe</code> 该可执行程序执行。</p>]]></content>
    
    
    <categories>
      
      <category>博客专栏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
