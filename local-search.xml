<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring 与事务</title>
    <link href="/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事务是让人生厌的八股，也是面试中的常客。网路上关于 Spring 与事务的问题非常多，然而大部分解答都是在「 背答案」，并没有把它的底层逻辑讲清楚，只要问题一经变通，也就无从下手不知所措。</p><p>Spring 使用魔法般的注解 <code>@Transactional</code> 帮我们解决事务的使用问题，给我们带来便利的同时，也屏蔽了底层的细节。屏蔽了底层的细节，也就导致事务相关的使用都是靠着积累的经验，而无法真正理解它。</p><p><strong>说明：</strong>本文仅对 Spring 中事务的原理进行说明，MySQL 中的事务实现不在本文阐述。</p><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>事务这个概念有点抽象，可以把它看做由一堆 SQL 语句组成的操作。</p><p>事务可以保证它里面的 SQL 语句要么全部成功，要么全部失败，不存在第三种中间状态。</p><p>事务还有 ACID 四种特性，陈词滥调这里不想过多阐述，可以自行 Google 了解。</p><h2 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h2><p>首先要说明的是，「 事务」更像是一种约定，数据库可以选择遵守或不遵守该约定。即便是在支持事务的数据库中，它们实现事务的方式也各不相同，MySQL 提供对事务的支持，接下来看看在 MySQL 中要如何使用事务。</p><p>在使用事务之前，需要了解事务相关的一些概念。</p><ul><li>事务（transaction）指一组 SQL 语句，对应的是整个转账流程。</li><li>回滚（rollback）指撤销指定的 SQL 语句</li><li>提交（commit）将未存储的 SQL 语句结果写入到数据库</li><li>保留点（savepoint）指事务处理中设置的临时占位符，用于事务回滚到指定的 SQL 语句。</li></ul><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>假设这样一个场景：用户注册一个账号，默认金额是 0 元，之后充值了 100 元，两个操作都在一个事务内。对应的 SQL 语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL 中标识事务开始</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>上诉操作完成了一个事务的提交，倘若要回滚上诉操作只需要将 <code>COMMIT</code> 替换成 <code>ROLLBACK</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>不知道你发现了没有，提交和回滚都是针对一组 SQL 进行的。用户注册账号成功，但是充值失败，能否让「 充值失败」不影响到用户注册。</p><p>答案是肯定的，上面提到的 <code>SAVEPOINT</code> 就是解决该问题的。</p><p><code>SAVEPOINT</code> 就像游戏存档一样，可以在事务的执行过程中建立多个存档，遇到异常可以随时返回到指定的存档。如下面的语句，「 注册」会成功，而「充值」失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">-- 创建名为 `register_user` 的保留点</span><br><span class="hljs-keyword">SAVEPOINT</span> register_user;<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 回滚到 `register_user` 保留点</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> register_user;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h2 id="传统的-JDBC-管理事务"><a href="#传统的-JDBC-管理事务" class="headerlink" title="传统的 JDBC 管理事务"></a>传统的 JDBC 管理事务</h2><h3 id="提交与回滚操作"><a href="#提交与回滚操作" class="headerlink" title="提交与回滚操作"></a>提交与回滚操作</h3><p>看下这段代码，你是否熟悉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection(); <span class="hljs-comment">// (1)</span><br><br><span class="hljs-keyword">try</span> (connection) &#123;<br>    connection.setAutoCommit(<span class="hljs-literal">false</span>); <span class="hljs-comment">// (2)</span><br>    <span class="hljs-comment">// 执行一些 SQL 代码</span><br>    connection.commit(); <span class="hljs-comment">// (3)</span><br><br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    connection.rollback(); <span class="hljs-comment">// (4)</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取数据库连接，获取的方式有多种，现在大多数都是维护一个数据库连接池，然后从连接池分配一个连接。</li><li>把获取到的数据库连接，关闭自动提交。因为事务要交由代码管理，而不是让数据库默认提交。</li><li>当执行完 SQL 代码之后，开始提交。</li><li>数据库进行 COMMIT 提交出现异常，代码中进行捕获，并执行回滚操作。</li></ol><h3 id="设置隔离级别与保留点（SAVEPOINT）"><a href="#设置隔离级别与保留点（SAVEPOINT）" class="headerlink" title="设置隔离级别与保留点（SAVEPOINT）"></a>设置隔离级别与保留点（SAVEPOINT）</h3><p>在  jdbc 中设置数据库隔离级别和 <code>SAVEPOINT</code> 也是非常简单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">Savepoint</span> <span class="hljs-keyword">savePoint</span> <span class="hljs-operator">=</span> connection.setSavepoint(); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">2</span>)<br><br>connection.rollback(<span class="hljs-keyword">savePoint</span>);  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><ol><li><code>setTransactionIsolation</code> api 就可以设置数据库的隔离级别</li><li><code>setSavepoint</code> 创建一个 <code>SAVEPOINT</code></li><li><code>rollback</code> 到上一个 <code>SAVEPOINT</code></li></ol><p>可以看到 jdbc 中对数据库事务的操作都是非常简单的，Spring 与 jdbc 实现事务的操作并无太大差别，只是他把这些封装的太好，会让你觉得是魔法，难以理解。</p><h2 id="Spring-的事务魔法"><a href="#Spring-的事务魔法" class="headerlink" title="Spring 的事务魔法"></a>Spring 的事务魔法</h2><h3 id="Transactional-注解"><a href="#Transactional-注解" class="headerlink" title="Transactional 注解"></a>Transactional 注解</h3><p>使用 JDBC 开启事务，需要写大量的 <code>try...catch</code> 。通常 <code>try</code> 代码块执行 SQL 操作，<code>catch</code> 中捕获异常进行回滚。</p><p>来看下 Spring 中为一个方法添加事务有多简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        userDao.save(user);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>加上 <code>@Transactional</code> 注解等价代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            userDao.save(user);<br><br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个操作，相比上面的 JDBC 操作，简便不少。操控事务的样板代码，不用在每个方法中写了，一个注解 Spring 统统搞定。</p><p>因此，Spring 的事务魔法秘密就揭开了。对加了 <code>@Transactional</code>的方法或者类，使用 AOP 的方式，帮你生成数据库的链接，事务开启、提交、回滚代码，仅此而已。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在深入 <code>@Transcational</code> 注解之前，还是要先简单介绍下 AOP 在事务上的实现，这对你理解后面的问题，大有裨益。</p><p>首先要清楚 AOP 在实现事务时，并不会改变原来类的行为，它只是生成了一个代理类。生成代理类的方式有 CGLIB、JDK 动态代理，两种代理方式各不相同，但这里不对代理方式阐述。</p><p>通过一个简单的 Demo 看下这个流程：</p><p>在 <code>UserService</code> 的 <code>registerUser</code> 方法开启事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 注册用户代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 使用 AOP 为 <code>UserService</code> 生成代理类 <code>UserServiceProxy</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 调用 UserService 的 registerUser 方法</span><br>            invoke();<br>           <br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>UserController</code> 中注入 <code>UserService</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/register&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span>&#123;<br>userService.registerUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>/register</code> 请求的流程如下：</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/01acb810-c014-487d-9a72-7a6111fd0920.png" alt="aop.png"></p><p>可以看到，<code>Controller</code>  实际上是调用 <code>UserServiceProxy</code> 的 <code>registerUser</code> 方法，然后在代理方法中操控事务，并调用真正的 <code>UserService</code> 的 <code>registerUser</code>。</p><p>或许你还有个疑问：注入的是 <code>UserService</code> ，为什么调用的却是它的代理类？</p><p>这就涉及 Spring  的依赖注入原理，详细可以自行搜索。实际上在 <code>UserController</code> 中注入的是 <code>UserServiceProxy</code> ，而非看到的 <code>UserService</code>。</p><h3 id="一些疑难杂症"><a href="#一些疑难杂症" class="headerlink" title="一些疑难杂症"></a>一些疑难杂症</h3><p>列举一些关于 Spring 事务的疑难杂症，也是面试的常考题。</p><h4 id="为什么-private-方法加-Transactional-注解不生效"><a href="#为什么-private-方法加-Transactional-注解不生效" class="headerlink" title="为什么 private 方法加 @Transactional 注解不生效?"></a>为什么 <code>private</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>这个问题其实是和 AOP 相关的，因为 AOP 无法对 <code>private</code> 方法生成代理。无法代理也就意味着对 <code>priavte</code> 方法的调用，都是直接调用被代理的类。</p><h4 id="为什么-final-方法加-Transactional-注解不生效"><a href="#为什么-final-方法加-Transactional-注解不生效" class="headerlink" title="为什么 final 方法加 @Transactional 注解不生效?"></a>为什么 <code>final</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>原理同上，还是 AOP 无法代理被 <code>final</code> 关键字修饰的方法和类</p><h4 id="为什么类方法相互调用事务不生效？"><a href="#为什么类方法相互调用事务不生效？" class="headerlink" title="为什么类方法相互调用事务不生效？"></a>为什么类方法相互调用事务不生效？</h4><p>事务方法 <code>a</code>调用同类的事务方法 <code>b</code> ，在外部调用 <code>a</code> 方法，<code>b</code> 方法的事务不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个只需要分析下调用过程就清楚了：</p><ol><li>先调用代理类中的 <code>a</code> 方法，然后代理类中调用真正的 <code>a</code> 方法。</li><li><code>UserService</code> 的 <code>a</code> 方法执行过程中，发现要调用 <code>b</code> 方法，因此调用了自己的 <code>b</code> 方法。</li></ol><p>可以看到，<code>a</code> 调用 <code>b</code> 的时候，并没有先经过代理类，而是直接在 <code>UserService</code> 中执行了，所以 <code>b</code> 的事务不会生效。</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/9559d6ef-b67e-49b3-b2a3-6ed40d97aa6d.png" alt="question_1.png"></p><h4 id="为什么注入自己就能解决相互调用问题？"><a href="#为什么注入自己就能解决相互调用问题？" class="headerlink" title="为什么注入自己就能解决相互调用问题？"></a>为什么注入自己就能解决相互调用问题？</h4><p>同样是上面的代码，只需要在 <code>UserService</code> 中注入自己，<code>b</code> 的事务就生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Autowird</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        userService.b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面说的依赖注入吗，这里注入自己，实际上注入的是 <code>UserService</code> 的代理类。因此在执行 <code>userService.b()</code> 这段代码时，会调用代理类的 <code>b</code> 方法，所以 <code>b</code> 的事务生效。</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/4f01d7cf-3c53-4e24-ae76-69b835d7d61b.png" alt="question_2.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的 GC</title>
    <link href="/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/"/>
    <url>/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/</url>
    
    <content type="html"><![CDATA[<p>人在日常活动中不可避免会产生垃圾，程序也是如此。在方法中 new 一个对象，每次调用该方法都会进行 new 对象操作，如果没有人去管理这些对象，没有把这些对象占有内存及时释放掉，内存很快就会满。因此，在程序运行过程中，需要及时寻找和处理「 死去」的对象。这个「 死去」的对象就是<strong>垃圾</strong>，而寻找和处理垃圾的过程就叫做 <strong>GC</strong>。</p><p>GC 全称 “Garbage Collection” 即垃圾收集。不同的语言对于 GC 的处理都是不一样的，因此也产生了不同的「流派」。</p><p><strong>需要说明的是</strong>：本文介绍的 GC 都是基于 HotSpot。</p><h2 id="垃圾管理流派"><a href="#垃圾管理流派" class="headerlink" title="垃圾管理流派"></a>垃圾管理流派</h2><p>根据内存的管理方式，划分出两个流派：手动管理和自动管理。</p><p>手动管理的代表就是：C ++ 和 C。它们需要在编码过程中，手动去释放内存。</p><ul><li>优点：能明确垃圾的产生，以及提高回收的效率。 </li><li>缺点：垃圾太多，在代码中手动清理内存很「痛苦」，很容易忘记释放内存，导致内存泄露。由于需要明确垃圾的产生位置，因此也需要对该语言非常熟悉，这也无形中加大了语言的上手难度。</li></ul><p>自动管理的代表：Java (当然还有很多其他语言，篇幅有限，暂不阐述)。</p><ul><li>优点：使用者无需关心内存的使用，只需专注功能和业务的实现。内存的处理和回收有个智能的程序替我们完成。</li><li>缺点：屏蔽了底层细节，出现了内存问题，使用者无法着手解决。当然解决办法也很简单，就是去了解 GC 原理。</li></ul><h2 id="寻找垃圾"><a href="#寻找垃圾" class="headerlink" title="寻找垃圾"></a>寻找垃圾</h2><p>现在我们知道 Java 是自动 GC，那现在问题来了：它是怎么去找到垃圾？怎么保证找的对象就一定是垃圾呢？</p><p>在「 找垃圾」这块，也有两种方式：引用计数和可达性分析。虽然有两种方式，但主流的 Java 虚拟机里面都没有选用引用计数。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>如图所示，小圆圈代表对象，箭头代表引用关系，数字代表对象被引用的次数。可以看到蓝色的对象都是处于「 活跃」状态的，而灰色的对象要么没有被引用，要么引用它的对象没有被引用，这些对象就是程序需要回收的垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/2069ac04-c401-4330-bb40-6fda0dea5fcb.png" alt="GC-in-Java-01.PNG"></p><p>这一切看似完美无缺，实则存在一个巨大问题：对象间的循环引用。</p><p>仔细看上面这张图，红色的对象相互循环引用，程序并没有使用到，理应当作垃圾处理。但是，在引用计数方法看来这是个「 活跃」的对象，因此并不会进行处理。</p><p>在一些文章上有谈论到解决该问题的方法，例如：循环引用的对象使用 <code>弱引用</code>，使用单独的算法等，详情可以自行搜索。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>Java 就是通过<code>可达性分析</code>算法来进行内存管理的。</p><p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，即通过 GC Roots 访问不到该对象时，则证明此对象是垃圾。</p><p>用比较生活化的例子来解释：家是内存，家庭成员是 GC Roots，物品是对象，家庭大扫除就是可达性分析。家庭大扫除的结果就是把家庭成员都用不到的东西归为垃圾，并把它清除掉。</p><p>如图所示：灰色的对象就是 GC Roots 访问不到的对象，这些对象就是垃圾。图中也可以看到对象循环引用的问题的，在这里也已经不复存在，都会被当做垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/09db1a69-e11e-4a4b-9bdd-43946cb355a5.png" alt="GC-in-Java-02.PNG"></p><p>大扫除的例子，我们知道「 家庭成员」是 GC Roots，在 Java 技术体系中常见的 GC Roots 包括以下几种：</p><ul><li>线程</li><li>native 方法</li><li>栈帧中的局部变量表</li><li>Class 引用的 static field</li><li>所有被同步锁（synchronized关键字）持有的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过上面两种方法来看，似乎对象在内存中的状态只有「 被引用」和「 未被引用」两种状态，GC 把「 未被引用」 的对象收集。</p><p>在在内存空间充足时，可能并不希望「 未被引用」的对象被清除，只有当内存紧张时，才把那些对象抛弃。</p><p>在 Java 中对引用的概念进行扩充，将引用分为：</p><ul><li>强引用（Strongly Re-ference） <ul><li>在 Java 程序代码中普遍存在的就是<code>强引用</code>，比如你 new 一个对象。</li></ul></li><li>软引用（Soft Reference） <ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li></ul></li><li>弱引用（Weak Reference） <ul><li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li></ul></li><li>虚引用（Phantom Reference） <ul><li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。类似于 Linux 中的 <a href="https://zh.wikipedia.org/wiki/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">退出状态</a>。</li></ul></li></ul><p>这4种引用强度依次逐渐减弱。</p><h2 id="垃圾自我救赎"><a href="#垃圾自我救赎" class="headerlink" title="垃圾自我救赎"></a>垃圾自我救赎</h2><p>使用可达性分析找到「未被引用」的对象并不会立即将内存释放，而是给这些对象进行<code>标记</code> ，当对象被<strong>标记两次</strong>后才会进行回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/8939c679-8d1a-4d66-8bd4-910e8e25d6bd.png" alt="image.png"></p><p>当对象第一次标记之后，随后会进行一次筛选，筛选的依据是：<strong>对象是否有必要执行 finalize() 方法？</strong></p><p>假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>「没有必要执行」</strong>。</p><p>对象被判定为「没有必要执行」，则直接进行回收。否则，会把对象放入到一个名为 <code>F-Queue</code> 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。流程如下：</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/f74a1943-9e8f-440b-b097-b3eb7995cd64.png" alt="image.png"></p><p>对象的 finalize() 方法执行，GC 对 <code>F-Queue</code> 中的对象进行第二次标记。如果 finalize() 方法执行之后，对象重新回到了 GC Roots 的引用链上，则把它移出队列。否则，被 GC 回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/41e3ebdc-ac30-40a3-9783-9bdd08b958f7.png" alt="image.png"></p><p>这个时候你可能就有问题了：那我在对象的 finalize() 方法中，编写代码使得当前对象重新回到 GC Roots 引用链上，这个对象岂不是永远不会被 GC 回收？</p><p>答案是会被回收。可以看到「没有必要执行」的条件中有一条是： <strong>finalize() 方法已经被虚拟机调用过</strong>。因此对象虽然能回到引用链上，但是下一次 GC 它一定会被回收。<strong>总结就是：一个对象只能被救赎一次。</strong></p><p>其实关于  finalize() 方法，很多人也不了解，只需要知道它会于 GC 过程产生联系即可。在 《Effective Java》第三版 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md">Item 8</a> ，以及《深入理解 Java 虚拟机》第三版中，作者都不建议在代码中使用 finalize，甚至让我们忘记这个 API。</p><p>因此，使用  finalize() 方法的最佳实践就是：从不使用它。</p><blockquote><p>文章参考《深入理解 Java 虚拟机》第三版、《Effective Java》第三版、《Plumbr Handbook Java Garbage Collcetion》。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins 自动化部署</title>
    <link href="/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>简介：Java 编写的最广泛使用的开源持续集成工具，非常易用，广泛的第三方插件支持，以及分布式构建。</p><p>文章所演示的项目地址：</p><p>GitHub: <a href="https://github.com/greek-zzf/oh-my-jenkins.git">https://github.com/greek-zzf/oh-my-jenkins.git</a><br>Gitee: <a href="https://gitee.com/geek-zzf/oh-my-jenkins.git">https://gitee.com/geek-zzf/oh-my-jenkins.git</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="War-包方式"><a href="#War-包方式" class="headerlink" title="War 包方式"></a>War 包方式</h3><p>优点：安装启动非常方便。</p><p>缺点：与环境强绑定，服务器要为 Jenkins 提供部署项目所需要的环境，例如：Node、Java 等。 部署成服务需要使用对应平台的命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到安装方式，下载 War 包。或者直接点击<a href="https://www.jenkins.io/download/">这里</a>下载。 </p></li><li><p>下载完成运行命令 <code>java -jar jenkins.war</code> ，等待几分钟。 </p></li><li><p>在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>优点：与宿主机环境隔离，不依赖宿主机环境。注册成服务非常方便，只需要启动时设置好参数 <code>--restart=always</code> 即可。</p><p>缺点：启动稍微复杂，需要配置好启动命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到 Docker 安装方式。或者直接点击<a href="https://www.jenkins.io/doc/book/installing/docker/">这里</a>访问。 </p></li><li><p>运行 Docker 命令如下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">step1: docker network create jenkins<br><br>step2: docker run --name jenkins-docker --rm --detach \<br>  --privileged --network jenkins --network-alias docker \<br>  --env DOCKER_TLS_CERTDIR=/certs \<br>  --volume jenkins-docker-certs:/certs/client \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --publish 2376:2376 \ <br>  docker:dind --storage-driver overlay2   --insecure-registry 47.107.74.10:5000 <br> <br><br>step3: 创建 Dockerfile 文件，并把如下内容复制进去<br><br>    FROM jenkins/jenkins:2.332.2-jdk11<br>    USER root<br>    RUN apt-get update &amp;&amp; apt-get install -y lsb-release<br>    RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \<br>      https://download.docker.com/linux/debian/gpg<br>    RUN echo &quot;deb [arch=$(dpkg --print-architecture) \<br>      signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \<br>      https://download.docker.com/linux/debian \<br>      $(lsb_release -cs) stable&quot; &gt; /etc/apt/sources.list.d/docker.list<br>    RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli<br>    USER jenkins<br>    RUN jenkins-plugin-cli --plugins &quot;blueocean:1.25.3 docker-workflow:1.28&quot;<br><br>step4: docker build -t myjenkins-blueocean:2.332.2-1 .<br><br>step5: docker run --name jenkins-blueocean --rm --detach \<br>  --network jenkins --env DOCKER_HOST=tcp://docker:2376 \<br>  --env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \<br>  --publish 8080:8080 --publish 50000:50000 \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --volume jenkins-docker-certs:/certs/client:ro \<br>  myjenkins-blueocean:2.332.2-1<br></code></pre></td></tr></table></figure></li><li><p>等待一会，在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><p><strong>注意</strong>：步骤4构建失败，可能是由于 Docker 权限问题，解决方案可参考<a href="https://github.com/docker/buildx/issues/476">这里</a>。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>解锁 Jenkins：浏览器中提示输入管理员密码。War 在启动的控制台中会打印密码，或者页面提示的文件中。Docker 方式使用命令，查看容器日志信息即可看到 <code>docker logs jenkins-blueocean</code>。 </p></li><li><p>插件下载镜像设置：为了部署和运行项目，需要安装一些插件。首先需要给插件站点设置一个镜像，不然访问速度感人。配置路径 “Manager Jenkins -&gt; Manager Plugins -&gt; Advanced”，在底部的 <code>Update Site</code> 中把地址进行替换。这里提供一个国内可访问的镜像地址：<a href="https://updates.jenkins-zh.cn/update-center.json%E3%80%82">https://updates.jenkins-zh.cn/update-center.json。</a></p></li><li><p>设置好插件镜像源之后，去搜索对应的插件，下载安装即可。 </p></li><li><p>下载并安装插件：由于项目是用 Git 来管理的，并且使用的是 Maven，因此需要下载这两个插件。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建 Job 之前，需要先了解一个 Job 任务涉及到哪些流程。Jenkins 给我们提供了以下几个模块：</p><ul><li><p><code>General</code> Job 描述，可选。 </p></li><li><p><code>Source Code Management</code> 源代码管理，有多个版本工具选择：Git、Svn 等。 </p></li><li><p><code>Build Triggers</code> 构建触发器，选择构建代码的时机 </p><ul><li>Trigger builds remotely，手动去触发。</li><li>Build after other project are built，在其他项目构建完成后触发。</li><li>Build periodically，周期的进行构建</li><li>GitHub Hooks，当有代码更新到 GitHub，GitHub 会触发一个 Hooks，并通知 Jenkins 服务开始构建，这个需要在 GitHub 中配置推送地址信息。</li><li>Poll SCM 定时任务轮询，填写 Cron 表达式指定轮询的时机。例如：每 10 分钟去检查 GitHub 仓库是否有代码更新。</li></ul></li><li><p><code>Build Environment</code>构建环境，配置项目构建的环境，可以在构建的时候传递环境变量信息。 </p></li><li><p><code>Build</code> 可以选择构建所需步骤。 </p></li><li><p><code>Post-build Actions</code>可以指定项目完成构建之后的行为。</p></li></ul><h2 id="手动创建-Job"><a href="#手动创建-Job" class="headerlink" title="手动创建 Job"></a>手动创建 Job</h2><p>在 Jenkins 中添加两个任务，一个用于拉取代码运行测试、打包任务，另一个可以手动选择版本的部署任务。</p><h3 id="创建测试打包任务"><a href="#创建测试打包任务" class="headerlink" title="创建测试打包任务"></a>创建测试打包任务</h3><ol><li>填写创建的 Job 信息</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/24e982a6-9b83-4233-99f0-15c083663bb5.png" alt="image.png"></p><ol start="2"><li>选择 Git 作为代码管理工具，配置对应的仓库地址。如果是私密仓库，需要填写对应的账号密码。这里使用了 ssh 方式，并提前配置好了私钥信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/0c9f33b3-b50e-45dd-b984-8fdd5c4a1ea9.png" alt="image.png"></p><ol start="3"><li>选择一个构建方式，这里我们选择 SCM，填写一个每 10 分钟轮询一次的 corn 表达式。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/415593ca-72bb-4786-a3c5-14271c5d15ac.png" alt="image.png"></p><ol start="4"><li>构建的时候选择 <code>Execute shell</code> 并在文本框中填写要执行的脚本信息，这里我们填写 <code>mvn clean package</code>，该命令会执行清理、测试、打包操作，在 target 目录下生成 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3fea80cf-d62d-4d27-a028-4bae6b70c59a.png" alt="image.png"></p><ol start="5"><li>保存任务，回到页面。等待 10 分钟或者手动点击立即构建，即可开始构建。 控制台最终打印了文件夹下所有项目版本信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b452178d-9bdd-4873-98f7-663fd62ef8bf.png" alt="image.png"></p><h3 id="创建部署任务"><a href="#创建部署任务" class="headerlink" title="创建部署任务"></a>创建部署任务</h3><ol><li>创建 deploy 任务，在页面中填写描述，并勾选 <code>This project is parameterized</code>，选择 String 参数，这里定义一个变量 version。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f0e1221-1b21-4ac1-a991-19753f4085ca.png" alt="image.png"></p><ol start="2"><li>由于部署任务和打包任务是分开，此处无需在使用 Git 去拉取代码，也无需定义构建触发器，直接手动构建即可。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/8489f466-cf27-4f07-b07a-304f8b42769b.png" alt="image.png"></p><ol start="3"><li>build 环节还是去执行一个 shell，这里我们配置一个 java 程序启动命令 <code>java -Dserver.port=5000 -jar  /c/Users/Administrator/Desktop/jenkins/$&#123;version&#125;.jar</code>指定 5000 端口，并且根据输入的版本号，去执行对应的 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f823c65-51d5-4936-b226-d635fc86e3c3.png" alt="image.png"></p><ol start="4"><li>根据上个任务构建的输出，我们执行部署任务的构建。Jenkins 会弹出提示，此时输入对应的项目版本号，点击开始构建，等待构建完成项目就启动成功了。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b651a7f8-0267-42c9-861b-4ea128b5f596.png" alt="image.png"></p><h2 id="使用-Jenkinsfile-创建-Job"><a href="#使用-Jenkinsfile-创建-Job" class="headerlink" title="使用 Jenkinsfile 创建 Job"></a>使用 Jenkinsfile 创建 Job</h2><p>图形化页面创建一个 Job 很方便，但是当 Jenkins 需要为多个项目创建 Job 时，一个一个手动创建就会很繁琐，并且 Job 信息也没办法进行版本管理。</p><p>Jenkinsfile 就是来解决这个问题的，他将 Job 的配置信息用脚本语言来表示，这样只需要维护这个脚本即可。Jenkinsfile 就像是一份说明书，指导 Jenkins 的工作，让他自动帮我们完成配置。编写 Jenkinsfile 的脚本语言是 Groovy，推荐学习。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>整个流程如图：<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/70124ec6-6334-457c-9f47-4341127d490c.png" alt="image.png"></p><p><strong>创建流程</strong>：</p><ul><li><p>为项目编写 Dockerfile。</p></li><li><p>创建 Jenkinsfile。</p></li><li><p>使用 pipleline 语法编写脚本：使用 Dockerfile 文件 build 一个镜像，并上传到 Docker 私服。</p></li><li><p>使用一个新的 Job，用来获取 Docker 私服所有项目版本信息，支持选择对应版本部署。</p></li></ul><h3 id="为项目编写-Dockerfile"><a href="#为项目编写-Dockerfile" class="headerlink" title="为项目编写 Dockerfile"></a>为项目编写 Dockerfile</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">FROM <span class="hljs-attr">java:</span>openjdk<span class="hljs-number">-8</span>u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target<span class="hljs-regexp">/oh-my-jenkins-0.0.1-SNAPSHOT.jar /</span>app<br><br>EXPOSE <span class="hljs-number">8080</span><br><br>CMD [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;oh-my-jenkins-0.0.1-SNAPSHOT.jar&quot;</span> ]<br></code></pre></td></tr></table></figure><h3 id="在-master-分支创建-Jenkinsfile-并编写对应的脚本"><a href="#在-master-分支创建-Jenkinsfile-并编写对应的脚本" class="headerlink" title="在 master 分支创建 Jenkinsfile 并编写对应的脚本"></a>在 master 分支创建 Jenkinsfile 并编写对应的脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>     agent any<br>     triggers &#123;<br>          pollSCM(<span class="hljs-string">&#x27;* * * * *&#x27;</span>)<br>     &#125;<br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            agent &#123; docker &#123;<br>                image <span class="hljs-string">&quot;circleci/openjdk:8u212-jdk-stretch&quot;</span><br>                args <span class="hljs-string">&#x27;-v /usr/local/docker-cache:/root/.m2&#x27;</span><br>                            &#125;<br>                 &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&#x27;mvn clean package&#x27;</span><br>                stash <span class="hljs-attr">includes:</span> <span class="hljs-string">&#x27;**/target/*.jar&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;app&#x27;</span><br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Docker Build&#x27;</span>) &#123;<br>           steps &#123;<br>               echo <span class="hljs-string">&#x27;Starting to build docker image&#x27;</span><br><br>                unstash <span class="hljs-string">&#x27;app&#x27;</span><br>                script &#123;<br>                    <span class="hljs-keyword">def</span> customImage = docker.build(<span class="hljs-string">&quot;172.29.145.109:5000/on-my-jenkins:$&#123;new Date().format(&#x27;yyyy-MM-dd-HH-mm-ss&#x27;)&#125;&quot;</span>)<br>                    customImage.push()<br>                &#125;<br>           &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本定义了轮询任务，在 docker 中使用 java 环境运行 <code>mvn clean package</code>打包，并把它暂存。之后使用一个 docker build 构建镜像并推送到 docker 私服。由于私服地址和 Jenkins 都在同一个服务器，因此直接使用内网 ip。</p><h3 id="在-deploy-分支创建-Jenkinsfile-并编写部署脚本"><a href="#在-deploy-分支创建-Jenkinsfile-并编写部署脚本" class="headerlink" title="在 deploy 分支创建 Jenkinsfile  并编写部署脚本"></a>在 deploy 分支创建 Jenkinsfile  并编写部署脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> responseJson = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://172.29.145.109:5000/v2/oh-my-jenkins/tags/list&quot;</span>)<br>        .getText(<span class="hljs-attr">requestProperties:</span> [<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&quot;application/json&quot;</span>]);<br><br>println(responseJson)<br><br>Map response = <span class="hljs-keyword">new</span> groovy.json.JsonSlurperClassic().parseText(responseJson) <span class="hljs-keyword">as</span> Map;<br><br><span class="hljs-keyword">def</span> versionsStr = response.tags.join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>pipeline &#123;<br>     agent any<br><br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            input &#123;<br>                message <span class="hljs-string">&quot;Choose a version&quot;</span><br>                ok <span class="hljs-string">&quot;Deploy&quot;</span><br>                parameters &#123;<br>                    choice(<span class="hljs-attr">choices:</span> versionsStr, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;version&#x27;</span>)<br>                &#125;<br>            &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker rm -f oh-my-jenkins&#x27; || true&quot;</span><br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker run --name oh-my-jenkins -p 8081:8080 -d 172.29.145.109:5000/oh-my-jenkins:$&#123;version&#125;&#x27;&quot;</span><br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本获取 Docker 私服的<code>oh-my-jenkins</code>镜像，部署我们选择的版本。</p><h3 id="在-Jenkins-创建多分支流水线任务"><a href="#在-Jenkins-创建多分支流水线任务" class="headerlink" title="在 Jenkins 创建多分支流水线任务"></a>在 Jenkins 创建多分支流水线任务</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b439354a-e1a4-47f4-9bf4-06975e7d8c98.png" alt="image.png"></p><p>然后只需要配置仓库地址就好了，由于 GitHub 抽风，所以使用 Gitee 仓库地址。<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/4047e5a2-911f-4a91-9380-55c45988a209.png" alt="image.png"><br>创建完流水线任务，他会自动扫描仓库上的所有分支，并读取 Jenkinsfile 文件，执行命令。</p><h3 id="选择版本部署"><a href="#选择版本部署" class="headerlink" title="选择版本部署"></a>选择版本部署</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3368c931-7653-4f8a-bc9e-df43d04ee7fc.png" alt="image.png"><br>当流水线分支创建完成之后，deploy 分支会等待我们选择版本，选择需要部署的版本，deploy 即可完成部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基本结构</title>
    <link href="/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>谈起 JVM 第一印象就是「八股」，毕竟正经人谁学 JVM 啊。当我深入学习，了解了相关原理后，真令人大呼过瘾。</p><p>了解 JVM 并不会让你更快的 CRUD，对大部分工作没有实质性的帮助，但这是成为高级程序员的第一步。</p><h2 id="JVM-初识"><a href="#JVM-初识" class="headerlink" title="JVM 初识"></a>JVM 初识</h2><p>JVM 全称是 <strong>Java virtual machine</strong> 即 Java 虚拟机。JVM 是抽象（虚拟）计算机，它定义了一系列规范，因此他有很多实现，如：HotSpot，Eclipse OpenJ9 等等，最常使用的应该就是 Oracle 的 HotSpot。</p><p>JVM 存在的意义就是抹平所有平台和操作系统的鸿沟。它就像是一个在不同平台提供的翻译官，当用英语和它对话时，他翻译成自己「国家」的语言并执行。这就是为什么在 Windows 下编写好的代码能够在 Linux 等其他系统运行的原因。</p><p>代码编译执行过程如图<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/4ff19c89-d87f-4273-bfe4-3c47e3a8f1ad.png" alt="jvm_1.png"><br>程序员使用像 Java，Kotlin，Scala ，Groovy 等高级语言进行编码，编译成 JVM 能识别的语言。JVM 识别并进行「二次编译操作」，将它翻译成对应的平台语言。</p><p>日常编码所做的仅仅只是用高级语言编写一份「说明书」，说明书如何编译成中间语言，这就是高级语言编译器做的事了，当然也可以自己去实现一个编译器，嗯。。至少我目前没有这个能力。</p><p><strong>JLS</strong></p><p>Java 语言规范 Java Language Specification， 定义了 Java 编程的语法。比如 Java 中的关键字信息 class、public 等等，都是在 JLS 规范下，完成 Java 代码的开发。</p><p><strong>JVMS</strong></p><p>Java 虚拟机规范 Java Virtual Machine Specifiction，定义了字节码如何在 JVM 中执行，仅此而已。</p><h2 id="JVM-堆-Heap"><a href="#JVM-堆-Heap" class="headerlink" title="JVM 堆 (Heap)"></a>JVM 堆 (Heap)</h2><p>堆是 JVM 中非常重要的区域，所有的「对象」都在堆上分配，它是个无情的对象生产机器，只负责生产，不负责销毁。</p><p>堆为我们创建了对象，但是在代码中操作与访问对象实际上都是在操作对象的地址或者引用。</p><p>来看个非常简单的代码，以此来演示堆中发生了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1540f816-9a4c-4b1f-af66-0a4c6b917b3c.png" alt="jvm_heap.png"><br>首先堆内存中创建了一个对象（假设对象地址为 100），然后将该对象的地址赋值给 obj 变量，可以想象有一条线将 obj 和 对象 100 连接起来。</p><p>接着，堆内存中又创建了一个变量 101，然后将该对象地址赋值给 obj，此时 obj 和对象 101 连接起来了。这就是堆所做的一切。</p><p>很显然，上面的例子对象 100 还是存在堆中，他并没有消失，他还在等有缘人「联系」它。</p><p>这样就会存在一个问题，「无人问津」的对象越来越多怎么办？这就涉及到 GC 了，GC 会根据相应的算法来判断对象是否需要回收销毁，因此暂时不需要操心，后续提供 GC 的讲解。</p><p>当然堆中产生的对象太多，大量占用堆内存，导致内存溢出，常见表现为 OOM (Out Of Memory) 异常。当代码出现该异常时，就应该关心，代码是否产生了大量不必要的对象，谨慎的检查代码。</p><h2 id="JVM-栈（Stack）"><a href="#JVM-栈（Stack）" class="headerlink" title="JVM 栈（Stack）"></a>JVM 栈（Stack）</h2><p>当我们用 IDEA Debug 如下代码，可以看到在 IDEA 界面底部，多了一些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    a();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am a&quot;</span>);<br>    b();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我的调试器中表现形式如下：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/9c51eaa9-3ce2-4d47-9a40-b38be9fba7aa.png" alt="method_stack.PNG"></p><p>从 main 方法到 b 方法，中间一系列调用都称作<strong>「栈」</strong>或<strong>「方法栈」</strong>，其中每一次方法调用称作<strong>「栈帧」</strong>，如图中的 main，a，b。</p><p>不知你是否思考过，为什么代码的调用形式会是这样？无论你是否好奇过，现在我来分析下代码执行的过程。</p><p>我们都知道，Java  程序的入口都是 main 方法开始的，因此当代码被执行时，会先调用 <strong>main</strong> 方法。不过，在调用 main 方法之前，JVM 创建一个方法栈，用来保存「当前线程」方法调用过程（因此方法栈是线程私有的）。于是方法栈中会放入第一个栈帧 main，由于栈结构的特性，main 自然而然的就会在栈底。</p><p>接着执行 main 方法，执行到最后需要调用 <strong>a</strong> 方法，因此将栈帧 a 放入方法栈中。接着 a 中又调用 b 方法，以此类推。现在，方法栈中已经有 3 个栈帧了，方法调用已经结束了。于是从栈顶开始，将方法的执行结果依次返回，b 方法中无返回值，因此执行完打印语句，b 栈帧就销毁了。以此类推到 a 方法，最后到 main，这就是上述代码玩完整的执行过程，流程如图：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/41370100-58dc-4f78-bdde-b88dd7483c77.png" alt="method_stack_invoke.png"></p><p>了解了方法调用的基本流程，这里有几个疑问：</p><p><strong>Q：当方法栈满了会发生什么？</strong></p><p>A：当栈深度过⼤时抛出 StackOverflowError，著名的程序员交流网站就是以此命名的 <a href="https://stackoverflow.com/">stackoverflow</a></p><p><strong>Q：栈帧销毁什么时候被销毁？</strong></p><p><strong>A</strong>：这些情况栈帧会被销毁：当方法执行抛出异常或者错误；方法正常返回结果或者无返回。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>来看一段简单的代码， a 方法定义了一个变量，并且调用了 b 方法使得该变量自增，然后打印该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    b(i);<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    i++;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中打印的结果为 0，按照正常的思维去理解的话，i 的值因该为 1 才对，这是为什么？</p><p>这是因为这些变量在方法中都是<strong>「值传递」</strong>的，当把 i 传递给 b 方法时，发生了一次拷贝，因此 b 方法中操作的 i，实际上只存在 b 方法中，并不会影响到 a 方法中的 i 变量。</p><p>上面说的是基本类型变量传递，接下来用引用数据类型来进行参数传递，看看发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    b(obj);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(Object obj)</span>&#123;<br>    obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中初始化了一个变量 obj，并把它当作参数传递给 b 方法，b 方法中创建一个新的对象，并把该对象地址赋值给参数 obj。整个过程就是这样，此时 a 中的 obj 对象和 b 中的 obj 是什么关系？他们是同一个对象吗？b 中的对象改变了，会影响到 a 吗？</p><p>有过编程经验的应该都知道，答案是否定的。<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/42e48b45-6083-49b6-ae87-95fe66c76114.png" alt="stack_argument.png"><br>如图所示，a 中 obj 变量指向 Object 10087，把 obj 当作参数给 b 方法时，他会直接复制 obj 所指向的对象地址，即 b 方法刚开始也指向 10087 对象。之后创建了一个新对象地址为 10086，并把地址重新赋值给了 obj，因此 b 中的 obj 指向的是 10086，而 a 指向的是 10087，两者操作的都不是同一个对象，因此也不会相互影响。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>现在已经对 JVM 中的堆和栈有所了解，但是对于方法栈中的每个栈帧还不了解，目前只是知道方法调用就入栈，结束就出栈。因此，现在将栈帧放大来看，看看代码执行过程中，栈帧发生了什么。</p><p>每个栈帧中都有一个「操作数栈」和「局部变量表」。</p><p>每当方法调用开始的时候，局部变量表会被初始化成当前方法的参数。操作数栈上会根据代码实际情况，加载局部变量表中的数据，或者直接加载常量，根据<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">字节码指令集</a>，完成相应的数据操作。</p><p>这就像是人在吃饭一样，用筷子在碟子（局部变量表）中夹菜，夹到碗中（操作数栈），然后根据自己喜好（代码）吃自己的菜。</p><h2 id="JVM-方法区"><a href="#JVM-方法区" class="headerlink" title="JVM 方法区"></a>JVM 方法区</h2><p>方法区中包含了整个虚拟机所共享的 Class 信息，JVM 就是根据方法区中 Class 这份说明书，来帮我们生成对象的。</p><p>方法区中存的所有信息都是共享，基本都是只读的，但这并不是一定的。<strong>「运行时常量池」</strong>就是个例外，在程序运行时往往会往常量池中放入常量信息。</p><p>运行时常量池会保存经常使用的常量，例如 String 字符串常量，当重复 new 一个相同字符串对象时，新的对象就会指向字符串常量池中的字符串常量，这样就节省了内存开销。同时在 String api 中，由于常量的重复使用，可以使得它的 equals 方法可以更快速地进行判断。</p><p><strong>永久代和元空间</strong></p><p>JVM 方法区是一块所有的线程共享的区域，是 JVM 所定义的规范。</p><p>Java 7 之前发方法区的实现称作<strong>「永久代」</strong>，即 <strong>PermGen</strong>。Java 8 之后的称作<strong>「元空间」</strong>，即 <strong>Metaspace</strong>。</p><p>在 Java 7 中，方法区和堆是使用一块连续的物理内存，仅仅是在逻辑上分开的。如果没有设置方法区的大小的话，使用默认大小很容易遇到 OOM 错误。</p><p>在 Java 8 之后，把方法区和堆区分开来，使用了本地内存（Native memory），大小取决于本地内存大小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2022/01/03/Stream/"/>
    <url>/2022/01/03/Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Stream-流"><a href="#什么是-Stream-流" class="headerlink" title="什么是 Stream 流"></a>什么是 Stream 流</h2><p>流就相当于工厂的流水线工作，传送带上是一件件产品，而传送带周围是一些工人。有的负责把挑出次品，把它放到其他另一条流水线中重新加工，有的负责根据产品颜色进行收集，等等。如下图所示。<br><img src="/../picture/Stream/446cbca4-82a6-49e7-8ceb-1ceadcbcc8a9.png" alt="image-20210424211146663.png"></p><p>三个员工对传送带上的产品进行操作，老王负责收集把黄色产品挑出，老周负责把产品按先后排序，而老赵负责把残次品挑拣出来，拆开零件放到新的床送带中，继续加工。传送带的终点就是篮子，产品都流向篮子里面。</p><p>流的操作就是如此。在没有流之前，我们要自己从一堆产品中找到残次品很难。但是我们有了流之后，我们有了流水线，有了工人，我们就可以让工人帮我们收集，让他们来处理，我们只是充当老板的角色，下达命令即可。在 Java 的流 (Stream) 中，我们只需要使用一些命令，剩下的交给程序本身去执行。这样做既减少了代码量，又能高效完成我们的需求，真是两全其美。</p><p>在上面的过程中，我们把老王和老周，以及老赵操作叫做<strong>中间操作</strong>。因为他们并没有把产品收集起来，他们只是把其他不合格的产品过滤挑出，产品最终都是到篮子里面。但是你装产品不一定是用篮子，你也可以使用箱子，等其他容器。我们把使用这些<code>容器</code>装产品的操作称作<strong>终结操作</strong>。在 java 中，<strong>中间操作就是返回为 Stream 的操作，终结操作就是返回非Stream 的操作。</strong>下面会详细讲解。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>**创建 Stream **</p><ul><li>Collection.stream()</li><li>Stream.of()</li><li>String.chars()</li><li>IntStream.range() 等</li></ul><p><strong>Stream 中间操作</strong></p><ul><li>filter 按照输入的条件，过滤流中的元素</li><li>map</li><li>sorted 对流中的元素排序</li></ul><p><strong>Stream 终结操作</strong></p><ul><li>forEach 遍历流中的元素</li><li>count &#x2F; max &#x2F; min 统计元素个数 、最大元素、最小元素</li><li>findFirst &#x2F; findAny 找到第一个元素、随机找一个元素</li><li>anyMatch &#x2F; noneMatch 是否有匹配的元素、没有匹配的元素</li><li><strong>collect</strong> 等</li></ul><p>从方法名中我们就能了解它的用处，更为详细的 API 操作可以查看 Stream 源代码。</p><h2 id="Collector-操作"><a href="#Collector-操作" class="headerlink" title="Collector 操作"></a>Collector 操作</h2><p>Collector 操作是 Stream 中最强大的操作，他就是我们上面例子中提到的「篮子」「箱子」等。它具有以下 API</p><ul><li>toSet &#x2F; toList &#x2F; toCollection</li><li>joining()</li><li>toMap()</li><li>groupingBy()</li></ul><p>通过这些 API 操作，使得我们能将流中的元素收集起来</p><p>下面通过一些实际案例，加深对 Stream 的理解。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        User(String name, <span class="hljs-type">int</span> age) &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有个需求<strong>筛选出年龄大于等于60的用户，然后将他们按照年龄从大到小排序，将他们的名字放在一个LinkedList中返回</strong>。我们可以使用 Stream 写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LinkedList&lt;String&gt; <span class="hljs-title function_">collectNames</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>       <span class="hljs-keyword">return</span> users.stream()<br>               .filter(user -&gt; user.age &gt;= <span class="hljs-number">60</span>)<br>               .sorted(comparing(User::getAge).reversed())<br>               .map(user -&gt; user.name)<br>               .collect(toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><p>解析：要使用 Stream 首先就需要创建它<code>users.stream()</code>，根据要求筛选出年龄大于 60 的用户 <code>filter(user -&gt; user.age &gt;= 60)</code>，然后使用 sorted 对筛选后的用户按照年龄排序。由于我们要返回的是一个字符串列表<code>LinkedList&lt;String&gt;</code>，而我们 Stream 中的元素都是对象类型，因此我们使用 <code>map(user -&gt; user.name)</code>，把User 映射成 String 类型，这样 Stream 中的元素都是用户的名字了。最后，使用 collect 操作将用户的名字收集成一个 Linked ，这样就解决了我们的需求。</p><p>通俗解释：我们作为老板，我们要创建一条流水线，然后安排工人在流水线旁边进行操作。安排员工老赵把用了60年以上的产品，筛选出来。筛选完后，安排老周按使用时长进行从大到小排序。排序之后，安排老王把可用的零件拆下来，最后用一个篮子收集这些可用的零件。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>统计一个给定的字符串中，大写英文字母（A,B,C,…,Z）出现的次数</strong>。例如，给定字符串”AaBbCc1234ABC”，返回6，因为该字符串中出现了6次大写英文字母 ABCABC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUpperCaseLetters</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) str.chars()<br>            .filter(Character::isUpperCase)<br>            .count();<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：String 类型创建流 <code>str.chars()</code>，然后使用 filter 进行过滤操作，过滤出大写字母 <code>filter(Character::isUpperCase)</code>，接着对过滤出的字母进行统计，完成需求。</p><p>更多关于 Stream 操作 demo点击<a href="https://github.com/greek-zzf/my-demo/tree/main/example/Stream%20%E7%BB%83%E4%B9%A0">这里</a></p><h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>可以通过并发提高<strong>互相独立操作</strong>的性能。</p><p><strong>互相独立操作</strong>指的就是，操作相互之间不影响。例：1个人割麦子需要10天，那10个人割相同面积的麦子就只需要1天。</p><p><strong>非互相独立操作</strong>就像女人生孩子，1个女人十10个月生1个孩子，但是10个女人并不是一个月就能把孩子生出来。</p><p>在正确使用的前提下，可以获得近似线性的性能提升。要使用并发流我们可以使用 <code>parallelStream()</code>创建并发流。或者在原有流的基础上，使用 <code>parallel()</code> 方法将流转化为并发流。</p><p>使用一个简单的案例来使用并发流，统计 1 到 100万之间的质数个数 。原始的 Stream 写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).filter(是否为质数).count()<br></code></pre></td></tr></table></figure><p>并发流写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).parallel().filter(isPrime).count();<br></code></pre></td></tr></table></figure><p>因为统计个数属于互相独立操作，就像两个人数羊群有多少只绵羊一样，两人分别数自己区域的羊，然后再加起来汇总。</p><p>对于并发流来说，使⽤要⼩⼼，性能要测试，如果你不知道⾃⼰在做什 么，就忘了它吧。对于详细的操作可以参考<a href="https://book.douban.com/subject/30412517/">《Effective Java 第三版》</a>42-48节。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-年终总结（技术向）</title>
    <link href="/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/"/>
    <url>/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。</p><h3 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h3><ul><li>Maven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。</li><li>学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。</li><li>了解 Jenkis 自动化部署的流程，能够进行简单的构建。</li><li>学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。</li><li>编写了自己的自动化脚本，自动拉取代码打包，运行项目。</li><li>会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。</li><li>学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）</li><li>深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。</li><li>了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。</li><li>熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。</li><li>写了一个简单的新浪新闻爬虫。</li><li>GitHub 也开始有绿点了，尽管不多，但也是个很好的开始。</li></ul><p><img src="/../picture/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/a2f75394-0052-49aa-8e37-a56774bf8a47.png" alt="image.png"></p><ul><li>帮助开源项目 <a href="https://github.com/ByteLegend/ByteLegend">https://github.com/ByteLegend/ByteLegend</a>，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。</li><li>了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。</li></ul><h3 id="知识获取渠道推荐："><a href="#知识获取渠道推荐：" class="headerlink" title="知识获取渠道推荐："></a>知识获取渠道推荐：</h3><ul><li>正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 <a href="https://fsou.cc/">https://fsou.cc/</a>，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。</li><li>取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。</li><li>论坛：<ul><li><a href="https://v2ex.com/">V站</a> 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。</li><li>HackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。</li><li>GitHub 全球最大的同性交友平台（手动滑稽）</li><li>CoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。</li><li>[<a href="https://nipafx.dev/]">https://nipafx.dev/]</a>(You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。</li></ul></li><li>许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。</li><li>了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是<strong>无所不知</strong>)、陈皓（Collshell 作者）</li></ul><h3 id="2022-的一些目标"><a href="#2022-的一些目标" class="headerlink" title="2022 的一些目标"></a>2022 的一些目标</h3><ul><li>工作顺利、生活愉快。</li><li>去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》</li><li>参与到更多开源项目中去、GitHub 绿点也可以多一些。</li><li>保持自己的好奇心、做自己想做的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？</p></blockquote><p>我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。</p><p>上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。</p><p>对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></blockquote><p>简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。</p><p><strong>二进制向量</strong>就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。</p><p>下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/54a416e0-66c1-4893-aade-ede8e001bd04.png" alt="1.png"></p><p><strong>映射函数</strong>我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。</p><p>布隆过滤器对一个 key 使用多个映射函数，得到多个值。</p><p>哈希函数映射</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/63b9a80b-0cd5-48ea-ac54-a93256a7caf7.png" alt="hash.png"></p><p>布隆过滤器中映射函数</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/51445b83-d4a0-497f-8ebb-5f0fb9ddcc76.png" alt="bloomfilter.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解一些基本概念之后，布隆过滤器的原理就很明了了。</p><p>布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。</p><p>例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/ccf230bf-6de4-49ab-8238-c9387cad586d.png" alt="insert.png"></p><p>我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。</p><p>如果是，则该元素<strong>可能</strong>在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。</p><p>如果不是，则表示该元素一定不在集合中。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。</p><h3 id="误识别率"><a href="#误识别率" class="headerlink" title="误识别率"></a>误识别率</h3><p>插入字符串 “zzh” 得到下标 2、7、11</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8b034b8d-b422-4dfc-a270-10c65db5d255.png" alt="insert.png"></p><p>插入字符串 “greek” 得到下标 5、8、9</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4bc4c95c-abee-4c20-9d5e-cf66a4b02cd5.png" alt="insert_greek.png"></p><p>插入字符串 “gem” 得到下标 2、5、8</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/66253d9d-d8ac-4783-9ba3-a3f954bfb9fa.png" alt="insert_gem.png"></p><p>可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。</p><h3 id="删除困难"><a href="#删除困难" class="headerlink" title="删除困难"></a>删除困难</h3><p>删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。</p><p>我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。</p><h3 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h3><p>识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。</p><p>假设在布隆过滤器里面有 <em>k</em> 个映射函数, <em>m</em> 个比特, 以及 <em>n</em> 个已插入元素，那么该过滤器误判率近似于：_(1-e-kn&#x2F;m)k_ 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。</p><p>对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情<a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/#footnote2">点击</a></p><blockquote><p>对于给定的 <em>m</em> 和 <em>n</em> ，有一个函数可以帮我们确定最优的 <em>k</em> 值: <em>(m&#x2F;n)ln(2)</em></p><p>所以可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的_n_, <em>m</em>, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束</li></ol></blockquote><p>事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">wiki</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>查询效率和插入效率高</strong>，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。</p><p><strong>空间效率</strong>。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。</p><p>假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。</p><p>一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 依赖与插件解析机制</title>
    <link href="/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>劝退提醒</strong>：不了解 maven 坐标机制，没有使用过 maven 插件，不了解 maven 插件命令的，可以关闭文章了。</p><p>我们经常在项目中引入包，使用 <code>&lt;dependency&gt;</code> 标签，然后填写包的坐标信息， Maven 就可以帮我们引入该 jar 包。当本地存在该 jar 包时，就从本地引入该 jar 包，否则就从远程仓库引入。</p><p>这背后的解析机制是什么呢？</p><h2 id="依赖解析机制"><a href="#依赖解析机制" class="headerlink" title="依赖解析机制"></a>依赖解析机制</h2><p>依赖解析的背后机制可以概括如下：</p><ol><li><p>依赖范围是 <code>system</code>，maven 就会从本地加载该 jar 包，完成构建。</p></li><li><p>正常解析依赖坐标，先去本地仓库找，找到就完成构建。</p></li><li><p>本地找不到，并且显示的指定了版本信息，就去远程仓库中遍历，找到并下载解析。</p></li><li><p>如果依赖的版本信息并没有指定，而是使用 <code>RELEASE</code>或者 <code>LATEST</code>，他会找到远程仓库的<strong>元数据</strong>和本地的元数据进行合并，然后计算出真正的版本号。元数据指的就是仓库中 <code>groupId/artifactId/maven-metadata.xml</code>文件，例如我们打开 guava 包的元数据。元数据位置就在 com.google.guava&#x2F;guava 包下，打开可以看到如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">metadata</span> <span class="hljs-attr">modelVersion</span>=<span class="hljs-string">&quot;1.1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">versioning</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">latest</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">latest</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">release</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">release</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r03<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r05<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r06<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r07<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r08<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r09<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lastUpdated</span>&gt;</span>20210319161151<span class="hljs-tag">&lt;/<span class="hljs-name">lastUpdated</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">versioning</span>&gt;</span><br>&lt;/metadata<br></code></pre></td></tr></table></figure><p> 上面的信息展示了 latest，release 对应的版本号，以及 guava 包的历代版本号，以及最近一次更新时间。例如我们引入 guava，并使用 latest 版本，maven 就会合并元数据，然后计算出 latest 对应的版本号，然后从本地仓库找到改版本的 guava，没有则去远程仓库下载。</p></li><li><p>依赖的版本是 SNAPSHOT，则同样获取远程元数据与本地合并，计算版本信息，获取对应版本的包。</p></li><li><p>如果依赖版本为时间戳的快照版本，就会先转换成非时间戳的快照版本，然后去解析下载。</p></li><li><p>maven 3 中如果不指定 version，则默认解析使用 RELEASE 版本。</p></li></ol><h2 id="插件解析机制"><a href="#插件解析机制" class="headerlink" title="插件解析机制"></a>插件解析机制</h2><p>我们常用的 maven 插件命令都是 <code>mvn dependency:tree</code> <code>mvn flyway:migrate</code>，诸如此类的，他们的格式都是 <code>mvn 插件前缀:目标</code>。</p><p>为了方便用户使用和配置插件，maven 不需要用户提供完整的坐标信息，就能解析得到正确的插件。那么问题来了，maven 是怎么确定插件的坐标和版本的呢？例如 <code>mvn dependency:tree</code> 他执行了什么插件，插件坐标版本信息是什么？</p><p>插件的解析机制和依赖解析机制基本一致，不同的是远程仓库不一样。配置插件的远程仓库地址需要使用 <code>&lt;pluginRepository&gt;</code> 标签配置，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了 <code>&lt;pluginRepositories&gt;</code>和 <code>&lt;pluginRepository&gt;</code>不同，其他的与依赖的仓库配置信息一致。</p><h3 id="默认的-groupId"><a href="#默认的-groupId" class="headerlink" title="默认的 groupId"></a>默认的 groupId</h3><p>在 pom 文件在红配置插件信息的时候，如果插件是 maven 官方的插件（groupId 为 org.apache.maven.plugins），就可以省略 groupId 的配置。如下是官方的 clean 插件配置，没有指定 groupId，但是解析坐标的时候会带上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在插件配置中，不推荐省略 groupId 的写法，但这与我们使用 maven 插件命令有关。</p><h3 id="省略版本信息"><a href="#省略版本信息" class="headerlink" title="省略版本信息"></a>省略版本信息</h3><p>maven 的核心插件都在超级 pom 中显示的声明了具体的版本信息，因此当这些插件未指定版本信息的时候，就会使用超级 pom 中指定的插件版本。</p><p>如果是非核心插件，且未指定版本信息。在 maven2 中默认解析至 latest，maven3 默认解析至 release，具体的解析过程与依赖解析一致，都是根据合并计算元数据，得到具体的版本信息。</p><h3 id="插件前缀解析"><a href="#插件前缀解析" class="headerlink" title="插件前缀解析"></a>插件前缀解析</h3><p>我们使用命令 <code>mvn dependency:tree</code> 插件前缀是 dependency，我们是如何根据这个前缀信息得到该插件的完整坐标呢？</p><p>这就需要结合上面的知识了，首先存在一个保存 groupId 和 artifactId 对应关系的文件 maven-metadata.xml，该文件存在 groupId &#x2F; maven-metadata.xml。由于上面的 dependency 是官方插件，因此 groupId 为 <code>org.apache.maven.plugins</code> ，我们去远程仓库找到该文件，如下图。</p><p><img src="/../picture/Maven%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/91808d7d-667b-4874-bf53-33765521e002.png" alt="image.png"></p><p>我们可以找到插件前缀 dependency 对应的 articfactId 是 <code>maven-dependency-plugin</code>，因此插件的完整坐标可以确定了。</p><p><strong>获取 groupId</strong></p><p>这里还有个问题，因为我们是提前知道 dependency 是官方的插件，可以推出他的 groupId ，但是 maven 是怎么知道它的 groupId 呢？</p><p>maven 的主要插件都在 <code>[https://repo1.maven.org/maven2/org/apache/maven/plugins](https://repo1.maven.org/maven2/org/apache/maven/plugins)</code>和<code>[https://repository.codehaus.org/org/code-haus/mojo](https://repository.codehaus.org/org/code-haus/mojo)</code>下，他们对应的 groupId 分别是 <code>org.apache.maven.plugins</code> 和 <code>org.codehaus.mojo</code>。maven 解析插件的时候就会默认使用这两个 groupId 去匹配，检查 org&#x2F;apache&#x2F;maven&#x2F;plugins&#x2F;maven-metadata.xml，org&#x2F;codehaus.momjo&#x2F;maven-metadata.xml 文件，判断是否有匹配的插件前缀，如果有则获取对应的坐标信息，完成解析。</p><p>倘若想使用的插件是第三方的，就可以通过配置 setting.xml 文件，让 maven 也检查其他 groupId 上的仓库 metadata.xml 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>第三方仓库 groupId<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><p>解析 dependency:tree 命令</p><ol><li><p>先使用默认的和配置的第三方的  groupId 去找到对应的 <code>maven-metadata.xml</code>文件，然后检查是否包含 dependency 前缀信息。</p></li><li><p>包含前缀信息，获取对应 articfactId，不包含则使用下一个 groupId 的 maven-metadata.xml 文件。如果所有都获取不到，则报错。</p></li><li><p>获取到 articfactId 之后根据上面 <a href="#Ueudm">获取版本信息</a>，即可得到完整的坐标，完成解析执行。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2021/08/11/String/"/>
    <url>/2021/08/11/String/</url>
    
    <content type="html"><![CDATA[<p>首先我们要有一个概念，互联网基本上就只干一件事「处理字符串」。我们看的纷繁复杂的网页，都是通过字节传输的，然后经过一个指定的编码转化成人类能看懂的字符串。因此能处理好字符串是 Web 服务器的基本要求，像 Java，PHP，Python，Ruby等。</p><h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p>背过一些八股文面试题的人都知道 String 是不可变的，那么问题来了，「不可变的定义是什么？」，「String 是如何保证不可变的呢？」</p><p><strong>不可变性</strong>，当创建一个<code>String s = &quot;abcd&quot;</code>对象的时候，JVM 的堆内存就生成了一个 String 对象，并且它的值是 abcd，而 s 变量只是指向这个对象。我们说的不可变性指的就是 JVM 生成的对象值不可变，比如刚才的 abcd，创建出来之后它就一直都是 abcd，无法被改变。</p><p>经常使用字符串的人开始疑惑了，那我 <code>String s = &quot;abcdel&quot;</code>不是也可以吗？String 的值不是改变了吗？</p><p>的确，我们是可以给 s 这个变量重新赋值。但是我们给他赋值实际上是 JVM 新创建了一个值为 abcdel 的 String 变量，然后变量 s 从指向值为 abcd 的对象，改为指向值为 abcdel 的对象。原来值为 123 的对象还是存在 JVM 中，并且值并没有改变，只是暂时没有变量指向这个对象罢了。上面的操作，可以用如图所示。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/picture/String/ea0bb048-f46d-4e83-abb9-de31bd9a694d.png" alt="image.png"></h3><p>了解上面的知识后，回到新的问题上来，<strong>String 是如何保证不可变性呢？</strong></p><p>打开 String 的源代码，我们可以发现，String 类以及它的字符数组变量都是被 final 关键词修饰的。这就意味着 String 无法被继承，并且 char[] value 的地址指向无法修改，而且 String 所有的公开 API 都没有修改 char[] value 的方法，这就保证了 String 的不可变性。</p><p><img src="/picture/String/632458ad-4ea5-42bf-b25a-9c0262d646c4.png" alt="image.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>线程安全</strong>，不可变的对象天生就是线程安全的，可以随心所欲的在线程之间传递。</p><p><strong>存储安全，</strong>为什么说是存储安全呢？因为遵守了 hashCode 的约定。</p><p>正是因为 Stirng 的不可变性，才能实现存储安全。我们可以想象一下有一个 <code>Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</code>，假如 String 是可变的话，那么就违反了 hashCode 的约定，想了解 hashCode 的相关约定<a href="https://www.yuque.com/alipayygdprovgrb/uc535m/mdqx4t">访问这里</a> 。</p><p>如图所示，有三个字符串 “a”，”c”，通过计算分别得到了对应的 hashCode。如果 String 是可变的行不行呢？我们可以通过反证法来证明。现在假如 String 是可变的，那么当字符串从 a 变成了 c（即 <code>String a = &quot;a&quot; 到 a = &quot;c&quot;</code> ），他的 hashCode 要不要改变呢？分两种情况。</p><p><img src="/picture/String/1304755d-ad8a-4838-8262-6e408d0c7787.png" alt="image.png"></p><p>如果<strong>不改变 hashCode</strong>，那就违反了 hashCode  的第二条约定「两个对象 equals 方法为 true，则生成的 hashCode 相等」。显然 <code>a.equals(c)</code> 为true，按照约定 a 和 c 的 hashCode 应该相等。但我们的前提是 a 的 hashCode 不改变，因此 a 和 c 的 hashCode 并不相等，前后矛盾。</p><p>如果<strong>改变 hashCode</strong> ，那么就违反了 hashCode 的第一条约定「两个对象相等，hashCode 也相等」。例如我们通过如下代码让 a 和 c 为同一个对象，此时的 a &#x3D;&#x3D; c。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>如果此时 a 改变了值，hashCode 也会跟着变化。但是 a &#x3D;&#x3D; c 依然为 true，因为他们所引用的内存地址都是相同的。hashCode 规定对象相等返回相同的 hashCode ，而我们的前提是值改变，hashCode 改变，也是前后矛盾。</p><p>通过反证法，证明了 String 必须是不可变的，才能达到存储安全的目的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每当想修改字符串的时候，都必须创建新的对象来维持它的不可变性。比如下面这个循环，循环 10 次，就创建了 10 个对象，当循环次数上升到一定程度，就会给内存管理带来巨大的压力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text + i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当我们想创建值相同的两个 String 对象，有以下三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>我们分别用 &#x3D;&#x3D; 和 equals 方法来判断 a，b是否相等，三种方式输出的结果分别会是什么呢？</p><p>方法一，a，b 的值都是 “123”，因此很简单，<code>a.equals(b)</code>肯定为 true，那么 <code>a == b</code> 呢？答案是 true。因为有「字符串常量池」的存在，当 a 创建出来，字符串常量池创建 “123” 这个字符串常量，当 b 赋值的时候，发现字符串常量池中已经有相同的对象，因此直接让 b 指向这个对象，此时 a 和 b 都指向同一个对象。如图</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/picture/String/990942c9-60db-42ef-99c4-370f76819ce7.png" alt="image.png"></h3><p>方法二，a 和 b 都是通过 new 方法，各自声明了一个值为 “123” 的对象，因此这是两个不同的对象。所以，a &#x3D;&#x3D; b 为 false，a.equals(b) 为 true。此时的 a 和 b 是指向不同的对象的，虽然他们的值都是 123。</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/picture/String/d40d7eb9-b7c9-4f13-8720-de56aa0a2859.png" alt="image.png"></h3><p>方法三，a 赋值 b，把 a 的地址指向给 b一份。因此，a，b 两个变量都是引用同一个对象，因此 a&#x3D;&#x3D;b 为 true，a.equals(b) 也为 true。图中就是 a 指向的内存地址是 0x45，然后通过 <code>String b = a</code> b 得到 a 传来的地址，所以也指向 0x45 这个内存。</p><p><img src="/picture/String/2bb22221-4e5c-47cd-a667-e5f2eeec841e.png" alt="image.png"></p><h3 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h3><p>虽然 String 是不可变的，但是在实际生产中我们还是需要可变字符串，这要怎么解决呢？就拿上面那段循环代码来说，每次都要创建一个新的变量，循环次数多了必然占用过多内存。**StringBuilder **就是个可变字符串，因此我们可以使用 StringBuilder 来改进这段代码，这样就避免了创建多个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text.append(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuffer 也是可变字符串，与 StringBuilder 的区别是：StringBuilder 线程不安全，但是速度快；StringBuffer 线程安全，速度相对较慢。因此，要根据实际生产环境，选择合适的类，大多数情况优先使用 StringBuilder。</p><p>String，StringBuffer 和 StringBuilder 更多 API，请参考 Java 官方文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 前后端基础架构原理</title>
    <link href="/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>当我们打开浏览器去访问一个网站时，发生了什么？在了解整个过程之前，我们应该先了解一些基本概念</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>首先我们需要明确一点的是，当我们访问一个网站的时候，实际上是在与一个主机进行交互。就像去商店购物一样，只要你不差钱，商店有的，它都能提供给你。</p><h3 id="主机（Host）"><a href="#主机（Host）" class="headerlink" title="主机（Host）"></a>主机（Host）</h3><p>主机简单来说就是一台电脑，只不过它的作用更多，可以响应浏览器发送的请求。我们平时所用的电脑也可以充当一台服务器，只不过需要一些专业的操作，才能把它变成主机。</p><p>那么问题来了，世界上有很多台主机，我们在浏览器输入 <a href="http://www.taobao.com/">www.taobao.com</a> 的时候，它是怎么帮我们找到淘宝的主机的？</p><h3 id="IP-与域名"><a href="#IP-与域名" class="headerlink" title="IP 与域名"></a>IP 与域名</h3><p>每个 IP 对应一个主机，因此只要我们知道 IP 地址就可以正确地找到对应的主机了。说到这里可能还有个疑问，我们明明输入的是一个网址，也没有看见 ip 地址啊，他怎么知道我访问的是那一台主机？这个就要说到 DNS 的功劳了。首先用 ip 去找对应的主机是没问题的，我们输入的网址本质上就对应一个 ip，只是我们没有察觉。DNS 就是把输入的网址，找到对应的 ip ，然后返回给我们。这样我们就本能的以为，只要输入网址就能找到对应的网站了，这是 DNS 给我们的错觉。</p><p>DNS 是个网络上的服务，他包含了域名和 ip 地址的映射关系。windows 本机上有个 hosts 文件，可以自己添加和修改网址和 ip 的对应关系，假如我们把 <a href="http://www.taobao.com/">www.taobao.com</a> 对应的 ip 改成 127.0.0.1，这样在浏览器再次输入<a href="http://www.taobao.com/">www.taobao.com</a> 就找不到原本的淘宝网站了，而是映射到本机。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>现在请假设一个场景：你有一台电脑，电脑连了一根网线，同时电脑上开了好几个程序，像 QQ、淘宝、微信。你有没想过，一根网线传的数据，他怎么知道哪个是 QQ 要的数据，哪个是淘宝返回的数据呢？</p><p>区分不同应用的数据，我们就用到了<strong>端口</strong>，不同应用他所对应的端口不一样的。网线中传输的数据，每个数据包都有对应的端口信息，就像一列火车一样，每个人的目的地不一样，有的在广州下车，有的在深圳下车，目的地不一样。数据也是这样，根据端口到达不同的应用中去。</p><p>我们可以经常看到网址前面有 http 或 https，他们都对应着不同的端口号。HTTPS 协议的默认端⼝是443，HTTP协议的默认端口是80。别看我们访问网站的时候没有看到端口号，其实浏览器已经在后面偷偷帮我们补上了。</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>当我们向远程的服务器发起请求时，TCP 协议就开辟了一条双车道的「高速公路」，不过在这条路上跑的是数据。同时数据也是一个一个的字节，所以也叫字节流，<strong>TCP是基于流的协议</strong>。由于是双车道，所以我们可以和服务器同时接受和发送数据，这叫做<strong>全双工协议，</strong>tcp就是全双工协议。半双工协议就是类似生活中的「对讲机」，只有对方说完，我们才能说话。</p><p><strong>TCP 协议本质上就是规定字节流如何发送和接收</strong><br>**</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>Http 是在 TCP 协议之上的一层协议。Http 定义了文本之外的东西如何被传输。我们把发送给服务器的字节流叫做 <strong>HTTP Request</strong>，比如我们访问豆瓣首页。我们就会向服务器发送如下字节流。</p><p><strong><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/a46104e5-ab13-4c06-8d67-fc25533364f0.png" alt="image.png"></strong><br>服务器收到请求之后就会返回一个 <strong>HTTP Response <strong>字节流，除了 Headers 之外，还返回了</strong> HTTP Response Body（响应体）</strong>，response body 可以是文本，也可以是及二进制数据，包括图片、声音、下载的文件等。</p><p><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/d1b5fc66-e420-4974-a253-2d14fc46da93.png" alt="image.png"><br>刚才访问的豆瓣网站，就返回了一个 response body，一个 html 文件。我们得浏览器收到这个 html 文件，就会根据他的结构，标签去解析和展示他。我们看到的页面就是浏览器解析之后的样子。</p><p><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/b594a1c8-ea35-46ee-9093-5ff9fe6ae319.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 包冲突解决过程</title>
    <link href="/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>记录一次 maven 包冲突解决过程，项目地址<a href="https://github.com/hcsp/resolve-package-conflict">链接</a>。</p><h2 id="查看错误方法"><a href="#查看错误方法" class="headerlink" title="查看错误方法"></a>查看错误方法</h2><p>首先要将项目克隆到本地，然后运行，找到出错的位置，以及出错的信息。<br> <img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb20e3c-d218-44f4-a995-61be864a19e4.png" alt="image.png"><br>如图所示，错误的位置在 MainTest.java 文件第六行，错误信息 <code>NoSuchMethod</code> ，表示没有找到这个方法。根据位置提示，一层一层往下找，发现原来是 A.java 这个类中调用的 <code>getJsonpFunction</code> 方法找不到</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb93ac6-bf86-4f27-8f3f-5b0e0f6978ce.png" alt="image.png"></p><h2 id="查看包冲突"><a href="#查看包冲突" class="headerlink" title="查看包冲突"></a>查看包冲突</h2><p>通过使用 maven helper 插件查看包的依赖树。如图所示，spring-web:5.1.8.RELEASE 版本和 spring-web:4.3.6.RELEASE 版本冲突了。图上的 4.3.6 版本为红色，可知，maven 使用的是 5.1.8 版本。我们根据 maven 解决包冲突的就近原则来看，5.1.8 离项目的距离为1，4.3.6 的距离为2，因此保留5.1.8版本，再次证实了这一点。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/bcd7d3b1-5625-4466-9bff-4d7fa1cf4a7c.png" alt="image.png"></p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>既然知道了是 spring-web 这个包的问题。我们就访问 maven 仓库，找到对应的版本，访问他的 github 主页。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/529dcfcc-07f4-4315-b0bc-e1fc3b11c480.png" alt="image.png"><br>找到了 github 仓库，进入报错的那个类，通过切换 tags 来切换不同版本对应的源代码，两者进行比较。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/cb13c43d-19fe-41db-9552-443f008f598a.png" alt="image.png"><br>对比发现在5.1.8版本 org.springframework.http.converter.json.MappingJacksonValue 中不存在 <code>getJsonpFunction</code>  这个方法。而 4.3.6 中却有。因此可以断定，我们项目本该使用 4.3.6 版本，而 maven 帮我们剔除了 4.3.6 版本，保留了 5.1.8 版本，导致找不到 <code>getJsonFunction</code> 而报错。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/a26925af-9758-4767-8e5a-107165edd81b.png" alt="image.png"></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>知道了冲突的原因，我们就只需要把 5.1.8 版本的依赖注释掉就行，这样 maven 就会帮我们加载 4.3.6 版本的包了。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/4efcceb9-a459-4eb2-bda3-58ab8f6dda90.png" alt="image.png"><br>同时也可以将 5.1.8 版本的依赖改成 4.3.6 版本，解决冲突。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
