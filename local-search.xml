<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021-年终总结（技术向）</title>
    <link href="/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/"/>
    <url>/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。</p><h3 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h3><ul><li>Maven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。</li><li>学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。</li><li>了解 Jenkis 自动化部署的流程，能够进行简单的构建。</li><li>学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。</li><li>编写了自己的自动化脚本，自动拉取代码打包，运行项目。</li><li>会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。</li><li>学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）</li><li>深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。</li><li>了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。</li><li>熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。</li><li>写了一个简单的新浪新闻爬虫。</li><li>GitHub 也开始有绿点了，尽管不多，但也是个很好的开始。</li></ul><p><img src="/../picture/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/a2f75394-0052-49aa-8e37-a56774bf8a47.png" alt="image.png"></p><ul><li>帮助开源项目 <a href="https://github.com/ByteLegend/ByteLegend">https://github.com/ByteLegend/ByteLegend</a>，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。</li><li>了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。</li></ul><h3 id="知识获取渠道推荐："><a href="#知识获取渠道推荐：" class="headerlink" title="知识获取渠道推荐："></a>知识获取渠道推荐：</h3><ul><li>正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 <a href="https://fsou.cc/">https://fsou.cc/</a>，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。</li><li>取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。</li><li>论坛：<ul><li><a href="https://v2ex.com/">V站</a> 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。</li><li>HackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。</li><li>GitHub 全球最大的同性交友平台（手动滑稽）</li><li>CoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。</li><li>[<a href="https://nipafx.dev/]">https://nipafx.dev/]</a>(You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。</li></ul></li><li>许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。</li><li>了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是<strong>无所不知</strong>)、陈皓（Collshell 作者）</li></ul><h3 id="2022-的一些目标"><a href="#2022-的一些目标" class="headerlink" title="2022 的一些目标"></a>2022 的一些目标</h3><ul><li>工作顺利、生活愉快。</li><li>去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》</li><li>参与到更多开源项目中去、GitHub 绿点也可以多一些。</li><li>保持自己的好奇心、做自己想做的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？</p></blockquote><p>我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。</p><p>上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。</p><p>对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></blockquote><p>简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。</p><p><strong>二进制向量</strong>就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。</p><p>下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/54a416e0-66c1-4893-aade-ede8e001bd04.png" alt="1.png"></p><p><strong>映射函数</strong>我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。</p><p>布隆过滤器对一个 key 使用多个映射函数，得到多个值。</p><p>哈希函数映射</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/63b9a80b-0cd5-48ea-ac54-a93256a7caf7.png" alt="hash.png"></p><p>布隆过滤器中映射函数</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/51445b83-d4a0-497f-8ebb-5f0fb9ddcc76.png" alt="bloomfilter.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解一些基本概念之后，布隆过滤器的原理就很明了了。</p><p>布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。</p><p>例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/ccf230bf-6de4-49ab-8238-c9387cad586d.png" alt="insert.png"></p><p>我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。</p><p>如果是，则该元素<strong>可能</strong>在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。</p><p>如果不是，则表示该元素一定不在集合中。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。</p><h3 id="误识别率"><a href="#误识别率" class="headerlink" title="误识别率"></a>误识别率</h3><p>插入字符串 “zzh” 得到下标 2、7、11</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8b034b8d-b422-4dfc-a270-10c65db5d255.png" alt="insert.png"></p><p>插入字符串 “greek” 得到下标 5、8、9</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4bc4c95c-abee-4c20-9d5e-cf66a4b02cd5.png" alt="insert_greek.png"></p><p>插入字符串 “gem” 得到下标 2、5、8</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/66253d9d-d8ac-4783-9ba3-a3f954bfb9fa.png" alt="insert_gem.png"></p><p>可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。</p><h3 id="删除困难"><a href="#删除困难" class="headerlink" title="删除困难"></a>删除困难</h3><p>删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。</p><p>我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。</p><h3 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h3><p>识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。</p><p>假设在布隆过滤器里面有 <em>k</em> 个映射函数, <em>m</em> 个比特, 以及 <em>n</em> 个已插入元素，那么该过滤器误判率近似于：_(1-e-kn&#x2F;m)k_ 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。</p><p>对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情<a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/#footnote2">点击</a></p><blockquote><p>对于给定的 <em>m</em> 和 <em>n</em> ，有一个函数可以帮我们确定最优的 <em>k</em> 值: <em>(m&#x2F;n)ln(2)</em></p><p>所以可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的_n_, <em>m</em>, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束</li></ol></blockquote><p>事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">wiki</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>查询效率和插入效率高</strong>，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。</p><p><strong>空间效率</strong>。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。</p><p>假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。</p><p>一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
