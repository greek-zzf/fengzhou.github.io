<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring 与事务</title>
    <link href="/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/10/10/Spring%20%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事务是让人生厌的八股，也是面试中的常客。网路上关于 Spring 与事务的问题非常多，然而大部分解答都是在「 背答案」，并没有把它的底层逻辑讲清楚，只要问题一经变通，也就无从下手不知所措。</p><p>Spring 使用魔法般的注解 <code>@Transactional</code> 帮我们解决事务的使用问题，给我们带来便利的同时，也屏蔽了底层的细节。屏蔽了底层的细节，也就导致事务相关的使用都是靠着积累的经验，而无法真正理解它。</p><p><strong>说明：</strong>本文仅对 Spring 中事务的原理进行说明，MySQL 中的事务实现不在本文阐述。</p><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>事务这个概念有点抽象，可以把它看做由一堆 SQL 语句组成的操作。</p><p>事务可以保证它里面的 SQL 语句要么全部成功，要么全部失败，不存在第三种中间状态。</p><p>事务还有 ACID 四种特性，陈词滥调这里不想过多阐述，可以自行 Google 了解。</p><h2 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h2><p>首先要说明的是，「 事务」更像是一种约定，数据库可以选择遵守或不遵守该约定。即便是在支持事务的数据库中，它们实现事务的方式也各不相同，MySQL 提供对事务的支持，接下来看看在 MySQL 中要如何使用事务。</p><p>在使用事务之前，需要了解事务相关的一些概念。</p><ul><li>事务（transaction）指一组 SQL 语句，对应的是整个转账流程。</li><li>回滚（rollback）指撤销指定的 SQL 语句</li><li>提交（commit）将未存储的 SQL 语句结果写入到数据库</li><li>保留点（savepoint）指事务处理中设置的临时占位符，用于事务回滚到指定的 SQL 语句。</li></ul><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>假设这样一个场景：用户注册一个账号，默认金额是 0 元，之后充值了 100 元，两个操作都在一个事务内。对应的 SQL 语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL 中标识事务开始</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>上诉操作完成了一个事务的提交，倘若要回滚上诉操作只需要将 <code>COMMIT</code> 替换成 <code>ROLLBACK</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>不知道你发现了没有，提交和回滚都是针对一组 SQL 进行的。用户注册账号成功，但是充值失败，能否让「 充值失败」不影响到用户注册。</p><p>答案是肯定的，上面提到的 <code>SAVEPOINT</code> 就是解决该问题的。</p><p><code>SAVEPOINT</code> 就像游戏存档一样，可以在事务的执行过程中建立多个存档，遇到异常可以随时返回到指定的存档。如下面的语句，「 注册」会成功，而「充值」失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">-- 创建名为 `register_user` 的保留点</span><br><span class="hljs-keyword">SAVEPOINT</span> register_user;<br><span class="hljs-keyword">UPDATE</span> zzh <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 回滚到 `register_user` 保留点</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> register_user;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h2 id="传统的-JDBC-管理事务"><a href="#传统的-JDBC-管理事务" class="headerlink" title="传统的 JDBC 管理事务"></a>传统的 JDBC 管理事务</h2><h3 id="提交与回滚操作"><a href="#提交与回滚操作" class="headerlink" title="提交与回滚操作"></a>提交与回滚操作</h3><p>看下这段代码，你是否熟悉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection(); <span class="hljs-comment">// (1)</span><br><br><span class="hljs-keyword">try</span> (connection) &#123;<br>    connection.setAutoCommit(<span class="hljs-literal">false</span>); <span class="hljs-comment">// (2)</span><br>    <span class="hljs-comment">// 执行一些 SQL 代码</span><br>    connection.commit(); <span class="hljs-comment">// (3)</span><br><br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    connection.rollback(); <span class="hljs-comment">// (4)</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取数据库连接，获取的方式有多种，现在大多数都是维护一个数据库连接池，然后从连接池分配一个连接。</li><li>把获取到的数据库连接，关闭自动提交。因为事务要交由代码管理，而不是让数据库默认提交。</li><li>当执行完 SQL 代码之后，开始提交。</li><li>数据库进行 COMMIT 提交出现异常，代码中进行捕获，并执行回滚操作。</li></ol><h3 id="设置隔离级别与保留点（SAVEPOINT）"><a href="#设置隔离级别与保留点（SAVEPOINT）" class="headerlink" title="设置隔离级别与保留点（SAVEPOINT）"></a>设置隔离级别与保留点（SAVEPOINT）</h3><p>在  jdbc 中设置数据库隔离级别和 <code>SAVEPOINT</code> 也是非常简单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">Savepoint</span> <span class="hljs-keyword">savePoint</span> <span class="hljs-operator">=</span> connection.setSavepoint(); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">2</span>)<br><br>connection.rollback(<span class="hljs-keyword">savePoint</span>);  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> (<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><ol><li><code>setTransactionIsolation</code> api 就可以设置数据库的隔离级别</li><li><code>setSavepoint</code> 创建一个 <code>SAVEPOINT</code></li><li><code>rollback</code> 到上一个 <code>SAVEPOINT</code></li></ol><p>可以看到 jdbc 中对数据库事务的操作都是非常简单的，Spring 与 jdbc 实现事务的操作并无太大差别，只是他把这些封装的太好，会让你觉得是魔法，难以理解。</p><h2 id="Spring-的事务魔法"><a href="#Spring-的事务魔法" class="headerlink" title="Spring 的事务魔法"></a>Spring 的事务魔法</h2><h3 id="Transactional-注解"><a href="#Transactional-注解" class="headerlink" title="Transactional 注解"></a>Transactional 注解</h3><p>使用 JDBC 开启事务，需要写大量的 <code>try...catch</code> 。通常 <code>try</code> 代码块执行 SQL 操作，<code>catch</code> 中捕获异常进行回滚。</p><p>来看下 Spring 中为一个方法添加事务有多简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        userDao.save(user);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>加上 <code>@Transactional</code> 注解等价代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            userDao.save(user);<br><br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个操作，相比上面的 JDBC 操作，简便不少。操控事务的样板代码，不用在每个方法中写了，一个注解 Spring 统统搞定。</p><p>因此，Spring 的事务魔法秘密就揭开了。对加了 <code>@Transactional</code>的方法或者类，使用 AOP 的方式，帮你生成数据库的链接，事务开启、提交、回滚代码，仅此而已。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在深入 <code>@Transcational</code> 注解之前，还是要先简单介绍下 AOP 在事务上的实现，这对你理解后面的问题，大有裨益。</p><p>首先要清楚 AOP 在实现事务时，并不会改变原来类的行为，它只是生成了一个代理类。生成代理类的方式有 CGLIB、JDK 动态代理，两种代理方式各不相同，但这里不对代理方式阐述。</p><p>通过一个简单的 Demo 看下这个流程：</p><p>在 <code>UserService</code> 的 <code>registerUser</code> 方法开启事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 注册用户代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 使用 AOP 为 <code>UserService</code> 生成代理类 <code>UserServiceProxy</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-keyword">try</span> (connection) &#123;<br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 调用 UserService 的 registerUser 方法</span><br>            invoke();<br>           <br>            connection.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            connection.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>UserController</code> 中注入 <code>UserService</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/register&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span>&#123;<br>userService.registerUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>/register</code> 请求的流程如下：</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/01acb810-c014-487d-9a72-7a6111fd0920.png" alt="aop.png"></p><p>可以看到，<code>Controller</code>  实际上是调用 <code>UserServiceProxy</code> 的 <code>registerUser</code> 方法，然后在代理方法中操控事务，并调用真正的 <code>UserService</code> 的 <code>registerUser</code>。</p><p>或许你还有个疑问：注入的是 <code>UserService</code> ，为什么调用的却是它的代理类？</p><p>这就涉及 Spring  的依赖注入原理，详细可以自行搜索。实际上在 <code>UserController</code> 中注入的是 <code>UserServiceProxy</code> ，而非看到的 <code>UserService</code>。</p><h3 id="一些疑难杂症"><a href="#一些疑难杂症" class="headerlink" title="一些疑难杂症"></a>一些疑难杂症</h3><p>列举一些关于 Spring 事务的疑难杂症，也是面试的常考题。</p><h4 id="为什么-private-方法加-Transactional-注解不生效"><a href="#为什么-private-方法加-Transactional-注解不生效" class="headerlink" title="为什么 private 方法加 @Transactional 注解不生效?"></a>为什么 <code>private</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>这个问题其实是和 AOP 相关的，因为 AOP 无法对 <code>private</code> 方法生成代理。无法代理也就意味着对 <code>priavte</code> 方法的调用，都是直接调用被代理的类。</p><h4 id="为什么-final-方法加-Transactional-注解不生效"><a href="#为什么-final-方法加-Transactional-注解不生效" class="headerlink" title="为什么 final 方法加 @Transactional 注解不生效?"></a>为什么 <code>final</code> 方法加 <code>@Transactional</code> 注解不生效?</h4><p>原理同上，还是 AOP 无法代理被 <code>final</code> 关键字修饰的方法和类</p><h4 id="为什么类方法相互调用事务不生效？"><a href="#为什么类方法相互调用事务不生效？" class="headerlink" title="为什么类方法相互调用事务不生效？"></a>为什么类方法相互调用事务不生效？</h4><p>事务方法 <code>a</code>调用同类的事务方法 <code>b</code> ，在外部调用 <code>a</code> 方法，<code>b</code> 方法的事务不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个只需要分析下调用过程就清楚了：</p><ol><li>先调用代理类中的 <code>a</code> 方法，然后代理类中调用真正的 <code>a</code> 方法。</li><li><code>UserService</code> 的 <code>a</code> 方法执行过程中，发现要调用 <code>b</code> 方法，因此调用了自己的 <code>b</code> 方法。</li></ol><p>可以看到，<code>a</code> 调用 <code>b</code> 的时候，并没有先经过代理类，而是直接在 <code>UserService</code> 中执行了，所以 <code>b</code> 的事务不会生效。</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/9559d6ef-b67e-49b3-b2a3-6ed40d97aa6d.png" alt="question_1.png"></p><h4 id="为什么注入自己就能解决相互调用问题？"><a href="#为什么注入自己就能解决相互调用问题？" class="headerlink" title="为什么注入自己就能解决相互调用问题？"></a>为什么注入自己就能解决相互调用问题？</h4><p>同样是上面的代码，只需要在 <code>UserService</code> 中注入自己，<code>b</code> 的事务就生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <br>    <span class="hljs-meta">@Autowird</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        userService.b();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>()&#123;<br>    userService.a();<br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面说的依赖注入吗，这里注入自己，实际上注入的是 <code>UserService</code> 的代理类。因此在执行 <code>userService.b()</code> 这段代码时，会调用代理类的 <code>b</code> 方法，所以 <code>b</code> 的事务生效。</p><p><img src="/../picture/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1/4f01d7cf-3c53-4e24-ae76-69b835d7d61b.png" alt="question_2.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的 GC</title>
    <link href="/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/"/>
    <url>/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/</url>
    
    <content type="html"><![CDATA[<p>人在日常活动中不可避免会产生垃圾，程序也是如此。在方法中 new 一个对象，每次调用该方法都会进行 new 对象操作，如果没有人去管理这些对象，没有把这些对象占有内存及时释放掉，内存很快就会满。因此，在程序运行过程中，需要及时寻找和处理「 死去」的对象。这个「 死去」的对象就是<strong>垃圾</strong>，而寻找和处理垃圾的过程就叫做 <strong>GC</strong>。</p><p>GC 全称 “Garbage Collection” 即垃圾收集。不同的语言对于 GC 的处理都是不一样的，因此也产生了不同的「流派」。</p><p><strong>需要说明的是</strong>：本文介绍的 GC 都是基于 HotSpot。</p><h2 id="垃圾管理流派"><a href="#垃圾管理流派" class="headerlink" title="垃圾管理流派"></a>垃圾管理流派</h2><p>根据内存的管理方式，划分出两个流派：手动管理和自动管理。</p><p>手动管理的代表就是：C ++ 和 C。它们需要在编码过程中，手动去释放内存。</p><ul><li>优点：能明确垃圾的产生，以及提高回收的效率。 </li><li>缺点：垃圾太多，在代码中手动清理内存很「痛苦」，很容易忘记释放内存，导致内存泄露。由于需要明确垃圾的产生位置，因此也需要对该语言非常熟悉，这也无形中加大了语言的上手难度。</li></ul><p>自动管理的代表：Java (当然还有很多其他语言，篇幅有限，暂不阐述)。</p><ul><li>优点：使用者无需关心内存的使用，只需专注功能和业务的实现。内存的处理和回收有个智能的程序替我们完成。</li><li>缺点：屏蔽了底层细节，出现了内存问题，使用者无法着手解决。当然解决办法也很简单，就是去了解 GC 原理。</li></ul><h2 id="寻找垃圾"><a href="#寻找垃圾" class="headerlink" title="寻找垃圾"></a>寻找垃圾</h2><p>现在我们知道 Java 是自动 GC，那现在问题来了：它是怎么去找到垃圾？怎么保证找的对象就一定是垃圾呢？</p><p>在「 找垃圾」这块，也有两种方式：引用计数和可达性分析。虽然有两种方式，但主流的 Java 虚拟机里面都没有选用引用计数。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>如图所示，小圆圈代表对象，箭头代表引用关系，数字代表对象被引用的次数。可以看到蓝色的对象都是处于「 活跃」状态的，而灰色的对象要么没有被引用，要么引用它的对象没有被引用，这些对象就是程序需要回收的垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/2069ac04-c401-4330-bb40-6fda0dea5fcb.png" alt="GC-in-Java-01.PNG"></p><p>这一切看似完美无缺，实则存在一个巨大问题：对象间的循环引用。</p><p>仔细看上面这张图，红色的对象相互循环引用，程序并没有使用到，理应当作垃圾处理。但是，在引用计数方法看来这是个「 活跃」的对象，因此并不会进行处理。</p><p>在一些文章上有谈论到解决该问题的方法，例如：循环引用的对象使用 <code>弱引用</code>，使用单独的算法等，详情可以自行搜索。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>Java 就是通过<code>可达性分析</code>算法来进行内存管理的。</p><p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，即通过 GC Roots 访问不到该对象时，则证明此对象是垃圾。</p><p>用比较生活化的例子来解释：家是内存，家庭成员是 GC Roots，物品是对象，家庭大扫除就是可达性分析。家庭大扫除的结果就是把家庭成员都用不到的东西归为垃圾，并把它清除掉。</p><p>如图所示：灰色的对象就是 GC Roots 访问不到的对象，这些对象就是垃圾。图中也可以看到对象循环引用的问题的，在这里也已经不复存在，都会被当做垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/09db1a69-e11e-4a4b-9bdd-43946cb355a5.png" alt="GC-in-Java-02.PNG"></p><p>大扫除的例子，我们知道「 家庭成员」是 GC Roots，在 Java 技术体系中常见的 GC Roots 包括以下几种：</p><ul><li>线程</li><li>native 方法</li><li>栈帧中的局部变量表</li><li>Class 引用的 static field</li><li>所有被同步锁（synchronized关键字）持有的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过上面两种方法来看，似乎对象在内存中的状态只有「 被引用」和「 未被引用」两种状态，GC 把「 未被引用」 的对象收集。</p><p>在在内存空间充足时，可能并不希望「 未被引用」的对象被清除，只有当内存紧张时，才把那些对象抛弃。</p><p>在 Java 中对引用的概念进行扩充，将引用分为：</p><ul><li>强引用（Strongly Re-ference） <ul><li>在 Java 程序代码中普遍存在的就是<code>强引用</code>，比如你 new 一个对象。</li></ul></li><li>软引用（Soft Reference） <ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li></ul></li><li>弱引用（Weak Reference） <ul><li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li></ul></li><li>虚引用（Phantom Reference） <ul><li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。类似于 Linux 中的 <a href="https://zh.wikipedia.org/wiki/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">退出状态</a>。</li></ul></li></ul><p>这4种引用强度依次逐渐减弱。</p><h2 id="垃圾自我救赎"><a href="#垃圾自我救赎" class="headerlink" title="垃圾自我救赎"></a>垃圾自我救赎</h2><p>使用可达性分析找到「未被引用」的对象并不会立即将内存释放，而是给这些对象进行<code>标记</code> ，当对象被<strong>标记两次</strong>后才会进行回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/8939c679-8d1a-4d66-8bd4-910e8e25d6bd.png" alt="image.png"></p><p>当对象第一次标记之后，随后会进行一次筛选，筛选的依据是：<strong>对象是否有必要执行 finalize() 方法？</strong></p><p>假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>「没有必要执行」</strong>。</p><p>对象被判定为「没有必要执行」，则直接进行回收。否则，会把对象放入到一个名为 <code>F-Queue</code> 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。流程如下：</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/f74a1943-9e8f-440b-b097-b3eb7995cd64.png" alt="image.png"></p><p>对象的 finalize() 方法执行，GC 对 <code>F-Queue</code> 中的对象进行第二次标记。如果 finalize() 方法执行之后，对象重新回到了 GC Roots 的引用链上，则把它移出队列。否则，被 GC 回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/41e3ebdc-ac30-40a3-9783-9bdd08b958f7.png" alt="image.png"></p><p>这个时候你可能就有问题了：那我在对象的 finalize() 方法中，编写代码使得当前对象重新回到 GC Roots 引用链上，这个对象岂不是永远不会被 GC 回收？</p><p>答案是会被回收。可以看到「没有必要执行」的条件中有一条是： <strong>finalize() 方法已经被虚拟机调用过</strong>。因此对象虽然能回到引用链上，但是下一次 GC 它一定会被回收。<strong>总结就是：一个对象只能被救赎一次。</strong></p><p>其实关于  finalize() 方法，很多人也不了解，只需要知道它会于 GC 过程产生联系即可。在 《Effective Java》第三版 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md">Item 8</a> ，以及《深入理解 Java 虚拟机》第三版中，作者都不建议在代码中使用 finalize，甚至让我们忘记这个 API。</p><p>因此，使用  finalize() 方法的最佳实践就是：从不使用它。</p><blockquote><p>文章参考《深入理解 Java 虚拟机》第三版、《Effective Java》第三版、《Plumbr Handbook Java Garbage Collcetion》。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins 自动化部署</title>
    <link href="/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/30/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>简介：Java 编写的最广泛使用的开源持续集成工具，非常易用，广泛的第三方插件支持，以及分布式构建。</p><p>文章所演示的项目地址：</p><p>GitHub: <a href="https://github.com/greek-zzf/oh-my-jenkins.git">https://github.com/greek-zzf/oh-my-jenkins.git</a><br>Gitee: <a href="https://gitee.com/geek-zzf/oh-my-jenkins.git">https://gitee.com/geek-zzf/oh-my-jenkins.git</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="War-包方式"><a href="#War-包方式" class="headerlink" title="War 包方式"></a>War 包方式</h3><p>优点：安装启动非常方便。</p><p>缺点：与环境强绑定，服务器要为 Jenkins 提供部署项目所需要的环境，例如：Node、Java 等。 部署成服务需要使用对应平台的命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到安装方式，下载 War 包。或者直接点击<a href="https://www.jenkins.io/download/">这里</a>下载。 </p></li><li><p>下载完成运行命令 <code>java -jar jenkins.war</code> ，等待几分钟。 </p></li><li><p>在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>优点：与宿主机环境隔离，不依赖宿主机环境。注册成服务非常方便，只需要启动时设置好参数 <code>--restart=always</code> 即可。</p><p>缺点：启动稍微复杂，需要配置好启动命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到 Docker 安装方式。或者直接点击<a href="https://www.jenkins.io/doc/book/installing/docker/">这里</a>访问。 </p></li><li><p>运行 Docker 命令如下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">step1: docker network create jenkins<br><br>step2: docker run --name jenkins-docker --rm --detach \<br>  --privileged --network jenkins --network-alias docker \<br>  --env DOCKER_TLS_CERTDIR=/certs \<br>  --volume jenkins-docker-certs:/certs/client \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --publish 2376:2376 \ <br>  docker:dind --storage-driver overlay2   --insecure-registry 47.107.74.10:5000 <br> <br><br>step3: 创建 Dockerfile 文件，并把如下内容复制进去<br><br>    FROM jenkins/jenkins:2.332.2-jdk11<br>    USER root<br>    RUN apt-get update &amp;&amp; apt-get install -y lsb-release<br>    RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \<br>      https://download.docker.com/linux/debian/gpg<br>    RUN echo &quot;deb [arch=$(dpkg --print-architecture) \<br>      signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \<br>      https://download.docker.com/linux/debian \<br>      $(lsb_release -cs) stable&quot; &gt; /etc/apt/sources.list.d/docker.list<br>    RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli<br>    USER jenkins<br>    RUN jenkins-plugin-cli --plugins &quot;blueocean:1.25.3 docker-workflow:1.28&quot;<br><br>step4: docker build -t myjenkins-blueocean:2.332.2-1 .<br><br>step5: docker run --name jenkins-blueocean --rm --detach \<br>  --network jenkins --env DOCKER_HOST=tcp://docker:2376 \<br>  --env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \<br>  --publish 8080:8080 --publish 50000:50000 \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --volume jenkins-docker-certs:/certs/client:ro \<br>  myjenkins-blueocean:2.332.2-1<br></code></pre></td></tr></table></figure></li><li><p>等待一会，在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><p><strong>注意</strong>：步骤4构建失败，可能是由于 Docker 权限问题，解决方案可参考<a href="https://github.com/docker/buildx/issues/476">这里</a>。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>解锁 Jenkins：浏览器中提示输入管理员密码。War 在启动的控制台中会打印密码，或者页面提示的文件中。Docker 方式使用命令，查看容器日志信息即可看到 <code>docker logs jenkins-blueocean</code>。 </p></li><li><p>插件下载镜像设置：为了部署和运行项目，需要安装一些插件。首先需要给插件站点设置一个镜像，不然访问速度感人。配置路径 “Manager Jenkins -&gt; Manager Plugins -&gt; Advanced”，在底部的 <code>Update Site</code> 中把地址进行替换。这里提供一个国内可访问的镜像地址：<a href="https://updates.jenkins-zh.cn/update-center.json%E3%80%82">https://updates.jenkins-zh.cn/update-center.json。</a></p></li><li><p>设置好插件镜像源之后，去搜索对应的插件，下载安装即可。 </p></li><li><p>下载并安装插件：由于项目是用 Git 来管理的，并且使用的是 Maven，因此需要下载这两个插件。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建 Job 之前，需要先了解一个 Job 任务涉及到哪些流程。Jenkins 给我们提供了以下几个模块：</p><ul><li><p><code>General</code> Job 描述，可选。 </p></li><li><p><code>Source Code Management</code> 源代码管理，有多个版本工具选择：Git、Svn 等。 </p></li><li><p><code>Build Triggers</code> 构建触发器，选择构建代码的时机 </p><ul><li>Trigger builds remotely，手动去触发。</li><li>Build after other project are built，在其他项目构建完成后触发。</li><li>Build periodically，周期的进行构建</li><li>GitHub Hooks，当有代码更新到 GitHub，GitHub 会触发一个 Hooks，并通知 Jenkins 服务开始构建，这个需要在 GitHub 中配置推送地址信息。</li><li>Poll SCM 定时任务轮询，填写 Cron 表达式指定轮询的时机。例如：每 10 分钟去检查 GitHub 仓库是否有代码更新。</li></ul></li><li><p><code>Build Environment</code>构建环境，配置项目构建的环境，可以在构建的时候传递环境变量信息。 </p></li><li><p><code>Build</code> 可以选择构建所需步骤。 </p></li><li><p><code>Post-build Actions</code>可以指定项目完成构建之后的行为。</p></li></ul><h2 id="手动创建-Job"><a href="#手动创建-Job" class="headerlink" title="手动创建 Job"></a>手动创建 Job</h2><p>在 Jenkins 中添加两个任务，一个用于拉取代码运行测试、打包任务，另一个可以手动选择版本的部署任务。</p><h3 id="创建测试打包任务"><a href="#创建测试打包任务" class="headerlink" title="创建测试打包任务"></a>创建测试打包任务</h3><ol><li>填写创建的 Job 信息</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/24e982a6-9b83-4233-99f0-15c083663bb5.png" alt="image.png"></p><ol start="2"><li>选择 Git 作为代码管理工具，配置对应的仓库地址。如果是私密仓库，需要填写对应的账号密码。这里使用了 ssh 方式，并提前配置好了私钥信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/0c9f33b3-b50e-45dd-b984-8fdd5c4a1ea9.png" alt="image.png"></p><ol start="3"><li>选择一个构建方式，这里我们选择 SCM，填写一个每 10 分钟轮询一次的 corn 表达式。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/415593ca-72bb-4786-a3c5-14271c5d15ac.png" alt="image.png"></p><ol start="4"><li>构建的时候选择 <code>Execute shell</code> 并在文本框中填写要执行的脚本信息，这里我们填写 <code>mvn clean package</code>，该命令会执行清理、测试、打包操作，在 target 目录下生成 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3fea80cf-d62d-4d27-a028-4bae6b70c59a.png" alt="image.png"></p><ol start="5"><li>保存任务，回到页面。等待 10 分钟或者手动点击立即构建，即可开始构建。 控制台最终打印了文件夹下所有项目版本信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b452178d-9bdd-4873-98f7-663fd62ef8bf.png" alt="image.png"></p><h3 id="创建部署任务"><a href="#创建部署任务" class="headerlink" title="创建部署任务"></a>创建部署任务</h3><ol><li>创建 deploy 任务，在页面中填写描述，并勾选 <code>This project is parameterized</code>，选择 String 参数，这里定义一个变量 version。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f0e1221-1b21-4ac1-a991-19753f4085ca.png" alt="image.png"></p><ol start="2"><li>由于部署任务和打包任务是分开，此处无需在使用 Git 去拉取代码，也无需定义构建触发器，直接手动构建即可。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/8489f466-cf27-4f07-b07a-304f8b42769b.png" alt="image.png"></p><ol start="3"><li>build 环节还是去执行一个 shell，这里我们配置一个 java 程序启动命令 <code>java -Dserver.port=5000 -jar  /c/Users/Administrator/Desktop/jenkins/$&#123;version&#125;.jar</code>指定 5000 端口，并且根据输入的版本号，去执行对应的 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f823c65-51d5-4936-b226-d635fc86e3c3.png" alt="image.png"></p><ol start="4"><li>根据上个任务构建的输出，我们执行部署任务的构建。Jenkins 会弹出提示，此时输入对应的项目版本号，点击开始构建，等待构建完成项目就启动成功了。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b651a7f8-0267-42c9-861b-4ea128b5f596.png" alt="image.png"></p><h2 id="使用-Jenkinsfile-创建-Job"><a href="#使用-Jenkinsfile-创建-Job" class="headerlink" title="使用 Jenkinsfile 创建 Job"></a>使用 Jenkinsfile 创建 Job</h2><p>图形化页面创建一个 Job 很方便，但是当 Jenkins 需要为多个项目创建 Job 时，一个一个手动创建就会很繁琐，并且 Job 信息也没办法进行版本管理。</p><p>Jenkinsfile 就是来解决这个问题的，他将 Job 的配置信息用脚本语言来表示，这样只需要维护这个脚本即可。Jenkinsfile 就像是一份说明书，指导 Jenkins 的工作，让他自动帮我们完成配置。编写 Jenkinsfile 的脚本语言是 Groovy，推荐学习。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>整个流程如图：<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/70124ec6-6334-457c-9f47-4341127d490c.png" alt="image.png"></p><p><strong>创建流程</strong>：</p><ul><li><p>为项目编写 Dockerfile。</p></li><li><p>创建 Jenkinsfile。</p></li><li><p>使用 pipleline 语法编写脚本：使用 Dockerfile 文件 build 一个镜像，并上传到 Docker 私服。</p></li><li><p>使用一个新的 Job，用来获取 Docker 私服所有项目版本信息，支持选择对应版本部署。</p></li></ul><h3 id="为项目编写-Dockerfile"><a href="#为项目编写-Dockerfile" class="headerlink" title="为项目编写 Dockerfile"></a>为项目编写 Dockerfile</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">FROM <span class="hljs-attr">java:</span>openjdk<span class="hljs-number">-8</span>u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target<span class="hljs-regexp">/oh-my-jenkins-0.0.1-SNAPSHOT.jar /</span>app<br><br>EXPOSE <span class="hljs-number">8080</span><br><br>CMD [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;oh-my-jenkins-0.0.1-SNAPSHOT.jar&quot;</span> ]<br></code></pre></td></tr></table></figure><h3 id="在-master-分支创建-Jenkinsfile-并编写对应的脚本"><a href="#在-master-分支创建-Jenkinsfile-并编写对应的脚本" class="headerlink" title="在 master 分支创建 Jenkinsfile 并编写对应的脚本"></a>在 master 分支创建 Jenkinsfile 并编写对应的脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>     agent any<br>     triggers &#123;<br>          pollSCM(<span class="hljs-string">&#x27;* * * * *&#x27;</span>)<br>     &#125;<br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            agent &#123; docker &#123;<br>                image <span class="hljs-string">&quot;circleci/openjdk:8u212-jdk-stretch&quot;</span><br>                args <span class="hljs-string">&#x27;-v /usr/local/docker-cache:/root/.m2&#x27;</span><br>                            &#125;<br>                 &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&#x27;mvn clean package&#x27;</span><br>                stash <span class="hljs-attr">includes:</span> <span class="hljs-string">&#x27;**/target/*.jar&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;app&#x27;</span><br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Docker Build&#x27;</span>) &#123;<br>           steps &#123;<br>               echo <span class="hljs-string">&#x27;Starting to build docker image&#x27;</span><br><br>                unstash <span class="hljs-string">&#x27;app&#x27;</span><br>                script &#123;<br>                    <span class="hljs-keyword">def</span> customImage = docker.build(<span class="hljs-string">&quot;172.29.145.109:5000/on-my-jenkins:$&#123;new Date().format(&#x27;yyyy-MM-dd-HH-mm-ss&#x27;)&#125;&quot;</span>)<br>                    customImage.push()<br>                &#125;<br>           &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本定义了轮询任务，在 docker 中使用 java 环境运行 <code>mvn clean package</code>打包，并把它暂存。之后使用一个 docker build 构建镜像并推送到 docker 私服。由于私服地址和 Jenkins 都在同一个服务器，因此直接使用内网 ip。</p><h3 id="在-deploy-分支创建-Jenkinsfile-并编写部署脚本"><a href="#在-deploy-分支创建-Jenkinsfile-并编写部署脚本" class="headerlink" title="在 deploy 分支创建 Jenkinsfile  并编写部署脚本"></a>在 deploy 分支创建 Jenkinsfile  并编写部署脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> responseJson = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://172.29.145.109:5000/v2/oh-my-jenkins/tags/list&quot;</span>)<br>        .getText(<span class="hljs-attr">requestProperties:</span> [<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&quot;application/json&quot;</span>]);<br><br>println(responseJson)<br><br>Map response = <span class="hljs-keyword">new</span> groovy.json.JsonSlurperClassic().parseText(responseJson) <span class="hljs-keyword">as</span> Map;<br><br><span class="hljs-keyword">def</span> versionsStr = response.tags.join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>pipeline &#123;<br>     agent any<br><br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            input &#123;<br>                message <span class="hljs-string">&quot;Choose a version&quot;</span><br>                ok <span class="hljs-string">&quot;Deploy&quot;</span><br>                parameters &#123;<br>                    choice(<span class="hljs-attr">choices:</span> versionsStr, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;version&#x27;</span>)<br>                &#125;<br>            &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker rm -f oh-my-jenkins&#x27; || true&quot;</span><br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker run --name oh-my-jenkins -p 8081:8080 -d 172.29.145.109:5000/oh-my-jenkins:$&#123;version&#125;&#x27;&quot;</span><br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本获取 Docker 私服的<code>oh-my-jenkins</code>镜像，部署我们选择的版本。</p><h3 id="在-Jenkins-创建多分支流水线任务"><a href="#在-Jenkins-创建多分支流水线任务" class="headerlink" title="在 Jenkins 创建多分支流水线任务"></a>在 Jenkins 创建多分支流水线任务</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b439354a-e1a4-47f4-9bf4-06975e7d8c98.png" alt="image.png"></p><p>然后只需要配置仓库地址就好了，由于 GitHub 抽风，所以使用 Gitee 仓库地址。<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/4047e5a2-911f-4a91-9380-55c45988a209.png" alt="image.png"><br>创建完流水线任务，他会自动扫描仓库上的所有分支，并读取 Jenkinsfile 文件，执行命令。</p><h3 id="选择版本部署"><a href="#选择版本部署" class="headerlink" title="选择版本部署"></a>选择版本部署</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3368c931-7653-4f8a-bc9e-df43d04ee7fc.png" alt="image.png"><br>当流水线分支创建完成之后，deploy 分支会等待我们选择版本，选择需要部署的版本，deploy 即可完成部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基本结构</title>
    <link href="/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>谈起 JVM 第一印象就是「八股」，毕竟正经人谁学 JVM 啊。当我深入学习，了解了相关原理后，真令人大呼过瘾。</p><p>了解 JVM 并不会让你更快的 CRUD，对大部分工作没有实质性的帮助，但这是成为高级程序员的第一步。</p><h2 id="JVM-初识"><a href="#JVM-初识" class="headerlink" title="JVM 初识"></a>JVM 初识</h2><p>JVM 全称是 <strong>Java virtual machine</strong> 即 Java 虚拟机。JVM 是抽象（虚拟）计算机，它定义了一系列规范，因此他有很多实现，如：HotSpot，Eclipse OpenJ9 等等，最常使用的应该就是 Oracle 的 HotSpot。</p><p>JVM 存在的意义就是抹平所有平台和操作系统的鸿沟。它就像是一个在不同平台提供的翻译官，当用英语和它对话时，他翻译成自己「国家」的语言并执行。这就是为什么在 Windows 下编写好的代码能够在 Linux 等其他系统运行的原因。</p><p>代码编译执行过程如图<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/4ff19c89-d87f-4273-bfe4-3c47e3a8f1ad.png" alt="jvm_1.png"><br>程序员使用像 Java，Kotlin，Scala ，Groovy 等高级语言进行编码，编译成 JVM 能识别的语言。JVM 识别并进行「二次编译操作」，将它翻译成对应的平台语言。</p><p>日常编码所做的仅仅只是用高级语言编写一份「说明书」，说明书如何编译成中间语言，这就是高级语言编译器做的事了，当然也可以自己去实现一个编译器，嗯。。至少我目前没有这个能力。</p><p><strong>JLS</strong></p><p>Java 语言规范 Java Language Specification， 定义了 Java 编程的语法。比如 Java 中的关键字信息 class、public 等等，都是在 JLS 规范下，完成 Java 代码的开发。</p><p><strong>JVMS</strong></p><p>Java 虚拟机规范 Java Virtual Machine Specifiction，定义了字节码如何在 JVM 中执行，仅此而已。</p><h2 id="JVM-堆-Heap"><a href="#JVM-堆-Heap" class="headerlink" title="JVM 堆 (Heap)"></a>JVM 堆 (Heap)</h2><p>堆是 JVM 中非常重要的区域，所有的「对象」都在堆上分配，它是个无情的对象生产机器，只负责生产，不负责销毁。</p><p>堆为我们创建了对象，但是在代码中操作与访问对象实际上都是在操作对象的地址或者引用。</p><p>来看个非常简单的代码，以此来演示堆中发生了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1540f816-9a4c-4b1f-af66-0a4c6b917b3c.png" alt="jvm_heap.png"><br>首先堆内存中创建了一个对象（假设对象地址为 100），然后将该对象的地址赋值给 obj 变量，可以想象有一条线将 obj 和 对象 100 连接起来。</p><p>接着，堆内存中又创建了一个变量 101，然后将该对象地址赋值给 obj，此时 obj 和对象 101 连接起来了。这就是堆所做的一切。</p><p>很显然，上面的例子对象 100 还是存在堆中，他并没有消失，他还在等有缘人「联系」它。</p><p>这样就会存在一个问题，「无人问津」的对象越来越多怎么办？这就涉及到 GC 了，GC 会根据相应的算法来判断对象是否需要回收销毁，因此暂时不需要操心，后续提供 GC 的讲解。</p><p>当然堆中产生的对象太多，大量占用堆内存，导致内存溢出，常见表现为 OOM (Out Of Memory) 异常。当代码出现该异常时，就应该关心，代码是否产生了大量不必要的对象，谨慎的检查代码。</p><h2 id="JVM-栈（Stack）"><a href="#JVM-栈（Stack）" class="headerlink" title="JVM 栈（Stack）"></a>JVM 栈（Stack）</h2><p>当我们用 IDEA Debug 如下代码，可以看到在 IDEA 界面底部，多了一些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    a();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am a&quot;</span>);<br>    b();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我的调试器中表现形式如下：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/9c51eaa9-3ce2-4d47-9a40-b38be9fba7aa.png" alt="method_stack.PNG"></p><p>从 main 方法到 b 方法，中间一系列调用都称作<strong>「栈」</strong>或<strong>「方法栈」</strong>，其中每一次方法调用称作<strong>「栈帧」</strong>，如图中的 main，a，b。</p><p>不知你是否思考过，为什么代码的调用形式会是这样？无论你是否好奇过，现在我来分析下代码执行的过程。</p><p>我们都知道，Java  程序的入口都是 main 方法开始的，因此当代码被执行时，会先调用 <strong>main</strong> 方法。不过，在调用 main 方法之前，JVM 创建一个方法栈，用来保存「当前线程」方法调用过程（因此方法栈是线程私有的）。于是方法栈中会放入第一个栈帧 main，由于栈结构的特性，main 自然而然的就会在栈底。</p><p>接着执行 main 方法，执行到最后需要调用 <strong>a</strong> 方法，因此将栈帧 a 放入方法栈中。接着 a 中又调用 b 方法，以此类推。现在，方法栈中已经有 3 个栈帧了，方法调用已经结束了。于是从栈顶开始，将方法的执行结果依次返回，b 方法中无返回值，因此执行完打印语句，b 栈帧就销毁了。以此类推到 a 方法，最后到 main，这就是上述代码玩完整的执行过程，流程如图：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/41370100-58dc-4f78-bdde-b88dd7483c77.png" alt="method_stack_invoke.png"></p><p>了解了方法调用的基本流程，这里有几个疑问：</p><p><strong>Q：当方法栈满了会发生什么？</strong></p><p>A：当栈深度过⼤时抛出 StackOverflowError，著名的程序员交流网站就是以此命名的 <a href="https://stackoverflow.com/">stackoverflow</a></p><p><strong>Q：栈帧销毁什么时候被销毁？</strong></p><p><strong>A</strong>：这些情况栈帧会被销毁：当方法执行抛出异常或者错误；方法正常返回结果或者无返回。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>来看一段简单的代码， a 方法定义了一个变量，并且调用了 b 方法使得该变量自增，然后打印该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    b(i);<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    i++;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中打印的结果为 0，按照正常的思维去理解的话，i 的值因该为 1 才对，这是为什么？</p><p>这是因为这些变量在方法中都是<strong>「值传递」</strong>的，当把 i 传递给 b 方法时，发生了一次拷贝，因此 b 方法中操作的 i，实际上只存在 b 方法中，并不会影响到 a 方法中的 i 变量。</p><p>上面说的是基本类型变量传递，接下来用引用数据类型来进行参数传递，看看发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    b(obj);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(Object obj)</span>&#123;<br>    obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中初始化了一个变量 obj，并把它当作参数传递给 b 方法，b 方法中创建一个新的对象，并把该对象地址赋值给参数 obj。整个过程就是这样，此时 a 中的 obj 对象和 b 中的 obj 是什么关系？他们是同一个对象吗？b 中的对象改变了，会影响到 a 吗？</p><p>有过编程经验的应该都知道，答案是否定的。<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/42e48b45-6083-49b6-ae87-95fe66c76114.png" alt="stack_argument.png"><br>如图所示，a 中 obj 变量指向 Object 10087，把 obj 当作参数给 b 方法时，他会直接复制 obj 所指向的对象地址，即 b 方法刚开始也指向 10087 对象。之后创建了一个新对象地址为 10086，并把地址重新赋值给了 obj，因此 b 中的 obj 指向的是 10086，而 a 指向的是 10087，两者操作的都不是同一个对象，因此也不会相互影响。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>现在已经对 JVM 中的堆和栈有所了解，但是对于方法栈中的每个栈帧还不了解，目前只是知道方法调用就入栈，结束就出栈。因此，现在将栈帧放大来看，看看代码执行过程中，栈帧发生了什么。</p><p>每个栈帧中都有一个「操作数栈」和「局部变量表」。</p><p>每当方法调用开始的时候，局部变量表会被初始化成当前方法的参数。操作数栈上会根据代码实际情况，加载局部变量表中的数据，或者直接加载常量，根据<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">字节码指令集</a>，完成相应的数据操作。</p><p>这就像是人在吃饭一样，用筷子在碟子（局部变量表）中夹菜，夹到碗中（操作数栈），然后根据自己喜好（代码）吃自己的菜。</p><h2 id="JVM-方法区"><a href="#JVM-方法区" class="headerlink" title="JVM 方法区"></a>JVM 方法区</h2><p>方法区中包含了整个虚拟机所共享的 Class 信息，JVM 就是根据方法区中 Class 这份说明书，来帮我们生成对象的。</p><p>方法区中存的所有信息都是共享，基本都是只读的，但这并不是一定的。<strong>「运行时常量池」</strong>就是个例外，在程序运行时往往会往常量池中放入常量信息。</p><p>运行时常量池会保存经常使用的常量，例如 String 字符串常量，当重复 new 一个相同字符串对象时，新的对象就会指向字符串常量池中的字符串常量，这样就节省了内存开销。同时在 String api 中，由于常量的重复使用，可以使得它的 equals 方法可以更快速地进行判断。</p><p><strong>永久代和元空间</strong></p><p>JVM 方法区是一块所有的线程共享的区域，是 JVM 所定义的规范。</p><p>Java 7 之前发方法区的实现称作<strong>「永久代」</strong>，即 <strong>PermGen</strong>。Java 8 之后的称作<strong>「元空间」</strong>，即 <strong>Metaspace</strong>。</p><p>在 Java 7 中，方法区和堆是使用一块连续的物理内存，仅仅是在逻辑上分开的。如果没有设置方法区的大小的话，使用默认大小很容易遇到 OOM 错误。</p><p>在 Java 8 之后，把方法区和堆区分开来，使用了本地内存（Native memory），大小取决于本地内存大小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2022/01/03/Stream/"/>
    <url>/2022/01/03/Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Stream-流"><a href="#什么是-Stream-流" class="headerlink" title="什么是 Stream 流"></a>什么是 Stream 流</h2><p>流就相当于工厂的流水线工作，传送带上是一件件产品，而传送带周围是一些工人。有的负责把挑出次品，把它放到其他另一条流水线中重新加工，有的负责根据产品颜色进行收集，等等。如下图所示。<br><img src="/../picture/Stream/446cbca4-82a6-49e7-8ceb-1ceadcbcc8a9.png" alt="image-20210424211146663.png"></p><p>三个员工对传送带上的产品进行操作，老王负责收集把黄色产品挑出，老周负责把产品按先后排序，而老赵负责把残次品挑拣出来，拆开零件放到新的床送带中，继续加工。传送带的终点就是篮子，产品都流向篮子里面。</p><p>流的操作就是如此。在没有流之前，我们要自己从一堆产品中找到残次品很难。但是我们有了流之后，我们有了流水线，有了工人，我们就可以让工人帮我们收集，让他们来处理，我们只是充当老板的角色，下达命令即可。在 Java 的流 (Stream) 中，我们只需要使用一些命令，剩下的交给程序本身去执行。这样做既减少了代码量，又能高效完成我们的需求，真是两全其美。</p><p>在上面的过程中，我们把老王和老周，以及老赵操作叫做<strong>中间操作</strong>。因为他们并没有把产品收集起来，他们只是把其他不合格的产品过滤挑出，产品最终都是到篮子里面。但是你装产品不一定是用篮子，你也可以使用箱子，等其他容器。我们把使用这些<code>容器</code>装产品的操作称作<strong>终结操作</strong>。在 java 中，<strong>中间操作就是返回为 Stream 的操作，终结操作就是返回非Stream 的操作。</strong>下面会详细讲解。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p><strong>创建 Stream</strong></p><ul><li>Collection.stream()</li><li>Stream.of()</li><li>String.chars()</li><li>IntStream.range() 等</li></ul><p><strong>Stream 中间操作</strong></p><ul><li>filter 按照输入的条件，过滤流中的元素</li><li>map</li><li>sorted 对流中的元素排序</li></ul><p><strong>Stream 终结操作</strong></p><ul><li>forEach 遍历流中的元素</li><li>count &#x2F; max &#x2F; min 统计元素个数 、最大元素、最小元素</li><li>findFirst &#x2F; findAny 找到第一个元素、随机找一个元素</li><li>anyMatch &#x2F; noneMatch 是否有匹配的元素、没有匹配的元素</li><li><strong>collect</strong> 等</li></ul><p>从方法名中我们就能了解它的用处，更为详细的 API 操作可以查看 Stream 源代码。</p><h2 id="Collector-操作"><a href="#Collector-操作" class="headerlink" title="Collector 操作"></a>Collector 操作</h2><p>Collector 操作是 Stream 中最强大的操作，他就是我们上面例子中提到的「篮子」「箱子」等。它具有以下 API</p><ul><li>toSet &#x2F; toList &#x2F; toCollection</li><li>joining()</li><li>toMap()</li><li>groupingBy()</li></ul><p>通过这些 API 操作，使得我们能将流中的元素收集起来</p><p>下面通过一些实际案例，加深对 Stream 的理解。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        User(String name, <span class="hljs-type">int</span> age) &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有个需求<strong>筛选出年龄大于等于60的用户，然后将他们按照年龄从大到小排序，将他们的名字放在一个LinkedList中返回</strong>。我们可以使用 Stream 写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LinkedList&lt;String&gt; <span class="hljs-title function_">collectNames</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>       <span class="hljs-keyword">return</span> users.stream()<br>               .filter(user -&gt; user.age &gt;= <span class="hljs-number">60</span>)<br>               .sorted(comparing(User::getAge).reversed())<br>               .map(user -&gt; user.name)<br>               .collect(toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><p>解析：要使用 Stream 首先就需要创建它<code>users.stream()</code>，根据要求筛选出年龄大于 60 的用户 <code>filter(user -&gt; user.age &gt;= 60)</code>，然后使用 sorted 对筛选后的用户按照年龄排序。由于我们要返回的是一个字符串列表<code>LinkedList&lt;String&gt;</code>，而我们 Stream 中的元素都是对象类型，因此我们使用 <code>map(user -&gt; user.name)</code>，把User 映射成 String 类型，这样 Stream 中的元素都是用户的名字了。最后，使用 collect 操作将用户的名字收集成一个 Linked ，这样就解决了我们的需求。</p><p>通俗解释：我们作为老板，我们要创建一条流水线，然后安排工人在流水线旁边进行操作。安排员工老赵把用了60年以上的产品，筛选出来。筛选完后，安排老周按使用时长进行从大到小排序。排序之后，安排老王把可用的零件拆下来，最后用一个篮子收集这些可用的零件。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>统计一个给定的字符串中，大写英文字母（A,B,C,…,Z）出现的次数</strong>。例如，给定字符串”AaBbCc1234ABC”，返回6，因为该字符串中出现了6次大写英文字母 ABCABC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUpperCaseLetters</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) str.chars()<br>            .filter(Character::isUpperCase)<br>            .count();<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：String 类型创建流 <code>str.chars()</code>，然后使用 filter 进行过滤操作，过滤出大写字母 <code>filter(Character::isUpperCase)</code>，接着对过滤出的字母进行统计，完成需求。</p><p>更多关于 Stream 操作 demo点击<a href="https://github.com/greek-zzf/my-demo/tree/main/example/Stream%20%E7%BB%83%E4%B9%A0">这里</a></p><h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>可以通过并发提高<strong>互相独立操作</strong>的性能。</p><p><strong>互相独立操作</strong>指的就是，操作相互之间不影响。例：1个人割麦子需要10天，那10个人割相同面积的麦子就只需要1天。</p><p><strong>非互相独立操作</strong>就像女人生孩子，1个女人十10个月生1个孩子，但是10个女人并不是一个月就能把孩子生出来。</p><p>在正确使用的前提下，可以获得近似线性的性能提升。要使用并发流我们可以使用 <code>parallelStream()</code>创建并发流。或者在原有流的基础上，使用 <code>parallel()</code> 方法将流转化为并发流。</p><p>使用一个简单的案例来使用并发流，统计 1 到 100万之间的质数个数 。原始的 Stream 写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).filter(是否为质数).count()<br></code></pre></td></tr></table></figure><p>并发流写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100_0000</span>).parallel().filter(isPrime).count();<br></code></pre></td></tr></table></figure><p>因为统计个数属于互相独立操作，就像两个人数羊群有多少只绵羊一样，两人分别数自己区域的羊，然后再加起来汇总。</p><p>对于并发流来说，使⽤要⼩⼼，性能要测试，如果你不知道⾃⼰在做什 么，就忘了它吧。对于详细的操作可以参考<a href="https://book.douban.com/subject/30412517/">《Effective Java 第三版》</a>42-48节。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021-年终总结（技术向）</title>
    <link href="/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/"/>
    <url>/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。</p><h3 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h3><ul><li>Maven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。</li><li>学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。</li><li>了解 Jenkis 自动化部署的流程，能够进行简单的构建。</li><li>学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。</li><li>编写了自己的自动化脚本，自动拉取代码打包，运行项目。</li><li>会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。</li><li>学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）</li><li>深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。</li><li>了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。</li><li>熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。</li><li>写了一个简单的新浪新闻爬虫。</li><li>GitHub 也开始有绿点了，尽管不多，但也是个很好的开始。</li></ul><p><img src="/../picture/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/a2f75394-0052-49aa-8e37-a56774bf8a47.png" alt="image.png"></p><ul><li>帮助开源项目 <a href="https://github.com/ByteLegend/ByteLegend">https://github.com/ByteLegend/ByteLegend</a>，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。</li><li>了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。</li></ul><h3 id="知识获取渠道推荐："><a href="#知识获取渠道推荐：" class="headerlink" title="知识获取渠道推荐："></a>知识获取渠道推荐：</h3><ul><li>正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 <a href="https://fsou.cc/">https://fsou.cc/</a>，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。</li><li>取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。</li><li>论坛：<ul><li><a href="https://v2ex.com/">V站</a> 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。</li><li>HackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。</li><li>GitHub 全球最大的同性交友平台（手动滑稽）</li><li>CoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。</li><li>[<a href="https://nipafx.dev/]">https://nipafx.dev/]</a>(You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。</li></ul></li><li>许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。</li><li>了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是<strong>无所不知</strong>)、陈皓（Collshell 作者）</li></ul><h3 id="2022-的一些目标"><a href="#2022-的一些目标" class="headerlink" title="2022 的一些目标"></a>2022 的一些目标</h3><ul><li>工作顺利、生活愉快。</li><li>去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》</li><li>参与到更多开源项目中去、GitHub 绿点也可以多一些。</li><li>保持自己的好奇心、做自己想做的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？</p></blockquote><p>我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。</p><p>上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。</p><p>对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></blockquote><p>简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。</p><p><strong>二进制向量</strong>就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。</p><p>下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/54a416e0-66c1-4893-aade-ede8e001bd04.png" alt="1.png"></p><p><strong>映射函数</strong>我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。</p><p>布隆过滤器对一个 key 使用多个映射函数，得到多个值。</p><p>哈希函数映射</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/63b9a80b-0cd5-48ea-ac54-a93256a7caf7.png" alt="hash.png"></p><p>布隆过滤器中映射函数</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/51445b83-d4a0-497f-8ebb-5f0fb9ddcc76.png" alt="bloomfilter.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解一些基本概念之后，布隆过滤器的原理就很明了了。</p><p>布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。</p><p>例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/ccf230bf-6de4-49ab-8238-c9387cad586d.png" alt="insert.png"></p><p>我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。</p><p>如果是，则该元素<strong>可能</strong>在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。</p><p>如果不是，则表示该元素一定不在集合中。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。</p><h3 id="误识别率"><a href="#误识别率" class="headerlink" title="误识别率"></a>误识别率</h3><p>插入字符串 “zzh” 得到下标 2、7、11</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8b034b8d-b422-4dfc-a270-10c65db5d255.png" alt="insert.png"></p><p>插入字符串 “greek” 得到下标 5、8、9</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4bc4c95c-abee-4c20-9d5e-cf66a4b02cd5.png" alt="insert_greek.png"></p><p>插入字符串 “gem” 得到下标 2、5、8</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/66253d9d-d8ac-4783-9ba3-a3f954bfb9fa.png" alt="insert_gem.png"></p><p>可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。</p><h3 id="删除困难"><a href="#删除困难" class="headerlink" title="删除困难"></a>删除困难</h3><p>删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。</p><p>我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。</p><h3 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h3><p>识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。</p><p>假设在布隆过滤器里面有 <em>k</em> 个映射函数, <em>m</em> 个比特, 以及 <em>n</em> 个已插入元素，那么该过滤器误判率近似于：_(1-e-kn&#x2F;m)k_ 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。</p><p>对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情<a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/#footnote2">点击</a></p><blockquote><p>对于给定的 <em>m</em> 和 <em>n</em> ，有一个函数可以帮我们确定最优的 <em>k</em> 值: <em>(m&#x2F;n)ln(2)</em></p><p>所以可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的_n_, <em>m</em>, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束</li></ol></blockquote><p>事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">wiki</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>查询效率和插入效率高</strong>，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。</p><p><strong>空间效率</strong>。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。</p><p>假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。</p><p>一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 提交作业</title>
    <link href="/2021/12/24/GitHub%20%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/"/>
    <url>/2021/12/24/GitHub%20%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>使用一个工具的时候，应该先要问自己他是什么，他有什么作用？所以先根据这两个来初步了解下 Git 和 GitHub。</p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>GitHub 简单来说就是一个<code>代码仓库</code>，里面存放着世界各地程序员写的代码，我们也可以在 GitHub 上注册自己的账号，拥有自己的代码仓库。我们可以往自己的仓库提交代码，也可以去看一些大牛的仓库，学习他们的编码技巧，倘若发现一些小 Bug，我们也可以帮助别人解决，贡献一份力量。</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>想一个问题：我们已经有了自己的代码仓库 GitHub，那么我们该怎么把自己电脑上的代码放到 GitHub 中去呢？</p><p>解决这个问题的办法有：我们打开 GitHub ，在自己的代码仓库点击上传文件，这样就可以上传自己的代码。但是这样上传速度慢，而且容错性较差，可能遇到提交错误的代码，导致无法回到上一版本。</p><p><code>Git</code> 最大的用处，应该就是版本控制。可以记录你提交记录与版本，相当于「后悔药」，也支持多人协作，每个人的代码提交记录都会保存，所做的修改也有记录，这就是 <code>Git</code> 的好处。</p><h1 id="修改别人的代码"><a href="#修改别人的代码" class="headerlink" title="修改别人的代码"></a>修改别人的代码</h1><p>这是一次在 GitHub 上完成提交的经历，整个过程如下：</p><h2 id="一、Fork-别人的代码"><a href="#一、Fork-别人的代码" class="headerlink" title="一、Fork 别人的代码"></a>一、<code>Fork</code> 别人的代码</h2><p>首先，找到你要修改的仓库地址。因为是别人的代码，你没办法直接 「clone」复制下来，修改并提交，除非仓库的主人你认识，并且赋予了你修改的权限。既然没有直接的修改权限，那么我们就要 <code>Fork</code> 一份代码。<code>Fork</code> 的意思是：<strong>把当前仓库，拷贝到自己的 GitHub。</strong><code>Fork</code> 的结果就是你的 GitHub 中多了一个一模一样的仓库。<code>Fork</code> 操作如图：</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/cb59b504-916e-4f55-af84-6dc15999ca16.png" alt="image.png"><br>图中的 <code>Fork</code> 结果，在我的 GitHub 中多了一个「JavaCollection」的仓库，代码也和拷贝过来的一模一样。</p><h2 id="二、Clone-代码，并在本地进行修改"><a href="#二、Clone-代码，并在本地进行修改" class="headerlink" title="二、Clone 代码，并在本地进行修改"></a>二、<code>Clone</code> 代码，并在本地进行修改</h2><p>Clone 代码就相对简单很多了，找到 Fork 之后的仓库。我这边对应的就是我 GitHub 中的「JavaCollection」仓库，打开，并点击「code」，弹框选择 「HTTPS」,复制 「HTTPS」下面的地址。需要说明一点：如果你对 「SSH」和「GitHub CLI」不熟悉，就老老实实选择「HTTPS」。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/d3c61600-7248-4c10-be02-f8bb0a09b2f0.png" alt="image.png"></p><p>复制好地址之后，打开<strong>开发者工具</strong>，此处以 IDEA 举例。打开 IDEA，并在首页点击 <code>Get from Version Control</code> ，不同的 IDEA 版本可能名称不一样。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/3b5b086c-ccd2-4dc9-8870-53f0888ae0f9.png" alt="image.png"></p><p>在弹出的对话框中，选择在 <code>Version control</code> 选择 Git，并在 <code>Url</code> 一栏粘贴刚才复制的地址，再点击 <code>Clone</code> 即可</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/94d71270-bf17-4655-82c8-e34d275a0a9c.png" alt="image.png"></p><p>点击 Clone 之后，IDEA 会自动帮你把代码拷贝到本地，拷贝完成之后 IDEA 提示你「是否需要打开它」，选择「Yes」，等待一会，就可以对代码就行操作了。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/e55425a2-2f40-407f-8d8e-c1f85262010b.png" alt="image.png"></p><h2 id="三、Commit-代码，并-Push-本地代码到-GitHub"><a href="#三、Commit-代码，并-Push-本地代码到-GitHub" class="headerlink" title="三、Commit 代码，并 Push 本地代码到 GitHub"></a>三、<code>Commit</code> 代码，并 <code>Push</code> 本地代码到 <code>GitHub</code></h2><p>点击 IDEA 左下角的 Version Control，可看到修改的文件详情，在需要提交的文件处右键，然后点击 <code>Commit</code> ，代码就会先提交到本地仓库</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/64deed58-e000-482f-a9a7-4a34f2a7ccb7.png" alt="image.png"></p><p><code>Commit</code> 代码之后，接下来就要进行 <code>Push</code> 操作，在 IDEA 工具栏中找到「VCS」「Git」「Push」，就可以把本地代码提交到自己的 GitHub 中。接下来可以在 GitHub 中找到对应的代码仓库，查看刚才提交 <code>Push</code> 的结果。</p><h2 id="四、发起-Pull-requests"><a href="#四、发起-Pull-requests" class="headerlink" title="四、发起 Pull requests"></a>四、发起 <code>Pull requests</code></h2><p>在 GitHub 点击上传代码的仓库，就可以看到 <code>Pull requests</code> ，点击它，然后选择要提交的分支，以及他人仓库的分支，点击完成就可以了。</p><p><img src="/../picture/GitHub%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/269c3072-c82c-4bf3-8981-dc5abe3189e8.png" alt="image.png"><br>发起 <code>Pull requests</code> 之后只需要等待开发者查看你的 <code>PR</code>，根据情况判断是否需要，如果通过了，恭喜你成功贡献了一份力量，没有通过也不用气馁，可以看看不通过的原因什么，下次继续努力。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 函数式编程</title>
    <link href="/2021/09/20/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/09/20/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><strong>优点：</strong>减少工作量，减少 Bug，提高效率</p><p>减少工作量：做同样一件事，普通的方法实现，可能需要几十行代码，而函数式编程只需要几行代码</p><p>减少 Bug：代码写的越少，Bug 自然也变的越少</p><p>提高效率：别人还在吭哧坑次的写几十上百行代码时，你已经写完，顺便刷了个知乎</p><h2 id="函数式编程深入浅出"><a href="#函数式编程深入浅出" class="headerlink" title="函数式编程深入浅出"></a>函数式编程深入浅出</h2><p>你可能对我的话不信，那咱们就来看看实际的例子</p><p>假如给定一个用户列表信息，现在要你分别获取<code>id 为偶数的用户</code>、<code>姓周的用户</code>、<code>姓王的用户</code>，你会如何实现这个需求。</p><p>大多数人会写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤 id 为偶数的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithEvenId</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br><br> <span class="hljs-comment">// 过滤姓周的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterZhouUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>)) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br><br> <span class="hljs-comment">// 过滤姓王的用户</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterWangUsers</span><span class="hljs-params">(List&lt;User&gt; users)</span> &#123;<br>     List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (User user : users) &#123;<br>         <span class="hljs-keyword">if</span> (user.name.startsWith(<span class="hljs-string">&quot;王&quot;</span>)) &#123;<br>             result.add(user);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>代码达到了我们需要的效果，但是你仔细观察，会发现重复的代码太多了，不同的地方仅仅是 if 中的条件判断，这个时候就需要思考一下如何简化这些代码。稍微细心的人就会发现，过滤姓张的用户，和过滤姓王的用户可以抽取成一个方法，只需要把姓氏当做参数传给函数就行了，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤指定姓氏的用户</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithLastName</span><span class="hljs-params">(List&lt;User&gt; users,String lastName)</span>&#123;<br>      List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (User user : users) &#123;<br>          <span class="hljs-keyword">if</span> (user.name.startsWith(lastName)) &#123;<br>              result.add(user);<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样的确简化了部分代码，但是仅此而已吗？难道<code>过滤id为偶数的用户</code> 方法，就不能跟其它方法合并了吗？</p><p>这个时候你可能会想，要是可以传条件就好了，这样方法就能根据条件，过滤我们需要的用户信息。的确，这种方法确实可行，那要怎么去实现呢？既然传递的都是自己「实现」的条件，那么很容易想到「接口」这个东西。所以我们可以根据要求写一个接口，并提供一个方法，让其他实现该接口的类，自己定义方法的实现，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users,Condition condition)</span> &#123;<br>    List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-keyword">if</span> (condition.isSatisfied(user)) &#123;<br>            result.add(user);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhouUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WangUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;王&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsersWithEvenId</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSatisfied</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> user.id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用了一个接口，以及三个类，每个类对应不同的实现。编写一个根据条件过滤的方法 <code>filterUsersWithCondition</code>，我们传入接口类，然后进行条件判断。</p><p>但是实际上 Java 已经帮我们定义好了这些通用接口，不用我们再去定义，在 <code>java.util.function</code>包中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><p>他与我们自己定义的 Condition 接口很像，方法都是接收一个参数，返回一个布尔值。因此，我们完全可以把自己定义的接口，替换成官方提供的。这样又减少了一点代码量，以 <code>ZhouUser</code>类举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhouUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Predicate</span> &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(User user)</span> &#123;<br>          <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这个时候我们得 <code>filterUsersWithCondition</code> 方法，更改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users,Predicate&lt;User&gt; predicate)</span> &#123;<br>    List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-keyword">if</span> (predicate.test(user)) &#123;<br>            result.add(user);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，做到这样已经很不错了，但是我们还能精简。每次调用 <code>filterUsersWithCondition</code> 方法的时候，都要传入一个实现类，并且每次有新需求，都要生成一个新类实现 Predicate 接口，这样代码量还是很多。</p><p>我们可以这样，直接使用匿名类完成操作，这样我们就不用频繁的实现接口了。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>filterUsersWithCondition(users, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;User&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(User user)</span> &#123; <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候 IDEA 就会提示你了，按下快捷键 alt + enter 建，将匿名类转化为 Lambda 表达式。于是我们上面的代码就变成这样，代码瞬间简洁了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>filterUsersWithCondition(users, user -&gt; user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>));<br></code></pre></td></tr></table></figure><p>这边简单的介绍下 Lambda 表达式：<code>user -&gt; user.name.startsWith(&quot;周&quot;)</code>它对应的就是过滤姓周用户的匿名内部类 test 方法。<code>-&gt;</code> 左边对应参数，他完整的参数是 <code>(User user)</code>，由于 Lambda 可以通过上下文推断出参数类型，因此我们得式子仅仅指定了参数名<code>user</code>。<code>-&gt;</code> 右边的就是要执行的语句了，遇到多行执行语句需要用 <code>&#123;&#125;</code>括起来，用分号分隔语句。</p><p>Predicate 中的 test 方法，是将一个 User 对象到 boolean 的映射。实际上只要我们写的方法满足<code>object-&gt;boolean</code>，都可以自动转化成一个函数接口。比如我们刚写的 Lambda 表达式 <code>user -&gt; user.name.startsWith(&quot;周&quot;)</code> ，以及我们将要展示的方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        filterUsersWithCondition(users, Main::zhouUser);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">zhouUser</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> user.name.startsWith(<span class="hljs-string">&quot;周&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title function_">filterUsersWithCondition</span><span class="hljs-params">(List&lt;User&gt; users, Predicate&lt;User&gt; predicate)</span> &#123;<br>        List&lt;User&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(user)) &#123;<br>                result.add(user);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们自己编写了一个方法 <code>zhouUser</code>，这个方法也是满足 Object -&gt; boolean  的映射关系，因此他会被转化成相应的函数接口，这时使用方法引用调用这个方法，即可达到相同的目的。方法引用相比 Labmda 表达式的实现，更为清晰易懂，因为有方法名，我们很容易根据方法的名称来了解代码在干什么，对于日常维护开发更为友好。</p><h2 id="Java-中的函数接口"><a href="#Java-中的函数接口" class="headerlink" title="Java 中的函数接口"></a>Java 中的函数接口</h2><p>先说一个结论：<strong>任何只包含一个抽象方法的接口，都可以转化成函数接口</strong>，例如我们刚开始使用的 <code>Condition</code>接口。</p><p>在 Java 中不只有 Predicate，还有很多默认的实现。像，<code>Consumer</code>是 Object-&gt;void 的映射；<code>Supplier</code>是 void-&gt;Object 的映射;<code>ToIntFunction</code> 是 Object-&gt;int 的映射，等等，如图：</p><p><img src="/../picture/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/8360c589-7218-40e8-9bd9-f4f03414de05.png"></p><p>我们可以根据我们得需求使用以上接口，或者自己定义我们所需的接口。</p><h2 id="使用-Comparator-实战"><a href="#使用-Comparator-实战" class="headerlink" title="使用 Comparator 实战"></a>使用 Comparator 实战</h2><p>当我们需要对数据进行比较的时候，就需要 Comparator</p><p>还是上面说到的 User 对象，现在有了新需求，需要对 user 的 id 进行从小到大排序，然后按照年龄从大到小排列。我们可以使用 Collections.sort() 方法，对数据进行排序。可以发现需要传入的参数是一个 Comparator 接口，因此我们可以直接 New 一个 Comparator，并实现他的方法。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">4</span>, <span class="hljs-number">20</span>));<br><br>Collections.sort(users, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User o1, User o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o1.id &lt; o2.id) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.id &gt; o2.id) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Java 8 之后，JDK 为我们提供了更好的方法。在 Comparator 接口中有一个静态方法 comparing()，我们可以查看代码，发现他需要我们传入一个 Function 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">        Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>&#123;<br>    Objects.requireNonNull(keyExtractor);<br>    <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>        (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们传入的参数遵循 Function 接口对应的映射关系就可以了，打开发现 Function 是 T-&gt;R 的映射关系，即我们传入的参数转化成另一种数据类型。因此我们可以写成这样，User 类转化成整形，符合映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users,Comparator.comparing(user -&gt; user.id);<br></code></pre></td></tr></table></figure><p>我们可以使用方法引用替换 Lambda 表达式，getId 方法表面上没有参数，实际上是有一个隐藏的 this，因次该方法引用也符合映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users,Comparator.comparing(User::getId);<br></code></pre></td></tr></table></figure><p>比较了 id 之后我们还需要比较年龄的倒序排列，使用 thenComparing 继续比较，再使用 reversed() 方法将结果倒序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(users, Comparator.comparing(User::getId).thenComparing(User::getAge).reversed());<br></code></pre></td></tr></table></figure><p>这样就完成了我们得需求，一行代码完成了我们得工作，还减少了 bug，头发又可以少掉几根了，真是幸福。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 包管理</title>
    <link href="/2021/08/26/Java%20%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/26/Java%20%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>java 程序的本质就是在拼接命令行，如何拼接的细节，都由 ide 帮我们实现了。假如我们在程序中添加一个包，我们只需要 java -cp 后面补上包的位置，以及这个包依赖的其他包的位置。 当程序中引用的包越来越多时，带来传递性依赖也会越来越多，要在 Java -cp 后面一个个补上包的位置，并且保证不遗漏传递性依赖的包，并且还要保证包不能同名。这将是一比巨大的工作量，费时费力，还容易出错。</p><p>这个时候就需要使用包管理了。它的本质就是告诉JVM如何找到所需的第三⽅类库，以及成功地解决其中的冲突问题。</p><h2 id="JVM-加载包"><a href="#JVM-加载包" class="headerlink" title="JVM 加载包"></a>JVM 加载包</h2><p>首先，JVM 的工作被设计地相当简单：执行一个类的字节码，假如这个过程中碰到了新的类，就去加载它。</p><p>既然碰到新的类就会去加载，那么就存在一个问题：去哪里加载呢？</p><p><strong>类路径（Classpath）</strong></p><p>当 jvm 去找一个新的类时，就会到类路径（Classpath）中挨个去找，碰到 jar 包就会解压缩再去查找。<br>由于类的全限定类名（⽬录层级）唯⼀确定了⼀个类，因此 jvm 可以找到这个类。其中 jar 包本质上就是把许多类放在一起打的压缩包。</p><p><strong>包加载存在的一些问题</strong></p><ul><li><strong>传递性依赖。</strong>简单的解释就是，你依赖的类还依赖了别的类。例如：A -&gt; B -&gt; C，A 依赖 B，B 依赖 C。</li><li>Classpath hell。因为全限定类名是类的唯⼀标识，所以当多个同名类同时出现在Classpath中，就会出现问题。例如：当 classpath 中存在同名的但是不同版本的 jar 包，A-1.0.jar 和 A-1.2.jar。jvm 会根据声明顺序去选择执行，假如 A-1.0.jar 声明在前，jvm 就会加载 A-1.0.jar，而不使用 A-1.2.jar。如果 A-1.0.jar 中是存在安全风险，那么到时候程序运行到安全风险时，就会导致灾难性后果。</li></ul><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><h3 id="Apache-Ant"><a href="#Apache-Ant" class="headerlink" title="Apache Ant"></a>Apache Ant</h3><p>Apache Ant 解决了部分包管理的问题。通过⼿动下载 jar 包，放在⼀个⽬录中。然后写XML配置，指定编译的源代码⽬录、依赖的jar包、输出目录等。</p><p>这样做带来的缺点是什么呢？</p><ul><li>每个人都要自己造一套轮子库</li><li>依赖的第三⽅类库都需要⼿动下载，费时费力。依赖的第三方类库越多，越麻烦。</li><li>没有解决 Classpath hell 问题。即，还是可能存在包同名的问题。</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="Maven-包管理"><a href="#Maven-包管理" class="headerlink" title="Maven 包管理"></a>Maven 包管理</h4><p>Maven 是划时代的包管理工具，但是 Maven 能做的远不止包管理。 </p><p>Maven 的理念是约定优于配置，默认的 Maven 项目结构都是一样的。Maven 具有中央仓库，包都是按照一定约定存储的。Maven 还有本地仓库，默认是位于 <code>~/.m2</code> 。当我们引入一个依赖时，Maven 就会根据填写的信息找到对应的包，并把它下载到本地仓库，下载到本地仓库之后，下次再有相同的包，则直接从本地仓库找。</p><p>Maven 的包按照约定为所有的包编号，方便检索。例如要在项目中引入 fastjson.jar </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.75<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 通过 groupId &#x2F; artifactId &#x2F; version，来定位唯一的包。开发过程中只需要在 pom.xml 文件添加包相应的信息即可。</p><p>其中 version 中的版本 1.2.75 是有一个规约的，1表示主版本号，2表示此版本号，75表示修订号</p><ol><li>主版本号：当你做了不兼容的 API 修改。</li><li>次版本号：当你做了向下兼容的功能性新增。</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><h4 id="Maven-的传递性依赖以及包冲突"><a href="#Maven-的传递性依赖以及包冲突" class="headerlink" title="Maven 的传递性依赖以及包冲突"></a>Maven 的传递性依赖以及包冲突</h4><p><strong>maven 传递性依赖的⾃动管理原则：绝对不允许最终的 classpath 出现同名不同版本的jar包</strong></p><p><strong>maven 解决传递性依赖</strong></p><p>当我们引入相关的包时，maven 会帮我们下载这个包，<strong>并且把他的传递性依赖的包都下载下来。</strong>因此，在 maven 中我们不需要去管理包的传递性依赖问题，maven 都会帮我们处理好。 </p><p><strong>maven 解决传递性依赖带来的包冲突问题</strong></p><p>假设你的项目有以下依赖。A 依赖 C，C 依赖 D 的0.2版本；B 依赖 D 的 0.1版本。<br> <img src="/../picture/Java%E5%8C%85%E7%AE%A1%E7%90%86/90d36004-cdb8-47f4-9707-1c5d3ef77706.png" alt="image.png"></p><p>如果按照图上所示，把所有的包都下载，势必会造成前面的 Classpath hell 问题，因为两个包 D 同名了。首先，maven 会根据包的 groupId 和 artifactId 来判断是否为同一个。存在相同的包 maven 就会帮我们自动解决。</p><p>maven 解决的原则就是：离项目最近的胜出，如果一样近，则靠前声明的胜出。回到图中，D-0.2 离项目的距离是3，而 D-0.1 离项目的距离是2，因此 D-0.2就会被 maven 剔除，classpath 路径中只存在 D-0.1。maven 解决冲突的做法，在大部分情况下是可行的，但也有不行的时候。假设项目中使用了 D-0.2 中的 API，由于 D-0.1 是旧版，没有相同的 API，maven 根据原则，帮我们把 D-0.2 剔除了，这个时候项目启动就会报错了。</p><p><strong>手动解决包冲突</strong></p><p>当遇到上诉情况就需要我们手动来解决冲突问题。</p><ol><li>首先我们要对比冲突包的区别，判断项目实际上所需要的包（maven 中央仓库找到冲突的包，通过查看源代码进行对比）</li><li>确定了所需要的版本之后，可以使用如下方法进行解决<ul><li>方法一：根据 maven 的解决原则，最近的胜出，我们可以直接在项目中引入一个 D-0.2 版本，此时 D-0.2 离项目的距离是1，所以会使用 D-0.2。</li><li>方法二：指定 maven 排除不需要的包，把不需要的依赖排除掉，剩下需要的依赖就可以了。使用exclusions，在 B 的 dependency 中排除掉 D 的依赖。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>**tips: ** 可以使用<code>Maven helper</code> 查看依赖树，也可以通过 <code>mvn dependency:tree</code> 命令查看依赖树。</p><p><strong>依赖的 scope</strong></p><p>我们经常可以在 pom 文件中看到以下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 groupId、artifactId、version 来定位这个包。scope 则是用来声明这个包在项目的作用范围。通常有这三个值<br><code>test</code> 、 <code>compile</code> 、 <code>provided</code> 。test 表示包作用在测试代码中，src&#x2F;test 目录下。compile 作用在源代码和测试代码中，并且编译和运行都有效。procided 作用在代码的编译期间，代码运行期间不生效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行的入门与详解</title>
    <link href="/2021/08/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是命令行"><a href="#什么是命令行" class="headerlink" title="什么是命令行"></a>什么是命令行</h1><p>操作系统都有内核的概念，内核是直接与硬件打交道的。我们通过包裹内核的一层壳（ shell ）来与内核打交道。</p><p><strong>广义的命令行包括一切通过字符终端控制计算机的⽅式</strong></p><ul><li>Windows - cmd&#x2F;PowerShell&#x2F;Git bash </li><li>UNIX&#x2F;Linux系列：sh&#x2F;zsh&#x2F;Terminal, etc.</li></ul><h1 id="为什么需要命令行"><a href="#为什么需要命令行" class="headerlink" title="为什么需要命令行"></a>为什么需要命令行</h1><ul><li>因为基本所有公司的服务器都运⾏在 Linux 上 ，所以不得不用</li><li>将工作自动化（暂时没有接触到的领域）</li><li>相比 GUI，命令行更容易开发维护，bug 更少</li><li>远程连接命令行占用资源远低于 GUI</li><li>命令行上的开发者工具更丰富</li></ul><h1 id="不同平台命令行启动方式"><a href="#不同平台命令行启动方式" class="headerlink" title="不同平台命令行启动方式"></a>不同平台命令行启动方式</h1><ul><li>Windows：cmd&#x2F;PowerShell&#x2F;WSL </li><li>UNIX&#x2F;Linux：⼀开机就是，不⽤找。Mac OS 对应的是终端。</li></ul><h1 id="命令行的全部要素"><a href="#命令行的全部要素" class="headerlink" title="命令行的全部要素"></a>命令行的全部要素</h1><p><strong>命令是由可执行程序和参数组成的。</strong>例如：git add test.txt，git 就是<strong>可执行程序</strong>，git 后面所有的都是<strong>参数，</strong>即 <code>add test.txt</code> 。命令行输入命令，会把参数原封不动地交给可执行程序解释。</p><h2 id="可执行程序（Executable）"><a href="#可执行程序（Executable）" class="headerlink" title="可执行程序（Executable）"></a>可执行程序（Executable）</h2><p>什么样的东西是可执行的呢？在 Windows 和 Linux &#x2F; Unix有着不同的区别</p><ul><li>Windows：只要是 exe &#x2F; bat &#x2F; com 结尾的文件都是可执行文件</li><li>LIunx &#x2F; Unix：文件有 <strong>x 权限</strong>，表示该文件为可执行文件</li></ul><p><strong>可执行程序的位置</strong></p><ul><li>Windows：Path 环境变量或当前⽬录 </li><li>UNIX &#x2F; Linux：PATH 环境变量</li></ul><p><strong>可以在脚本的第一行指定解释器（shebang）</strong>，假设 zzf.sh文件中有如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/env node</span><br>console.log(123)<br></code></pre></td></tr></table></figure><p><code>#!/usr/bin/env node</code> 意思是在 PATH 环境变量找到 node 解释器位置，来解释 zzf.sh 文件。也可以使用 node.exe 文件的绝对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/d/node</span><br>console.log(123)<br></code></pre></td></tr></table></figure><p>从环境变量找解释器和使用绝对路径是等价的，但是一般都是从环境变量去找，更为灵活。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>UNIX 参数的约定</strong></p><ul><li>使用一个 “-“ 后面只能跟一个字符，例如：-a -f  等等。后面跟多个参数的话可以合并，例如：-a -f 合并成 -af</li><li>使用两个 “-“ 后面可以跟一个单词，例如： <code>ls -a</code>  显示所有文件，等价于 <code>ls --all</code></li></ul><p> </p><p>然而，Java 并不鸟 UNIX 参数约定，例如：当我们查看当前 Java 版本，使用命令 <code>java -version</code> ，一个 “-“ 后面跟了一个单词，与 UNIX 参数约定不符</p><p><strong>参数一些注意事项</strong>默认情况下 “$” 符号会进行展开。假设当前目录存在一个 <code>main$A.class</code> 文件，并且 <code>export A=123</code> 设置环境变量 A 为123， 使用 <code>Java main$A</code> 运行该文件，等价于 <code>Java main123</code> 。即，把 $A 替换成 123，如果不进行替换，就要使用单引号包裹起来，即 <code>Java &#39;main$A&#39;</code> 。双引号包裹内容也会进行替换。</p><p><strong>因此得出以下结论</strong></p><ul><li>单引号：不会对引号的内容做处理</li><li>双引号：对引号里的内容替换</li><li>空格：当做参数处理</li></ul><h2 id="环境变量（Environment-variable）"><a href="#环境变量（Environment-variable）" class="headerlink" title="环境变量（Environment variable）"></a>环境变量（Environment variable）</h2><ul><li>进程（Process）<ul><li>进程是计算机程序运⾏的最⼩单位 </li><li>独占⾃⼰的内存空间和⽂件资源</li></ul></li><li>每个进程都和⼀组变量相绑定 <ul><li>传递不同的环境变量可以让程序表现出不同的⾏为 </li><li>CLASSPATH&#x2F;GOPATH</li></ul></li><li>在进程的fork过程中，环境变量可以被完全继承</li><li>所有的操作系统&#x2F;编程语⾔都⽀持环境变量 </li><li>局部和全局的环境变量<ul><li>局部变量：只在当前环境生效</li><li>全局变量：全局生效的变量</li></ul></li></ul><p>我们可以通过 export &#x2F; set 设置环境变量，通过 echo 读取环境变量 。修改全局变量就需要在全部变量文件中修改，不同操作系统对应的文件不同。</p><h2 id="工作目录（Working-directory）"><a href="#工作目录（Working-directory）" class="headerlink" title="工作目录（Working directory）"></a>工作目录（Working directory）</h2><p><strong>工作目录就是输入命令行时，所处的目录即为工作目录。绝对路径是以根目录开头的路径，相对路径是相对于当前目录的路径。</strong></p><h1 id="进程的输入与输出"><a href="#进程的输入与输出" class="headerlink" title="进程的输入与输出"></a>进程的输入与输出</h1><p>标准输⼊ stdin ，进程将从标准输入中得到输入数据。例如使用 <code>rm -rf *</code> 命令，会提示是否确认删除，当我们回复y 的时候，就时一个标准输入。</p><p><strong>输出的重定向</strong>，我们可以使用 “&gt;” 符号来重定向输出，例如在终端输入 <code>date +&quot;%Y-%m-%d %H:%M:%S&quot; &gt; output.txt</code> ，就是将<strong>标准输出</strong>重定向到 output.txt 文件中，若再次运行该命令，会将之前的 output.txt 文件覆盖 。使用 “&gt;&gt;” 可以将标准输出追加到 output.txt 文件中。</p><p><strong>标准输出 stdout</strong> 和<strong>标准错误 stderr <strong>相当于一个进程的两个管道。标准输出对应着文件描述符1，标准错误 对应着文件描述符2。假设我们要将一个</strong>进程的标准输出重定向</strong>到 output.txt 文件中，我们可以使用 <code>命令 &gt; output.txt</code> 或者 <code> 命令 1&gt; output.txt</code> 。同理类推，将<strong>进程的标准错误重定向到</strong> error.txt 文件，可以使用    <code>命令 2&gt; error.txt</code> 。要让标准输出和标准错误都重定向到 output.txt 文件，使用 <code> 命令 &gt; output.txt &gt; 2&gt;&amp;1</code> 。该命令代表的意思是，先将2（标准错误），重定向到1（标准输出），再把结果重定向到 outout.txt 文件。</p><p><strong>&#x2F;dev&#x2F;null</strong> 相当于一个垃圾桶的概念，可以把标准输出或者标准输入重定向到该文件。 <code> 命令 &gt; /dev/null</code> 即把标准输出丢到垃圾桶里，相当于黑洞一般，把标准输出给「吞」了。</p><h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><p>任何一个 UNIX 文件都有9位，分成3组，分别是自己（文件创建者），同用户组的人，不同用户组的人。每一组都有 rwx，r 代表读（read），w 代表写（write），x 代表可执行。</p><p>假设有一个需求，我们要当前文件只能被当前用户读写执行。就需要把自己组的 r 设置为1，w 设置为1，x 设置为1，其他组的 rwx 都设置为0，设置完成后对应的二进制分别是 <code>111 000 000</code> ，对应的十进制就是 <code>700</code> ，因此使用 <code>chmod 700 当前文件</code> 即可赋予当前用户读写执行权限。</p><p>根据上面的结论，我们需要给所有用户可读可写可执行权限，就需要把所有组的 rwx 设置为1，得到的二进制就是 <code>111 111 111</code> ，对应的十进制为 <code>777</code> ，因此 <code>chmod 777 当前文件</code> 表示为所有用户，赋予可读可写可执行权限。</p><h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><ul><li>进⼊⽬录 cd (change directory) </li><li>展示⽂件 ls&#x2F;ll&#x2F;ls -alth (list) </li><li>移动&#x2F;重命名⽂件 mv (move) </li><li>删除⽂件 rm&#x2F;rm -r&#x2F;rm -rf (remove) </li><li>拷⻉⽂件 cp&#x2F;cp -r (copy) </li><li>显示变量 echo </li><li>导出变量 export </li><li>Git系列操作 git pull&#x2F;push&#x2F;add&#x2F;commit&#x2F;…</li><li>新建⽬录 mkdir&#x2F;mkdir -p (make directory) </li><li>当前⽬录 pwd (print working directory) </li><li>显示⽂件 cat (concatenate and print files)</li><li>编辑⽂件 vi</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 依赖与插件解析机制</title>
    <link href="/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/08/26/Maven%20%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>劝退提醒</strong>：不了解 maven 坐标机制，没有使用过 maven 插件，不了解 maven 插件命令的，可以关闭文章了。</p><p>我们经常在项目中引入包，使用 <code>&lt;dependency&gt;</code> 标签，然后填写包的坐标信息， Maven 就可以帮我们引入该 jar 包。当本地存在该 jar 包时，就从本地引入该 jar 包，否则就从远程仓库引入。</p><p>这背后的解析机制是什么呢？</p><h2 id="依赖解析机制"><a href="#依赖解析机制" class="headerlink" title="依赖解析机制"></a>依赖解析机制</h2><p>依赖解析的背后机制可以概括如下：</p><ol><li><p>依赖范围是 <code>system</code>，maven 就会从本地加载该 jar 包，完成构建。</p></li><li><p>正常解析依赖坐标，先去本地仓库找，找到就完成构建。</p></li><li><p>本地找不到，并且显示的指定了版本信息，就去远程仓库中遍历，找到并下载解析。</p></li><li><p>如果依赖的版本信息并没有指定，而是使用 <code>RELEASE</code>或者 <code>LATEST</code>，他会找到远程仓库的<strong>元数据</strong>和本地的元数据进行合并，然后计算出真正的版本号。元数据指的就是仓库中 <code>groupId/artifactId/maven-metadata.xml</code>文件，例如我们打开 guava 包的元数据。元数据位置就在 com.google.guava&#x2F;guava 包下，打开可以看到如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">metadata</span> <span class="hljs-attr">modelVersion</span>=<span class="hljs-string">&quot;1.1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">versioning</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">latest</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">latest</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">release</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">release</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r03<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r05<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r06<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r07<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r08<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>r09<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">versions</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lastUpdated</span>&gt;</span>20210319161151<span class="hljs-tag">&lt;/<span class="hljs-name">lastUpdated</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">versioning</span>&gt;</span><br>&lt;/metadata<br></code></pre></td></tr></table></figure><p> 上面的信息展示了 latest，release 对应的版本号，以及 guava 包的历代版本号，以及最近一次更新时间。例如我们引入 guava，并使用 latest 版本，maven 就会合并元数据，然后计算出 latest 对应的版本号，然后从本地仓库找到改版本的 guava，没有则去远程仓库下载。</p></li><li><p>依赖的版本是 SNAPSHOT，则同样获取远程元数据与本地合并，计算版本信息，获取对应版本的包。</p></li><li><p>如果依赖版本为时间戳的快照版本，就会先转换成非时间戳的快照版本，然后去解析下载。</p></li><li><p>maven 3 中如果不指定 version，则默认解析使用 RELEASE 版本。</p></li></ol><h2 id="插件解析机制"><a href="#插件解析机制" class="headerlink" title="插件解析机制"></a>插件解析机制</h2><p>我们常用的 maven 插件命令都是 <code>mvn dependency:tree</code> <code>mvn flyway:migrate</code>，诸如此类的，他们的格式都是 <code>mvn 插件前缀:目标</code>。</p><p>为了方便用户使用和配置插件，maven 不需要用户提供完整的坐标信息，就能解析得到正确的插件。那么问题来了，maven 是怎么确定插件的坐标和版本的呢？例如 <code>mvn dependency:tree</code> 他执行了什么插件，插件坐标版本信息是什么？</p><p>插件的解析机制和依赖解析机制基本一致，不同的是远程仓库不一样。配置插件的远程仓库地址需要使用 <code>&lt;pluginRepository&gt;</code> 标签配置，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了 <code>&lt;pluginRepositories&gt;</code>和 <code>&lt;pluginRepository&gt;</code>不同，其他的与依赖的仓库配置信息一致。</p><h3 id="默认的-groupId"><a href="#默认的-groupId" class="headerlink" title="默认的 groupId"></a>默认的 groupId</h3><p>在 pom 文件在红配置插件信息的时候，如果插件是 maven 官方的插件（groupId 为 org.apache.maven.plugins），就可以省略 groupId 的配置。如下是官方的 clean 插件配置，没有指定 groupId，但是解析坐标的时候会带上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在插件配置中，不推荐省略 groupId 的写法，但这与我们使用 maven 插件命令有关。</p><h3 id="省略版本信息"><a href="#省略版本信息" class="headerlink" title="省略版本信息"></a>省略版本信息</h3><p>maven 的核心插件都在超级 pom 中显示的声明了具体的版本信息，因此当这些插件未指定版本信息的时候，就会使用超级 pom 中指定的插件版本。</p><p>如果是非核心插件，且未指定版本信息。在 maven2 中默认解析至 latest，maven3 默认解析至 release，具体的解析过程与依赖解析一致，都是根据合并计算元数据，得到具体的版本信息。</p><h3 id="插件前缀解析"><a href="#插件前缀解析" class="headerlink" title="插件前缀解析"></a>插件前缀解析</h3><p>我们使用命令 <code>mvn dependency:tree</code> 插件前缀是 dependency，我们是如何根据这个前缀信息得到该插件的完整坐标呢？</p><p>这就需要结合上面的知识了，首先存在一个保存 groupId 和 artifactId 对应关系的文件 maven-metadata.xml，该文件存在 groupId &#x2F; maven-metadata.xml。由于上面的 dependency 是官方插件，因此 groupId 为 <code>org.apache.maven.plugins</code> ，我们去远程仓库找到该文件，如下图。</p><p><img src="/../picture/Maven%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/91808d7d-667b-4874-bf53-33765521e002.png" alt="image.png"></p><p>我们可以找到插件前缀 dependency 对应的 articfactId 是 <code>maven-dependency-plugin</code>，因此插件的完整坐标可以确定了。</p><p><strong>获取 groupId</strong></p><p>这里还有个问题，因为我们是提前知道 dependency 是官方的插件，可以推出他的 groupId ，但是 maven 是怎么知道它的 groupId 呢？</p><p>maven 的主要插件都在 <code>[https://repo1.maven.org/maven2/org/apache/maven/plugins](https://repo1.maven.org/maven2/org/apache/maven/plugins)</code>和<code>[https://repository.codehaus.org/org/code-haus/mojo](https://repository.codehaus.org/org/code-haus/mojo)</code>下，他们对应的 groupId 分别是 <code>org.apache.maven.plugins</code> 和 <code>org.codehaus.mojo</code>。maven 解析插件的时候就会默认使用这两个 groupId 去匹配，检查 org&#x2F;apache&#x2F;maven&#x2F;plugins&#x2F;maven-metadata.xml，org&#x2F;codehaus.momjo&#x2F;maven-metadata.xml 文件，判断是否有匹配的插件前缀，如果有则获取对应的坐标信息，完成解析。</p><p>倘若想使用的插件是第三方的，就可以通过配置 setting.xml 文件，让 maven 也检查其他 groupId 上的仓库 metadata.xml 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>第三方仓库 groupId<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><p>解析 dependency:tree 命令</p><ol><li><p>先使用默认的和配置的第三方的  groupId 去找到对应的 <code>maven-metadata.xml</code>文件，然后检查是否包含 dependency 前缀信息。</p></li><li><p>包含前缀信息，获取对应 articfactId，不包含则使用下一个 groupId 的 maven-metadata.xml 文件。如果所有都获取不到，则报错。</p></li><li><p>获取到 articfactId 之后根据上面 <a href="#Ueudm">获取版本信息</a>，即可得到完整的坐标，完成解析执行。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2021/08/11/String/"/>
    <url>/2021/08/11/String/</url>
    
    <content type="html"><![CDATA[<p>首先我们要有一个概念，互联网基本上就只干一件事「处理字符串」。我们看的纷繁复杂的网页，都是通过字节传输的，然后经过一个指定的编码转化成人类能看懂的字符串。因此能处理好字符串是 Web 服务器的基本要求，像 Java，PHP，Python，Ruby等。</p><h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p>背过一些八股文面试题的人都知道 String 是不可变的，那么问题来了，「不可变的定义是什么？」，「String 是如何保证不可变的呢？」</p><p><strong>不可变性</strong>，当创建一个<code>String s = &quot;abcd&quot;</code>对象的时候，JVM 的堆内存就生成了一个 String 对象，并且它的值是 abcd，而 s 变量只是指向这个对象。我们说的不可变性指的就是 JVM 生成的对象值不可变，比如刚才的 abcd，创建出来之后它就一直都是 abcd，无法被改变。</p><p>经常使用字符串的人开始疑惑了，那我 <code>String s = &quot;abcdel&quot;</code>不是也可以吗？String 的值不是改变了吗？</p><p>的确，我们是可以给 s 这个变量重新赋值。但是我们给他赋值实际上是 JVM 新创建了一个值为 abcdel 的 String 变量，然后变量 s 从指向值为 abcd 的对象，改为指向值为 abcdel 的对象。原来值为 123 的对象还是存在 JVM 中，并且值并没有改变，只是暂时没有变量指向这个对象罢了。上面的操作，可以用如图所示。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/picture/String/ea0bb048-f46d-4e83-abb9-de31bd9a694d.png" alt="image.png"></h3><p>了解上面的知识后，回到新的问题上来，<strong>String 是如何保证不可变性呢？</strong></p><p>打开 String 的源代码，我们可以发现，String 类以及它的字符数组变量都是被 final 关键词修饰的。这就意味着 String 无法被继承，并且 char[] value 的地址指向无法修改，而且 String 所有的公开 API 都没有修改 char[] value 的方法，这就保证了 String 的不可变性。</p><p><img src="/picture/String/632458ad-4ea5-42bf-b25a-9c0262d646c4.png" alt="image.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>线程安全</strong>，不可变的对象天生就是线程安全的，可以随心所欲的在线程之间传递。</p><p><strong>存储安全，</strong>为什么说是存储安全呢？因为遵守了 hashCode 的约定。</p><p>正是因为 Stirng 的不可变性，才能实现存储安全。我们可以想象一下有一个 <code>Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</code>，假如 String 是可变的话，那么就违反了 hashCode 的约定，想了解 hashCode 的相关约定<a href="https://www.yuque.com/alipayygdprovgrb/uc535m/mdqx4t">访问这里</a> 。</p><p>如图所示，有三个字符串 “a”，”c”，通过计算分别得到了对应的 hashCode。如果 String 是可变的行不行呢？我们可以通过反证法来证明。现在假如 String 是可变的，那么当字符串从 a 变成了 c（即 <code>String a = &quot;a&quot; 到 a = &quot;c&quot;</code> ），他的 hashCode 要不要改变呢？分两种情况。</p><p><img src="/picture/String/1304755d-ad8a-4838-8262-6e408d0c7787.png" alt="image.png"></p><p>如果<strong>不改变 hashCode</strong>，那就违反了 hashCode  的第二条约定「两个对象 equals 方法为 true，则生成的 hashCode 相等」。显然 <code>a.equals(c)</code> 为true，按照约定 a 和 c 的 hashCode 应该相等。但我们的前提是 a 的 hashCode 不改变，因此 a 和 c 的 hashCode 并不相等，前后矛盾。</p><p>如果<strong>改变 hashCode</strong> ，那么就违反了 hashCode 的第一条约定「两个对象相等，hashCode 也相等」。例如我们通过如下代码让 a 和 c 为同一个对象，此时的 a &#x3D;&#x3D; c。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>如果此时 a 改变了值，hashCode 也会跟着变化。但是 a &#x3D;&#x3D; c 依然为 true，因为他们所引用的内存地址都是相同的。hashCode 规定对象相等返回相同的 hashCode ，而我们的前提是值改变，hashCode 改变，也是前后矛盾。</p><p>通过反证法，证明了 String 必须是不可变的，才能达到存储安全的目的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每当想修改字符串的时候，都必须创建新的对象来维持它的不可变性。比如下面这个循环，循环 10 次，就创建了 10 个对象，当循环次数上升到一定程度，就会给内存管理带来巨大的压力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text + i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当我们想创建值相同的两个 String 对象，有以下三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>我们分别用 &#x3D;&#x3D; 和 equals 方法来判断 a，b是否相等，三种方式输出的结果分别会是什么呢？</p><p>方法一，a，b 的值都是 “123”，因此很简单，<code>a.equals(b)</code>肯定为 true，那么 <code>a == b</code> 呢？答案是 true。因为有「字符串常量池」的存在，当 a 创建出来，字符串常量池创建 “123” 这个字符串常量，当 b 赋值的时候，发现字符串常量池中已经有相同的对象，因此直接让 b 指向这个对象，此时 a 和 b 都指向同一个对象。如图</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/picture/String/990942c9-60db-42ef-99c4-370f76819ce7.png" alt="image.png"></h3><p>方法二，a 和 b 都是通过 new 方法，各自声明了一个值为 “123” 的对象，因此这是两个不同的对象。所以，a &#x3D;&#x3D; b 为 false，a.equals(b) 为 true。此时的 a 和 b 是指向不同的对象的，虽然他们的值都是 123。</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/picture/String/d40d7eb9-b7c9-4f13-8720-de56aa0a2859.png" alt="image.png"></h3><p>方法三，a 赋值 b，把 a 的地址指向给 b一份。因此，a，b 两个变量都是引用同一个对象，因此 a&#x3D;&#x3D;b 为 true，a.equals(b) 也为 true。图中就是 a 指向的内存地址是 0x45，然后通过 <code>String b = a</code> b 得到 a 传来的地址，所以也指向 0x45 这个内存。</p><p><img src="/picture/String/2bb22221-4e5c-47cd-a667-e5f2eeec841e.png" alt="image.png"></p><h3 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h3><p>虽然 String 是不可变的，但是在实际生产中我们还是需要可变字符串，这要怎么解决呢？就拿上面那段循环代码来说，每次都要创建一个新的变量，循环次数多了必然占用过多内存。**StringBuilder **就是个可变字符串，因此我们可以使用 StringBuilder 来改进这段代码，这样就避免了创建多个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    text = text.append(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuffer 也是可变字符串，与 StringBuilder 的区别是：StringBuilder 线程不安全，但是速度快；StringBuffer 线程安全，速度相对较慢。因此，要根据实际生产环境，选择合适的类，大多数情况优先使用 StringBuilder。</p><p>String，StringBuffer 和 StringBuilder 更多 API，请参考 Java 官方文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常体系</title>
    <link href="/2021/05/27/Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <url>/2021/05/27/Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，离开方法的手段可以 靠 return 方法返回，而<strong>异常是 return 方法之外，离开方法的手段</strong>。</p><p>在实际工作中，经常会遇到空指针、找不到、文件找不到，等等不计其数的异常情况。那么 Java 中如何处理这些异常呢？</p><h2 id="try-x2F-catch-x2F-finally"><a href="#try-x2F-catch-x2F-finally" class="headerlink" title="try &#x2F; catch &#x2F; finally"></a>try &#x2F; catch &#x2F; finally</h2><p>当对一个文件进行写入操作的时候，所使用的 IDE 就会提醒，可能存在异常，需要处理。于是我们按照 IDE 的提示，编写了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\1.txt&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>     &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>代码主要分成两部分：try 包裹的部分，以及 catch 包裹部分，其中 catch 专门用来捕获异常。</p><p>其中 try 包裹的，表示可能运行会出错的代码。上面的代码通过 File，构建一个输出流，由于 File 对应的文件不一定存在，导致构建输出流失败，出现异常。因此，构建输出流的代码就要放到 try 中包裹起来。</p><p>catch 包裹的代码，就是对异常进行处理的流程。上面的代码是将错误信息打印到<strong>标准错误流</strong>中。</p><p>一般异常处理使用 try-catch 语句就足够了，但有遇到加载文件资源的情况，使用完之后就需要及时关闭。也许你会想把关闭资源操作放在 try-catch 语句之后，这也是可以的。但是，一旦 try-catch 中有return 操作，导致代码无法往下执行，关闭资源也就失效了。</p><p><code>finally</code>就是解决这个问题的，无论 try-catch 中如何返回，如何调用，它包裹的代码块都会执行。在 catch 语句后加上 finally，以及包裹的代码，这样就完成了一套标准的异常处理流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">//执行资源清理操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Tips</strong>：如果 try 中可能存在多种类型异常，我们就需要多个 catch 来捕获他们。</p><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>在上面的代码中提到资源清理操作，在生产过程中，可能不止一个资源需要清理，我们需要进行多个资源关闭操作，难免会忘记对些资源清理。因此，在 Java 7 中就引入了 <code>try-with-resources</code>这个语法糖。</p><p>原先我们关闭资源操作写在 finally 中，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            os.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在我们把 <code>OutputStream os = new FileOutputStream(file)</code>声明在 try 后面的括号里，声明在里面的东西它会帮我们自动关闭，因此 <code>finally</code> 语句也不用写了。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file)) &#123;<br><br>       &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           e.printStackTrace();<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>那么问题来了，什么类型的资源会自动关闭呢 ？</p><p>答案就是<strong>所有实现了</strong> <code>AutoCloseable</code> <strong>这个接口的类</strong>，都能被自动关闭。比如上面的 <code>FileOutputStream</code>就实现了这个接口。当然智能的 IDE 在我们写 try-catch 的时候都会 给与提示，告诉你可以转成 try-catch-resources模式 </p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>上面使用 try-catch 捕获异常，但实际生产环境中也需要抛出异常，不在当前方法处理。手动抛出异常，需要用到关键字 <code>throw</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br> &#125;<br></code></pre></td></tr></table></figure><p>上面代码抛出了一个异常，但没有使用 try-catch 捕获处理。仔细观察的话，你会发现 openFile 方法后面多出了<code>throws Exception</code>，它的意思声明 openFile 方法可能会抛出异常。</p><p>那为什么要声明异常呢？直接抛出异常不行吗？</p><p>这就源于 Java 的「保护机制」，如果你的方法中可能存在异常，要么使用 try-catch 将它捕获处理，要么就使用 throws 给当前方法声明异常。任何调用了声明异常的方法，都需要处理传过来的异常，与前面一样，要么 try-catch，要么继续声明异常等待其他方法调用处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       A();<br>   &#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，B 调用 A 方法，A 方法没有 try-catch，而是使用 throws 声明异常。因此，B 方法就有两种选择，要么 try-catch 处理 A 抛出的异常，要么选择像 A 一样，声明一个异常继续向上抛出。显然 B 是同 A 一样，选择声明异常向上抛出，当其他方法调用 B 方法，也会面临 B 方法的两种选择。如果一直向上抛异常，而不使用 try-catch 处理，那么抛出的异常会击穿所有的栈帧，直到有方法将它 catch 住。</p><p><strong>Tips：throw 是抛出一个异常，而 throws 则是声明方法可能要抛出的异常</strong>，切勿混淆。</p><h2 id="Java-异常体系"><a href="#Java-异常体系" class="headerlink" title="Java 异常体系"></a>Java 异常体系</h2><ul><li>Throwable - 可以被抛出的东⻄（有毒）<ul><li>Exception - checked execption（受检异常，有毒，代表⼀种预料之中的异常）<ul><li>RuntimeException （运⾏时异常，⽆毒，代表⼀种预料之外的异常，因此不需要声明）</li></ul></li><li>Error （错误，无毒）</li></ul></li><li>catch 的级联与合并</li></ul><p>Throwable 是所有 Exception 和 Error 的父类，只要是 Throwable 类型就可以使用 throw 抛出。由于 Error 和 Exception 是他的子类，因此也能被抛出。</p><p>上面的继承体系中提到 「有毒」和「无毒」的概念，有毒指的是方法会<strong>传染</strong>，而无毒不会。「有毒」同前面的 A 方法和 B 方法一样，任何声明了有毒类型的方法，被调用之后，需要再次声明或者自己处理。任何声明了「无毒」类型的方法，被调用之后方法中无需做任何处理。「有毒」的代码实例，参考「抛出异常」章节的 A 和 B 方法。下面展示「无毒」的类型代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>    A();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们抛出了一个「无毒」类型异常 <code>RuntimeException</code>，当 B 方法调用 A 方法的时候，无需 try-catch，也无需声明异常。</p><p>这就是「有毒」和「无毒」的区别，它们有专业的术语 <code>checked</code>和<code>unchecked</code>，表示「受检」和「非受检」。「受检」表示写的代码会被检查，IDE 一般都会提示你做相应的处理。「非受检」表示写的代码不会被检查，无需做处理。</p><p>Exception 是预料之内异常，正因为在预料之内，所以 IDE 才会提示我们去处理这个异常。常见的有 <code>IOException</code>、<code>FileNotFonudException</code> 。RuntimeException 预料之外的异常，也正因为预料之外，因此 IDE 并不会对抛出的异常进行检验，因为根本无法检验。常见的有 <code>NullPointerException</code>，即空指针异常。</p><p>Error 代表一种严重的错误，他与 Exception 的区别是，前者代表不能恢复的异常，后面代表可以恢复的异常。大多数情况下，Error 代表一种不正常的情况，像内存错误（OutOfMemoryError）等。而像网络超时重连就是可恢复异常的表现。</p><p><strong>catch 的级联与合并</strong></p><p>前面我们提到过，方法中存在多个异常，就需要多个 catch 来处理，如下分别对几种不同类型的异常进行处理，进来的异常会从上到下一次比对，进入到对应的 catch 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<br><br>    &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>但上面代码存在一个问题，Exception 下面的 catch 都不会执行。因为 Exception 是他们的父类，所以每次进来都是第一个 catch 被执行，所以我们应该调整顺序从小到大排列，这样才能根据不同异常类型，做不同处理，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (EOFException e)&#123;<br><br>      &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>      &#125;<br></code></pre></td></tr></table></figure><p>在 Java 7 之后引用了新的语法，对于处理方法完全一致的异常可以进行合并。如下，都是将错误信息打印到标准错误流中，因此我们可以对它进行合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>     &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125; <span class="hljs-keyword">catch</span> (EOFException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br></code></pre></td></tr></table></figure><p>合并之后我们的代码就会变成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException | EOFException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="异常的一些原则"><a href="#异常的一些原则" class="headerlink" title="异常的一些原则"></a>异常的一些原则</h2><h3 id="抛出原则"><a href="#抛出原则" class="headerlink" title="抛出原则"></a>抛出原则</h3><ul><li><p>能⽤ if &#x2F; else处理的，不要使⽤异常</p><ul><li>无法保证抓出的异常是你想抓住的</li><li>相比 if 判断，异常的创建是非常昂贵的操作</li></ul></li><li><p>尽早抛出异常</p></li><li><p>异常要准确、带有详细信息</p></li><li><p>抛出异常也⽐悄悄地执⾏错误的逻辑强的多</p></li></ul><h3 id="处理原则"><a href="#处理原则" class="headerlink" title="处理原则"></a>处理原则</h3><ul><li><p>本⽅法是否有责任处理这个异常？</p><ul><li>不要处理不归⾃⼰管的异常</li></ul></li><li><p>本⽅法是否有能⼒处理这个异常？</p><ul><li>如果⾃⼰⽆法处理，就抛出</li></ul></li><li><p>如⾮万分必要，不要忽略异常</p></li></ul><h3 id="使⽤-JDK-内置的异常"><a href="#使⽤-JDK-内置的异常" class="headerlink" title="使⽤ JDK 内置的异常"></a>使⽤ JDK 内置的异常</h3><ul><li>NullPointerException</li><li>ClassNotFoundException&#x2F;NoClassDefFoundError</li><li>IllegalStateException</li><li>IllegalArgumentException</li><li>IllegalAccessException</li><li>ClassCastException</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识多线程</title>
    <link href="/2021/05/12/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/12/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在编程学习中，我们都要接触到多线程，多线程会帮系统性能带来很大提升，但是这种提升是风险与收益并存的。因此，学习并掌握多线程原理至关重要。</p><h2 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h2><p>既然有多线程，那肯定是有单线程的。那单线程是什么呢？单线程就是在特定时间系统只做一件事，这就和人一样只能「一心一意」，不能「三心二意」。</p><p>平时开发中跑的 Java 程序大多都是单应用，对于一些没有什么访问量的系统来说，能勉强支撑。反之，访问量较大的话，一个线程难以处理，很影响用户的体验。就像一片麦子一个人割，和10个人一起割时间完全不同的。因此，我们就需要用到多线程来解决性能问题。</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><p>在 Java 设计之初，就考虑到了线程，因此「多线程」在 Java 中是提供了语言级别的支持。在 Java 中使用多线程也很方便。创建线程最简单的方法就是使用 <code>new Thread()</code>，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wheatHarvest</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始割麦子&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hoeing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始锄地&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面创建两个线程，一个给他 <code>wheatHarvest()</code>割麦子的任务，另一个给他 <code>hoeing()</code>锄地的任务。创建了两个线程之后，这两件事是同时执行的，并不会说非要割完麦子，才去锄地。但上面只是创建了线程，分配了要执行的任务，线程并没有执行，要让线程执行必须调用线程的 <code>start()</code>方法，线程才会执行。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).start();<br></code></pre></td></tr></table></figure><h3 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start 和 run 的区别"></a>start 和 run 的区别</h3><p>刚开始学习多线程的时候经常将这两个方法搞混，现在重新复习一下。</p><p><strong>start 方法就是让线程开始执行，而 run 是要等待线程执行完才往下执行。</strong>如下，start 方法可以让割麦子和锄地同时运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).start();<br></code></pre></td></tr></table></figure><p>而 run 方法则是，先割麦子，等麦子割完了，然后再去锄地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::wheatHarvest).run();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::hoeing).run();<br></code></pre></td></tr></table></figure><p>在这个方法上实现中，run 方法和我们的单线程基本没区别，而且还额外增加了线程的开销。</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>既然多线程能给系统性能带来提升，那我们就可以无脑使用吗？答案肯定不是的。既然享受了多线程给我们带来性能上的提升，同时我们也要承担多线程带来的安全问题。</p><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>多线程问题的来源就是，所有被线程共享的变量。当多个线程去操作一个共享变量的时候，线程安全问题就会出现。我们看如下代码，我们使用多线程操作，把共享变量 i 自增1，把结果打印看看会发生什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码，肯定会有人认为程序会按顺序输出 1~100，实际上不是如此。你可以把代码复制到自己的环境中运行，得出的结果可能会出乎你的意料，输出的顺序都乱了，并且可能会出现重复输出。为什么会出现这种情况呢？这是因为 <code>i++</code>操作并非是一个<strong>原子操作</strong></p><p>那什么是原子操作呢？原子操作就是一个不可分割的操作，之所以称作「原子操作」，我猜想和高中学的化学有关，原子是不可再分割的粒子，因此计算机就引用了这一概念。<strong>在多线程中，一个事情在某一时刻只能被一个线程操作，称作原子操作</strong></p><p>回到刚才的 <code>i++</code>操作，表面上我们以为是一步操作，实际上它包含了三个步骤：第一步，取 i 的值。第二步，把 i 的值加 1。第三步，把修改后的值写回 i。</p><p>我们使用两个线程来举例，线程1，线程2。线程1先执行，执行到 i ++的第二步操作，先取 i 的值，取到 i 的值为 0，然后把值加1，这个时候值变为 2，但是请注意，这个值并没有写回 i 中。这时，线程2开始执行了，它把 i++ 操作执行完了。由于线程1并没有把值写回 i 中，因此线程2 取到 i 的值依然为 0，把值加 1，写回到 i 中，完成 i++ 操作，并执行输出语句，打印 i 的值为1，到此线程2完成了。此时线程1继续执行刚才未完成的步骤，把值写回到 i 中，刚才线程1计算的值为1，因此把 1 写回到 i 中，完成 i++操作，打印 i 的值仍然为1。经过上面的操作，会发现 i 被重复写入了，因此我们无法保证输出的结果是 1~100。</p><p><strong>你可能会有疑问，为什么线程1执行的好好的，线程2突然就插一脚呢？</strong></p><p>这是因为，在微观上（cpu 眼中），<strong>多线程问题来源就是 cpu 的上下文切换，每个线程都会占用固定的时间周期，超过时间换线程执行。</strong>上面的例子就刚好是 cpu 的上下文切换，导致了1 这个值重复写入到 i 中。</p><p>我们打开 QQ，打开微信，打开浏览器，我们都认为他们是在同时运行的。但实际上都是 cpu 在进行切换，一会切换到微信，一会切换到浏览器，一会到 QQ，由于这个速度很快，我们就主观的认为他们是在同时运行的。多线程也是如此。</p><h3 id="线程不安全的表现（死循环，死锁，哲学家用餐）"><a href="#线程不安全的表现（死循环，死锁，哲学家用餐）" class="headerlink" title="线程不安全的表现（死循环，死锁，哲学家用餐）"></a>线程不安全的表现（死循环，死锁，哲学家用餐）</h3><blockquote><p>著名的 HashMap 的死循环问题可以点击该<a href="https://coolshell.cn/articles/9606.html">链接</a>，了解详情。</p></blockquote><h4 id="死锁详解"><a href="#死锁详解" class="headerlink" title="死锁详解"></a>死锁详解</h4><p>以下是一个简单的死锁 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread2</span>().start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;拿到lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;拿到lock2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上这段代码运行之后，控制台并没有输出，但是程序还在一直执行。代码最初声明了两把锁 lock1 和 lock2，使用synchronized 关键字，去获取锁。例如 <code>synchronized(lock1)</code>表示，需要拿到 lock1 才会执行后面的代码块，执行完<code>&#123;&#125;</code>包裹的代码块，锁才会释放。需要注意的是，<strong>一把锁同时只能有一个线程拿到</strong>。</p><p>因此上面的程序执行流程是，主线程开辟了两个线程，Thread1 和 Thread2，并开始执行。其中 Thread1 需要先获取 lock1，获取之后线程休眠 500ms，然后再去获取 lock2。Thread2 则是先去拿到 lock2，休眠 100ms，然后再去拿 lock1。当 Thread1 去拿 lock2 时，发现 lock2 被拿了，于是 Thread1 等待；Thread2 准备去拿 lock1 的时候发现，lock1 被拿走了，于是 Thread2 等待。Thread1 和 Thread2 都在等待彼此释放自己需要的锁，于是产生了死锁等待。</p><h4 id="简单的死锁排查"><a href="#简单的死锁排查" class="headerlink" title="简单的死锁排查"></a>简单的死锁排查</h4><p>既然死锁了，我们就要需要先拿到死锁的进程 id</p><p>在 Linux 中使用 <code>ps aux | grep java</code>，列出所有 java 进程的 id。或者使用 java 自带的 <code>jps</code> 命令，列出所有 java 进程。</p><p>之后使用 jstack 命令打印进程的栈信息，通过输出的栈信息来排查死锁。</p><blockquote><p>一个经典的多线程问题<a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin">哲学家用餐</a></p></blockquote><p><strong>预防死锁产生的原则：所有的线程按照相同的顺序获取资源的锁。</strong>上面的例子 Thread1 和 Thread2 获取锁的顺序不不一致，Thread1 先拿 lock1，Thread2 先拿 lock2。假如两个线程都先去拿 lock1 或者 lock2，那就不会产生死锁了。</p><h2 id="实现线程安全的基本手段"><a href="#实现线程安全的基本手段" class="headerlink" title="实现线程安全的基本手段"></a>实现线程安全的基本手段</h2><p>为了规避和解决线程带来的安全问题，我们可以采取一些措施</p><h3 id="使用不可变类"><a href="#使用不可变类" class="headerlink" title="使用不可变类"></a>使用不可变类</h3><p>使用 Integer &#x2F; String 这些不可变类。</p><h3 id="使用-synchronized-同步块"><a href="#使用-synchronized-同步块" class="headerlink" title="使用 synchronized 同步块"></a>使用 synchronized 同步块</h3><p><strong>方法一：</strong>synchronized（一个对象）把这个对象当成锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>            i++;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是上面的代码，我们把声明了一个锁，并在 <code>modifySharedVariable</code>方法体中使用 <code>synchronized</code>关键字。这样线程每次执行这个方法的时候，都会先去获取 lock1，当代码块中的代码执行后，lock1 被释放，其他的线程才能继续拿 lock1 去执行。</p><p><strong>方法二：</strong>static synchronized 方法，把 Class 对象当成锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次不声明锁，而是直接在 <code>modifySharedVariable</code>方法上使用 <code>synchronized</code>关键字。在 static 方法上使用 synchronized，实际上是把这个类的 Class 对象当成锁。因此每次访问这个方法都要去拿到 Class 对象，也保证了 i++ 顺序执行。</p><p><strong>方法三：</strong>实例的 synchronized 方法把该类的实例当成锁。（调用的对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        System.out.println(i);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 synchronized 声明在普通的方法上，实际上是把调用的对象当成锁。上面的代码是通过 Demo 类的一个实例 object 来调用 modifySharedVariable 方法的。因此，object 就被当成锁，也保证了 i++ 顺序执行。上面的代码也可以改成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            i++;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接用 <code>synchronized (this)</code>，这与 synchronized 声明在实例方法，功能是等价的。</p><h3 id="使用-Collections-工具类"><a href="#使用-Collections-工具类" class="headerlink" title="使用 Collections 工具类"></a>使用 Collections 工具类</h3><p>我们可以使用 Java 给我们提供的 Collection 的工具类，把不安全的 Collection 变成安线程全的。像 Collections.<em>synchronizedList</em>()，Collections.<em>synchronizedSet</em>() 等等</p><p>例如将普通的 Map 变成线程安全的 Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><h3 id="使用-JUC（java-util-concurrent）-包"><a href="#使用-JUC（java-util-concurrent）-包" class="headerlink" title="使用 JUC（java.util.concurrent） 包"></a>使用 JUC（java.util.concurrent） 包</h3><p>juc 包提供了很多线程安全的类，遇到线程安全问题，我们都可以把不是线程安全的类，换成线程安全的。</p><p><strong>原子操作类：AtomicInteger、AtomicBoolean..，</strong>之前的我们得 i++ 操作不是原子的，可以使用原子操作类 AtomicInteger，来进行替换。使用 AtomicInteger 的 <code>incrementAndGet</code>方法，就可以实现原子自增1的操作。</p><p><strong>线程安全集合：</strong>ConcurrentHashMap，ConcurrentLinkedQueue 等。在任何使用 HashMap 有线程安全问题的地方，都可以无脑使用ConcurrentHashMap 替换</p><h3 id="ReentrantLock-（可重入锁）"><a href="#ReentrantLock-（可重入锁）" class="headerlink" title="ReentrantLock （可重入锁）"></a>ReentrantLock （可重入锁）</h3><p>ReentrantLock 所做的事情和 synchronized 几乎一样。</p><p><strong>区别在于 ReentrantLock 可以自己定义加锁和解锁时机。</strong>使用 synchronized 关键字，执行完代码块中的代码，锁就会释放，但是有的时候我们需要在其他地方释放锁，而不是执行完就释放。因此可以使用 ReentrantLock 加锁，在适当的时机解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(object::modifySharedVariable).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        reentrantLock.lock();<br>        i++;<br>        reentrantLock.unlock();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是之前的例子，如果你对输出结果并不关心的话，进入到 <code>modifySharedVariable</code>方法后，先使用 reentrantLock.lock() 获取锁，等 i++ 操作结束之后，使用 reentrantLock.unLock() 释放锁。reentrantLock 获取锁和释放锁的操作时机，都可以根据实际情况自己定义。</p><p><strong>Tips：可重入锁相关概念。</strong>如下 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        object.a();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        b();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>a 和 b 方法都使用 synchronized 声明了，主线程调用声明了一个实例调用 a 方法。根据前面学的知识，调用 a 方法需要拿到实例锁，然后执行 a 方法。a 方法中又调用了 b 方法，b 方法也需要拿到实例锁，但是因为 a 已经拿到了实例锁，并且 synchronized 也是可重入锁，所以调用 a 方法中调用 b 方法无需再去获取实例锁，这就是可重入锁的概念。</p><blockquote><p>可以点击查看 StackOverflow 上的大牛对于可重入锁的概念的理解<a href="https://stackoverflow.com/questions/16504231/what-is-the-meaning-of-reentrantlock-in-java/16504266#16504266">链接</a></p></blockquote><h2 id="Object-类里的线程方法"><a href="#Object-类里的线程方法" class="headerlink" title="Object 类里的线程方法"></a>Object 类里的线程方法</h2><p>说方法之前，了解下 Java 线程中的 6 种状态</p><ol><li><strong>初始（NEW），</strong>创建一个线程对象，但没有调用 start 方法</li><li><strong>运行（RUNNABLE），</strong>开始执行操作（得到 CPU 使用权）</li><li><strong>阻塞（BLOCKED），</strong>线程阻塞与锁</li><li><strong>等待（WAITING），</strong>需要其他线程唤醒，或中断</li><li><strong>超时等待（TIMED_WAITING），</strong>可以指定时间后，自行返回</li><li><strong>终止（TERMINATED），</strong>线程执行完毕</li></ol><p>使用代码解释这几个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Demo::modifySharedVariable).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifySharedVariable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            i++;<br>            System.out.println(i);<br>            lock.wait();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 new 一个线程的时候就是<strong>初始状态，</strong>调用了 start 方法，线程进入<strong>运行状态</strong>。假如第一个线程更快一步拿到 lock，这时其它两个线程就处于<strong>阻塞状态，</strong>当 lock 调用 wait() 方法，拿到 lock 的线程就进入<strong>等待状态，</strong>然后释放 lock，当线程方法执行完之后<strong>，</strong>线程进入<strong>终止状态</strong></p><p><strong>wait() 方法</strong></p><p>让当前线程进入<strong>等待状态</strong>。调用 wait 方法之前，必须先拿到锁。当调用 wait 方法之后，拿到的锁也就会释放。</p><p><strong>notify()</strong></p><p>随机唤醒一个处于等待状态的线程。</p><p><strong>notifyAll()</strong></p><p>唤醒所有处于等待状态的线程。</p><blockquote><p>实现生产者消费者模型 <a href="https://github.com/greek-zzf/my-demo/tree/main/example/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">demo</a>，可点击查看。</p></blockquote><h2 id="线程池与-Callable-x2F-Future"><a href="#线程池与-Callable-x2F-Future" class="headerlink" title="线程池与 Callable &#x2F; Future"></a>线程池与 Callable &#x2F; Future</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>在前面提到，我们每次使用线程都要先创建一个线程，然后使用给他分配任务，最后调用他的 start 方法执行这个任务。上面的步骤看起来没多大问题，仔细想想看，要是任务一多，每次分配任务的时候都要创建一个新的线程，这个创建线程的<strong>花销</strong>在 Java 世界中是很「昂贵的」。</p><p>类比到生活中，公司每次新接一个项目都去招一些人，做完项目就炒了，然后下次又来一个新的项目，又要去招人，这对于 HR 来说很麻烦。市面上的策略大多都是，招一群有潜力的人才，然后公司培养，有项目来就参与项目开发，下次再遇到新项目还是用之前招的人，这样就减少了公司频繁找人的开销。</p><p><strong>线程池就是预先定义好若干个线程，每次需要线程的时候就去调用，避免了每次创建线程的开销</strong>，这与公司找人的策略是一样的。</p><h3 id="定义线程池"><a href="#定义线程池" class="headerlink" title="定义线程池"></a>定义线程池</h3><p>使用 Executors 类去创建相应的线程池，并且可以配置线程的信息，使用 <code>newFixedThreadPool</code>方法，创建固定数量的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="Runable-与-Callable"><a href="#Runable-与-Callable" class="headerlink" title="Runable 与 Callable"></a>Runable 与 Callable</h3><p>在线程池中，都是使用 submit 方法提交并执行任务。使用 submit 方法的时候可以发现，它接收两个不同类型的参数。一个是与之前多线程相同的参数 Runable，而另一个则是 Callable。通过查看两者源代码可以发现，前者是没有返回值的，而 Callable 则有返回值。</p><p><img src="/../picture/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/60ed335c-4bda-4b0b-9b00-7aa0ae60dbe3.png" alt="image.png"></p><p><img src="/../picture/%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/c8717165-05fe-4a6f-b7da-95f2d9ca2265.png" alt="image.png"></p><p>我们可以发现 submit 方法返回了一个 Future 对象，Future 泛型的值与 Callable 里 call 方法返回的值是一样的。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><strong>Future 表示异步计算的结果，也可以理解未来返回的结果。</strong>例如：我们让一个工人去割麦子，他去执行之后，我们只需要看看仓库是否增加了这么多麦子即可。工人割麦子的时候，我们可以去干其他事情，只需最后看结果就行。这个 Future 就是工人割的麦子总量。</p><p>Future 的常用 API</p><ul><li>get() 方法即可拿到返回的数据（拿到麦子）</li><li>get(long timeout, TimeUnit unit) 给定等待时间，拿到结果（在规定时间内，检查割了多少麦子）</li><li>cancel() 方法取消当前线程的任务（不让工人割麦子）</li><li>isCancelled() 方法判断当前线程是否在正常结束之前被取消（不让工人割麦子之后，检查麦子是否割完）</li><li>isDone() 判断当前线程是否执行完成（检查麦子是否割完）</li></ul><h3 id="使用多线程实现-Word-Count"><a href="#使用多线程实现-Word-Count" class="headerlink" title="使用多线程实现 Word Count"></a>使用多线程实现 Word Count</h3><p>WordCount 就是给定一段或者多段文本（假设每个单词之间都是用空格分隔），记录每个单词出现的次数。</p><p><strong>实现思路</strong>：可以定义一个线程池，线程池中线程的数量可以根据参数传递。每个线程的任务就是读取文件的一行，然后统计该行每个单词出现的次数。最后把每个线程执行的结果汇总，这样就完成了。</p><p>先把整个思路的代码写好，通过参数 <code>threadNum</code>定义了线程池中线程的数量。使用 Map&lt;String,Integer&gt; 记录单词出现的次数，Future&lt;Map&lt;String, Integer&gt;&gt; 表示线程返回的结果， List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; 就表示多个线程返回的集合。</p><p>由于有多个文件，因此使用 for 循环对每个文件都要进行统计操作。<code>threadPool.submit(() -&gt; workJob(file))</code> 提交了任务并执行，任务就是 <code>workJob</code>，即统计一行，单词出现的次数，返回的结果是<code>Future&lt;Map&lt;String,Integer&gt;&gt;</code>，再用刚才定义好的集合 futures，把所有线程返回的结果收集起来。</p><p>futures 收集完成后，开始遍历这个集合，把线程返回的结果进行统计合并，使用 <code>mergeWorkResultIntoFileResult</code>得到一个最终的结果，然后把最终的结果返回，程序执行结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span> threadNum, List&lt;File&gt; files)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadNum);<br><br>        List&lt;Future&lt;Map&lt;String, Integer&gt;&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            futures.add(threadPool.submit(() -&gt; workJob(file)));<br>        &#125;<br><br>        Map&lt;String, Integer&gt; finalResult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Future&lt;Map&lt;String, Integer&gt;&gt; workResult : futures) &#123;<br>            mergeWorkResultIntoFileResult(workResult.get(), finalResult);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> finalResult;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来是具体的方法实现，首先是 workJob() 方法。统计一行文本中，单词出现的次数。</p><p>先读取一行文本保存到字符串，然后 split() 方法对单词进行分割，得到单词数组 words。把单词数组遍历，map 记录单词出现的次数。其中 <code>result.getOrDefault(word, 0) + 1</code> 方法表示：<strong>从 map 中拿到 key 为 word 的值，如果存在这个 key，就对这个 key 的值进行 +1 操作，然后 put 进去。如果不存在这个 key，就使它的值默认为 0，然后再进行 +1 操作，put 进去。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">workJob</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file));<br><br>     Map&lt;String, Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     String line;<br>     <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br><br>         String[] words = line.split(<span class="hljs-string">&quot; &quot;</span>);<br>         <span class="hljs-keyword">for</span> (String word : words) &#123;<br>             result.put(word, result.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>最后的工作 <code>mergeWorkResultIntoFileResult()</code>，把线程返回的结果，合并统计，得到最终结果。统计的操作和 workJob() 方法类似。把合并的结果返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">mergeWorkResultIntoFileResult</span><span class="hljs-params">(Map&lt;String, Integer&gt; workResult, Map&lt;String, Integer&gt; fileResult)</span> &#123;<br>    <br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entrySet : workResult.entrySet()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> entrySet.getKey();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mergerResult</span> <span class="hljs-operator">=</span> fileResult.getOrDefault(word, <span class="hljs-number">0</span>) + entrySet.getValue();<br>        fileResult.put(word, mergerResult);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fileResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，一个使用多线程的 wordcount 功能实现。代码可以点击看<a href="https://github.com/greek-zzf/my-demo/tree/main/example/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20WordCount">源代码</a>，后续会在代码中更新其他方法实现 WordCount。</p><h2 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h2><ul><li><p>不推荐：对于 cpu 密集型应用稍有折扣。cpu 密集型操作会把 cpu 跑满，因此再使用多线程去操作，性能上很那有提升。</p></li><li><p>推荐：IO 密集型操作（文件 IO，网络 IO），这两个操作相比 cpu 的执行速度慢如蜗牛，因此用多线程来执行，性能上会有很大提升。</p></li><li><p>多线程性能提升的上限：单核 cpu 100%，如果是多核就是 N*100%。当 cpu 跑满的时候，就很难有「闲工夫」去处理其他请求。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 获取 GitHub PR 消息</title>
    <link href="/2021/05/11/Java%20%E8%8E%B7%E5%8F%96%20GitHub%20PR%20%E4%BF%A1%E6%81%AF/"/>
    <url>/2021/05/11/Java%20%E8%8E%B7%E5%8F%96%20GitHub%20PR%20%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/greek-zzf/get-github-pr">链接</a></p><h2 id="使用-GitHub-API-获取-PR"><a href="#使用-GitHub-API-获取-PR" class="headerlink" title="使用 GitHub API 获取 PR"></a>使用 GitHub API 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jackson Databind 将返回的字符串解析转化成所需对象</li></ul><h3 id="访问-GitHub-API"><a href="#访问-GitHub-API" class="headerlink" title="访问 GitHub API"></a>访问 GitHub API</h3><p>访问 Github API <a href="https://docs.github.com/cn/rest/reference/pulls">文档</a>，找到 List pull requests 该项，根据 API 说明，应当使用 GET 方法，路径中还需要带上 owner 和 repo 参数，还需要设置 request header 中的 accept 为 <code>appliccation/vnd.github.v3+json</code>，这样就建立了一个正确的请求</p><p><img src="/../picture/Java%E8%8E%B7%E5%8F%96GitHubPR%E4%BF%A1%E6%81%AF/5857265f-3856-46c9-ba85-2a75f935b4a1.png" alt="image.png"></p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ol><li><p>创建一个类来封装获取到的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GitHubPullRequest</span> &#123;<br>        <span class="hljs-comment">// Pull request的编号</span><br>        <span class="hljs-type">int</span> number;<br>        <span class="hljs-comment">// Pull request的标题</span><br>        String title;<br>        <span class="hljs-comment">// Pull request的作者的 GitHub 用户名</span><br>        String author;<br><br>        GitHubPullRequest(<span class="hljs-type">int</span> number, String title, String author) &#123;<br>            <span class="hljs-built_in">this</span>.number = number;<br>            <span class="hljs-built_in">this</span>.title = title;<br>            <span class="hljs-built_in">this</span>.author = author;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>新建一个方法，使用 HttpClient 工具包发起 HTTP 请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://api.github.com/repos/&quot;</span> + repo + <span class="hljs-string">&quot;/pulls&quot;</span>);<br>httpGet.setHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/vnd.github.v3+json&quot;</span>);<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br></code></pre></td></tr></table></figure><p>首先创建一个<strong>默认的可关闭的客户端</strong>，使用 HttpGet 创建一个 GET 请求，repo 是我们要接收的参数。再刚才创建的 GET 请求中设置他的请求头信息，与 GitHub 规定的 API 一致。然后使用刚才创建的客户端，去执行 get 请求，将返回的结果用 CloseableHttpResponse 接收。</p></li><li><p>由于返回的结果是字节流，因此我们需要把字节流转换成我们需要的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">responseEntity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> responseEntity.getContent();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>getEntity()</code> 方法获取返回的 body 实体信息，获取到的实体信息调用 <code>getContent()</code> 方法获取内容，接着使用 IOUtils 工具把获取的内容从字节流以 UTF-8 的格式转化为字符串。 </p></li><li><p>把字符串转化成 json 对象或实体对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-type">JsonNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> objectMapper.readTree(result);<br><br>List&lt;GitHubPullRequest&gt; gitHubPullRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> number;<br>        String title;<br>        String author;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; node.size(); i++) &#123;<br>            number = node.get(i).get(<span class="hljs-string">&quot;number&quot;</span>).asInt();<br>            title = node.get(i).get(<span class="hljs-string">&quot;title&quot;</span>).asText();<br>            author = node.get(i).get(<span class="hljs-string">&quot;user&quot;</span>).get(<span class="hljs-string">&quot;login&quot;</span>).asText();<br><br>            gitHubPullRequests.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GitHubPullRequest</span>(number, title, author));<br>        &#125;<br></code></pre></td></tr></table></figure><p>使用 Jackson 工具，以树的形式反序列化 json 字符串得到 JsonNode，然后使用 for 循环将我们需要的数据封装到GitHubPullRequest 对象中，即可。</p></li></ol><h2 id="解析-HTML-获取-PR"><a href="#解析-HTML-获取-PR" class="headerlink" title="解析 HTML 获取 PR"></a>解析 HTML 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jsoup 将 html 字符串转化为 document</li></ul><h3 id="找到要获取的仓库-PR-地址，发起请求"><a href="#找到要获取的仓库-PR-地址，发起请求" class="headerlink" title="找到要获取的仓库 PR 地址，发起请求"></a>找到要获取的仓库 PR 地址，发起请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://github.com/&quot;</span> + repo + <span class="hljs-string">&quot;/pulls&quot;</span>);<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br></code></pre></td></tr></table></figure><p>发起请求并执行请求，获得返回的 response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpEntity</span> <span class="hljs-variable">responseEntity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> responseEntity.getContent();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>获取返回的数据中，body的内容，并把它转化成字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> Jsoup.parse(result);<br></code></pre></td></tr></table></figure><p>由于得到的是 html 字符串，使用 Jsoup 解析工具解析成 Document 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Element&gt; elements = doc.select(<span class="hljs-string">&quot;.js-issue-row&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 document 的 css 选择器，获取页面中的元素。此处可以根据具体页面采用不同的选择器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> number;<br>      String title;<br>      String author;<br>      List&lt;GitHubPullRequest&gt; gitHubPullRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (Element e : elements) &#123;<br>          title = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">0</span>).text();<br>          author = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">3</span>).child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).text();<br>          String[] str = e.child(<span class="hljs-number">0</span>).child(<span class="hljs-number">1</span>).child(<span class="hljs-number">3</span>).child(<span class="hljs-number">0</span>).text().split(<span class="hljs-string">&quot; &quot;</span>);<br>          number = Integer.parseInt(str[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>));<br>          gitHubPullRequests.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GitHubPullRequest</span>(number, title, author));<br>      &#125;<br></code></pre></td></tr></table></figure><p>根据元素之间的层级关系，拿到对应元素的信息，把信息封装到 GitHubPullRequest 类中存储。一个简单的 HTML 爬虫实现。</p><h2 id="使用第三方-SDK-获取-PR"><a href="#使用第三方-SDK-获取-PR" class="headerlink" title="使用第三方 SDK 获取 PR"></a>使用第三方 SDK 获取 PR</h2><p>工具包:</p><ul><li>Apache HttpClient 用来发起 HTTP 请求</li><li>Apache Commons IO 将返回的字节流转化成字符串</li><li>Jackson Databind 将返回的字符串解析转化成所需对象</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 正则表达式</title>
    <link href="/2021/04/17/Java%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/04/17/Java%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>定义</strong>：用于描述文本&#x2F;字符串的一组规则</p><p><strong>作用</strong>：使用一些自定义的规则来批量处理文本，提取信息</p><p><strong>优点</strong>：使用很少的代码完成复杂的文本提取工作，提高工作效率</p><p><strong>缺点</strong>：难学，难懂。在 java 对于正则表达式的支持不太友好，频繁使用会有性能问题。</p><h2 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h2><p><strong>元字符</strong></p><table><thead><tr><th>^</th><th>开始位置</th></tr></thead><tbody><tr><td>$</td><td>结束位置</td></tr><tr><td>.</td><td>单个任意字符</td></tr><tr><td>\w</td><td>单个”word”字符 字母&#x2F;数字&#x2F;下划线&#x2F;汉字</td></tr><tr><td>\s</td><td>单个空白字符</td></tr><tr><td>\d</td><td>单个数字字符</td></tr><tr><td>\b</td><td>单词的开始或结束</td></tr></tbody></table><p><strong>重复</strong></p><table><thead><tr><th>*</th><th>0次或多次</th></tr></thead><tbody><tr><td>+</td><td>1次或多次</td></tr><tr><td>?</td><td>0次或1次</td></tr><tr><td>{n}</td><td>n次</td></tr><tr><td>{n,}</td><td>&gt;&#x3D;n次</td></tr><tr><td>{n,m}</td><td>n到m次</td></tr></tbody></table><p><strong>选择</strong></p><table><thead><tr><th>[aeiou]</th><th>单个的a&#x2F;e&#x2F;i&#x2F;o&#x2F;u字符之一</th></tr></thead><tbody><tr><td>[0-9]</td><td>单个数字字符</td></tr><tr><td>[A-Z]</td><td>单个大写字母</td></tr><tr><td>[A-Z0-9_]</td><td>大写字母或者数字或者下划线</td></tr><tr><td>Hi&amp;#124;hi等价于[Hh]i</td><td>Hi或者hi</td></tr></tbody></table><h2 id="Java-世界中的正则表达式"><a href="#Java-世界中的正则表达式" class="headerlink" title="Java 世界中的正则表达式"></a>Java 世界中的正则表达式</h2><p>Java 中的正则表达式是比较「昂贵」的</p><ul><li><p>正则表达式需要解析</p><ul><li>Java 需要将正则表达式字符串，转换成自己内部的数据结构，这个转换过程代价较大</li><li>在写代码中可以将正则表达式预编译好，需要的时候再调用就行了，减少了多次编译的开销。例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;0\\d&#123;2&#125;-[1-9]\\d&#123;7&#125;|0\\d&#123;3&#125;-[1-9]\\d&#123;6&#125;&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>匹配过程非常「昂贵」</p><ul><li>Java 的匹配算法并不高效，用到的是<a href="https://www.google.com/search?q=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95&oq=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95&aqs=chrome..69i57j0l9.2220j0j4&sourceid=chrome&ie=UTF-8">回溯算法</a>。就像机器人走迷宫一般，一直尝试，遇到墙就换一条路线继续试，直到走出迷宫</li></ul></li></ul><p>Java 中使用到正则表达式的方法：String 类中的 split，replaceAll，replacefirst，matches，以及 Matches 中的方法。可以查看相关的 demo 链接：<a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%99%AE%E9%80%9A%E7%BB%83%E4%B9%A0/PhoneNumberMatcher.java">判断是不是合法的固定电话号码</a>，<a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%99%AE%E9%80%9A%E7%BB%83%E4%B9%A0/LogProcessor.java">移除文件中的时间戳</a></p><h2 id="分组与捕获"><a href="#分组与捕获" class="headerlink" title="分组与捕获"></a>分组与捕获</h2><p>前面的正则表达式用法，都是用来判断字符串是否满足条件。然而，实际工作中用到较多的都是从一堆字符串中提取所需的信息，那么 Java 又是怎么做的呢？</p><p>想要将所有符合正则表达式的⽂本抓出来处理，需要先了解如下规则：</p><ul><li>使⽤括号来指定⼀个被捕获的分组</li><li>分组的编号从1开始</li><li>分组的编号计算只看左括号</li><li>(?:)不捕获和分配编号，括号只⽤于分组或标记优先</li><li>分组编号为0表示整个匹配的字符串</li></ul><h3 id="Java-中捕获数据"><a href="#Java-中捕获数据" class="headerlink" title="Java 中捕获数据"></a>Java 中捕获数据</h3><p>在 Java 中可以使用 <code>Pattern 类的 matcher() 方法生成 Matcher 对象</code> ，然后我们可以对 <code>Matcher对象进行操作</code>。</p><p>假设有如下数据，我们需要将时间以及消费金额提取出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">2020-01-02 在家玩游戏消费0元<br>2020-01-03 在家敲代码消费3元<br>2020-02-02 出门旅游消费1000元<br></code></pre></td></tr></table></figure><p>我们可以先将该数据读取出来，保存成一个 List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">gcLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;message.log&quot;</span>);<br>List&lt;String&gt; lines = Files.readAllLines(gcLog.toPath());<br></code></pre></td></tr></table></figure><p>然后我们可以在类中声明 Pattern，把对匹配时间和事件的正则表达式预编译。经过在线正则表达式测试，我们可以编写如下正则 <code>\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;(.*)?\d</code> 这个可以匹配时间和金额。我们要提取，就需要给时间部分加上括号，金额部分也加上括号。正则表达式变成 <code>(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)(.*)?(\d)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_REGEX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)(.*)?(\d)&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(MESSAGE_REGEX);<br></code></pre></td></tr></table></figure><p>接着对所有字符串进行匹配，匹配过程中会生成 Matcher。调用 Matcher 的 find 方法，判断是否匹配成功。因为分组编号为 0 代表匹配的全部信息，即日期+金额，group(1) 代表匹配的第一组信息，即时间，group(2）就代表金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String line : lines) &#123;<br>          <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(line);<br>          <span class="hljs-keyword">if</span>(matcher.find())&#123;<br>              System.out.println(matcher.group(<span class="hljs-number">0</span>));<br>              System.out.println(matcher.group(<span class="hljs-number">1</span>));<br>              System.out.println(matcher.group(<span class="hljs-number">2</span>));<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><p>一个更为复杂的 GC 日志文件信息提取操作可查看 <a href="https://github.com/greek-zzf/my-demo/blob/main/example/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%88%86%E7%BB%84%E4%B8%8E%E6%8D%95%E8%8E%B7/GCLogAnalyzer.java">Demo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 常用标签</title>
    <link href="/2021/04/01/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/04/01/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><strong>href</strong>（指定要跳转的链接），取值如下<ul><li>网址（<a href="https://google.com,http//google.com%EF%BC%8C//google.com%EF%BC%89">https://google.com，http://google.com，//google.com）</a></li><li>路径（&#x2F;a&#x2F;b&#x2F;c，a&#x2F;b&#x2F;c&#x2F;，index.html）</li><li>伪协议（javascript:代码;，tel:手机号，mailto:邮箱）</li></ul></li><li><strong>target</strong>（指定打开链接的窗口），取值如下<ul><li>_blank（新窗口打开）</li><li>_top（顶级窗口打开）</li><li>_parent（父级窗口打开）</li><li>_self（默认值，表示在当前页面打开）</li></ul></li></ul><h2 id="table-标签"><a href="#table-标签" class="headerlink" title="table 标签"></a>table 标签</h2><h3 id="相关的标签"><a href="#相关的标签" class="headerlink" title="相关的标签"></a>相关的标签</h3><ul><li>table</li><li>thead（表头）</li><li>tbody（表内容）</li><li>tfoot（表尾）</li><li>tr，table row 缩写，表示一行。</li><li>td，table data 缩写,表示内容</li><li>th，table header 缩写，表示标题</li></ul><p>我们可以用如下代码的来实现，一个简单的表格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小红<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>246<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>279<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>297<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>小明</th><th>小红</th><th>小白</th></tr></thead></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>246<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>279<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>297<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../picture/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/b13bb768-2d4b-4038-aa44-e996452c2c6f.png" alt="image.png"><br>其中 <code>小明，小红，小白</code> 为表头的标题，所以使用 <thead> 标签包裹，并使用 <th> 标签表示表头。 <code>数学，语文，英语，总分</code> 也为标题，因此也要用 <th> 标签包裹，总分在 <tfoot> 中，使用 <th> 包裹。这样就实现一个简单的表格。</p><h3 id="相关样式"><a href="#相关样式" class="headerlink" title="相关样式"></a>相关样式</h3><ul><li><strong>table-layout</strong><ul><li>auto，根据内容的宽度展示</li><li>fixed，固定的宽度</li></ul></li><li><strong>border-collapse</strong>（border 是否合并）<ul><li>collapse 表示合并</li></ul></li><li><strong>border-spacing</strong>（合并 border 之间的距离）**</li></ul><h2 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>发出 get 请求，展示一张图片</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>alt（图片加载失败时展示的内容）</li><li>height（图片高度，直接使用数字。支持自适应，高度固定则宽度自适应）</li><li>width（图片宽度，直接使用数字。支持自适应，宽度固定则高度自适应）</li><li>src（引用图片地址，可以使用绝对路径，相对路径，网络地址）</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>onload（图片加载成功事件）</li><li>onerror（图片加载失败页面），通常可以做一些处理，例如当图片加载失败之后，可以使用默认的错误图片来展示。</li></ul><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>max-width:100%，自适应不同屏幕分辨率。可以使图片根据不同屏幕大小完整显示。</li></ul><h2 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>发 <strong>get</strong> 或 <strong>post</strong> 请求，然后<strong>刷新页面。</strong></p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul><li>action（请求的地址）</li><li>method（请求方法）</li><li>autocomplete（比如输入账号有自动填充）</li><li>target（指定刷新页面）</li></ul><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><ul><li>onsubmit（表单提交）</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>form 里面放一个 type &#x3D; submit 才能触发事件。</li><li>可以是 <code>&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;</code> ，或者 <code>&lt;input type=&quot;submit&quot;/&gt;</code></li></ul><h2 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>让用户输入内容</p><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul><li>type<ul><li>button，按钮</li><li>checkbox，复选框，提交多个选项将 input 的 name 属性设置为相同的值</li><li>file，上传单个文件，上传多个需要在 input 中加入 multipart 即可</li><li>hidden</li><li>password，密码类型</li><li>radio，单选框，实现单选需要将两个 input 的 name 设为相同的值</li><li>submit，提交表单</li><li>text，文本类型</li></ul></li></ul><h3 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h3><ul><li>onchange，输入框中改变的事件</li><li>onfocus，输入框焦点事件</li><li>onblur，输入框移出事件</li><li>一般不监听 input 的 click 事件</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection</title>
    <link href="/2021/03/15/Collection/"/>
    <url>/2021/03/15/Collection/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Collection"><a href="#什么是-Collection" class="headerlink" title="什么是 Collection"></a>什么是 Collection</h1><p><code>Collection</code> 是 Java 世界中最重要的类库，是这个类库的顶级接口。它的实现有 Set，List。而 Set 的实现又有 <strong>HashSet</strong>，TreeSet……。List 的实现有 <strong>ArrayList</strong>，LinkedList ……。也就是说我们日常使用的集合类都基本是 <code>Collection</code> 接口的实现。</p><h1 id="Collction-常用方法"><a href="#Collction-常用方法" class="headerlink" title="Collction 常用方法"></a>Collction 常用方法</h1><p><strong>C：</strong>new ArrayList()  &#x2F; new LinkedList() &#x2F; new HashSer() &#x2F;…<br><strong>R：</strong>size() &#x2F; isEmpty() &#x2F; contains() &#x2F; for() &#x2F;stream<br><strong>U：</strong>add() &#x2F; addAll() &#x2F; retainAll()<br><strong>D：</strong>clear() &#x2F; remove() &#x2F; removeAll()</p><ul><li>其中 <strong>contains()</strong> 判断 collection 是否包含某一元素</li><li><strong>retainAll()</strong> 表示<strong>当前集合只保留与指定集合的公共元素</strong>，比如下面的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCollection</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    collection1.add(<span class="hljs-number">1</span>);<br>    collection1.add(<span class="hljs-number">2</span>);<br>    collection1.add(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    collection2.add(<span class="hljs-number">2</span>);<br>    collection2.add(<span class="hljs-number">3</span>);<br>    collection2.add(<span class="hljs-number">3</span>);<br><br>    collection2.retainAll(collection1);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 <strong>collection2</strong> 进行 <strong>retainAll()</strong> 操作之后得到的结果就是与** collection1** 相同的元素，即：2，3。</p><ul><li><strong>removeAll() <strong>正好与</strong> retinAll() 相反，</strong>表示**移除当前集合移除与指定集合相同的元素，比如下面代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCollection</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>     collection1.add(<span class="hljs-number">1</span>);<br>     collection1.add(<span class="hljs-number">2</span>);<br>     collection1.add(<span class="hljs-number">3</span>);<br><br>     <span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>     collection2.add(<span class="hljs-number">2</span>);<br>     collection2.add(<span class="hljs-number">3</span>);<br>     collection2.add(<span class="hljs-number">4</span>);<br><br>     collection2.removeAll(collection1);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>collection2</strong> 进行 <strong>removeAll() <strong>操作之后，</strong>collection2</strong> 中的元素为：4。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 是<strong>有序且元素可重复</strong>的集合</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>ArrayList 底层是个数组实现</strong>，具有动态扩容的特点。说到数组，我们印象中的数组都是有容量限制的，都有一个固定大小，那 ArrayList 的动态扩容是怎么实现的呢？</p><p><strong>ArrayList 动态扩容原理</strong>：当 ArrayList 满了的时候，会自动扩容。ArrayList 会创建一个新的更大的空间的 List ，把原来满了的 List 的数据，复制到新的 List 中，并把原来满的 List 丢弃。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>LinkedList 底层是链表实现</strong>，LinkedList 在日常使用中很少使用到。</p><h2 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h2><p>ArrayList 是 Java 世界中，最常用的实现。既然是最常用的实现，为什么我们还需要 LinkedList? 既然有两种实现方式，那么两者的的区别和优缺点又是什么？</p><p>通过两者的底层实现可以发现他们各自的优势和区别。</p><p>因为 <code>ArrayList</code> 底层是数组实现，根据数组这一数据结构的特点，可以知道，数组用于查询，速度非常快。但是，数组做增删的操作就很比较慢。</p><p>而 <code>LinkedList</code> 的底层是链表实现，根据链表这一数据结构的特点，也很容易知道，链表的增删速度非常快，而对于查询来说就比较慢。</p><p>因此，综上所诉。对于查询需求较多的，我们可以使用 <code>ArrayList</code> 的实现，对于增删需求较多的，就使用 <code>LinkedList</code></p><h2 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h2><p>我们经常往 ArrayList 中添加元素，在们看来 ArrayList 好像是一个无限容量的空间一样，可以一直往里面丢东西。实际上是 ArrayList 的扩容机制在搞鬼，每当容量不足的时候，他就会在背后帮我们自动扩容，而我们是感知不到这个过程的，扩容机制给我们造成了无限容量的假象。</p><p>我们直接查看 ArrayList 的 add 方法源代码，如下。</p><p><img src="/../picture/Collection/7f8d3ac4-c857-44f1-8059-0f25f5d926df.png" alt="image.png"><br>可以发现在添加元素前，使用了 ensureCapacityInternal 方法，来确保可以添加。我们可以在 ensureCapacityInternal 的实现方法中找到 grow 方法，这个方法就是 ArrayList 扩容的秘密。</p><p><img src="/../picture/Collection/5b73daa1-eb23-4706-b5a4-67b333140334.png" alt="image.png"><br>可以看到代码中的 newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1)，表示的扩容后，新容量等于旧容量加上旧容量右移一位。右移可以理解为除以 n^2，此处就是旧容量除以1的2次方，相加之后新容量就是旧容量的1.5倍。<strong>ArrayList 扩容机制简述就是：创建一个更大的空间，空间容量为原来容量的1.5倍，然后把所有元素拷贝过去，完成扩容。</strong></p><p>说到这里还有个问题没有解决，既然 ArrayList 容量是有限的，那么<strong>我们直接 new 一个 ArrayList 的初始容量是多少呢？</strong>其实源代码已经给出答案了。</p><p><img src="/../picture/Collection/dd0e6e82-2b84-4a18-a78d-b61ffa2ad050.png" alt="image.png"><br>构造方法注释中标明，初始化容量是10。但我用 debug 调试的时候，发现初始容量并不是我们 new 的时候就创建好了，而是当我们往里面添加第一个元素时，触发了 ArrayList 的扩容机制，扩容成一个容量是10的新空间，再把我们要添加的元素放进新空间中。这属于懒加载机制，当我们需要添加元素时，才真正开辟空间。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 是<strong>无序且元素不可重复</strong>的集合。在 java 世界中，判断两个元素是否相同使用 <code>equals</code>  方法。</p><h2 id="简单的-Set-实现"><a href="#简单的-Set-实现" class="headerlink" title="简单的 Set 实现"></a>简单的 Set 实现</h2><p>我们可以顺着 List 的特性，以及 Collection 的 Contains() 方法来简单实现一个 Set。因为 Set 不包含重复元素，而且 Contains 方法就是判断元素是否重复。因此，只要往 List 中添加元素时，进行 Contains 判断，元素不重复就往 List 中添加，这样就能得到一个不包含重复元素的 List，也就是一个手写的简单 Set 实现。</p><h2 id="Java-世界的高效-Set-实现-HashSet"><a href="#Java-世界的高效-Set-实现-HashSet" class="headerlink" title="Java 世界的高效 Set 实现 HashSet"></a>Java 世界的高效 Set 实现 HashSet</h2><p>虽然我们手写的 Set 也能用，但是相比 Java 中其它的 Set 实现，性能差距不知差了多少。Java 世界中最高效的 Set 实现当属于 <code>HashSet</code> 。</p><h3 id="一、HashSet-实现简述"><a href="#一、HashSet-实现简述" class="headerlink" title="一、HashSet 实现简述"></a>一、HashSet 实现简述</h3><p>HashSet 之所以高效是因为他的背后是 HashBucket，即：哈希桶。每个哈希桶对应一个 hashCode。因此，每次往 HashSet 中添加元素的时候，首先通过 hash 运算，计算出它的 hashCode，再与哈希桶的 hashCode 进行比对，相同就把元素加入该哈希桶中。</p><h3 id="二、hashCode"><a href="#二、hashCode" class="headerlink" title="二、hashCode"></a>二、hashCode</h3><p>在了解 HashCode 之前，先了解下 <strong>Hash 运算</strong>。Hash 运算就是把我们数据变成一个哈希值，是一个单向映射操作。例如：假设 Hash 运算把名字变成姓氏，于是就是有「张三」-&gt;「张」、「李四」-&gt; 「李」，以此类推。Java 世界中的 Hash 运算有它<strong>自己的一套运算规则</strong>，我们只需要知道经过 Hash 运算会返回一个 int 值就行了。</p><p>hashCode 是数据通过 Hash 运算得到的值。我们可以通过 hashCode 来初步判断是否同一元素。</p><p>在 Java 世界中对象返回的 HashCode 都遵守以下约定：</p><ul><li><strong>同一个对象得到的 hashCode 相等</strong></li><li><strong>两个对象 <code>equals</code> 为 true，hashcode 相等</strong></li><li><strong>两个对象不等，hashcode 可能相等</strong></li></ul><h2 id="判断对象是否相等"><a href="#判断对象是否相等" class="headerlink" title="判断对象是否相等"></a>判断对象是否相等</h2><p>假设存在一个 Person 对象，它有 name 属性。现在我们要使得名字相同的对象为同一对象，应该怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面提到过判断是否重复我们可以使用 equals 方法，因此我们可以该方法来解决。假如我们初始化 person1，person2，他们的名字都是「张三」。然后我们再调用 equals 方法判断 <code>person1.equals(perons2)</code> ，结果返回的却是 false，为什么？</p><p>在我们看来，名字相同的人就是同一个对象，可是计算机却不是这么认为的，我们查看 Object 的 equals 方法发现，它比较的实际上是内存地址。因为是两个对象，所以他们指向的内存地址不同。尽管内存中的值相等，也没用。</p><p>因此，我们就需要重写 equals，hashCode 方法来达到相同名字为同一对象的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name.hashCode();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) obj;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(person.getName());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 equals 中比较两个对象的名字是否相等，相等返回 true。同时遵守「两个对象 <code>equals</code> 为 true，hashcode 相等」的约定，所以我们再 hashCode 方法中根据 name 来返回 HashCode，当 name 相同时就会返回相等的 HahsCode。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/03/04/Git/"/>
    <url>/2021/03/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p>了解一门新的技术或者工具都要问这几个问题：它是什么？它有什么用？</p><p><code>Git</code> 是世界上最先进的<code>分布式</code>版本控制系统。这里又有两个小问题：什么是「分布式」？「版本控制」又是什么？</p><p>首先讲一下「版本控制」。什么是版本控制呢，只要玩过游戏就能很好的理解，「版本控制」就像游戏的「存档」一样。一般我们打 boss 前都会存档，我们可能存在多个存档，每次想回到哪个时间点都能回去。我们遇到很难打的 boss ，可以借号给朋友，让朋友帮你过，朋友打完也可以存档，这样你玩的时候已经通关了。这就是「多人协作」的好处，同样 Git 也是支持多人协作的。相比游戏「存档」，Git 还可以清楚的知道每个存档你做了什么事，比如：你在存档 A 过了新手村，存档 B 击杀了 boss。游戏就不同了，「存档」和「事件」的对应关系，需要自己去记忆，存档多了就会很不方便。 </p><h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><p>git add</p><p>git commit</p><p>git status</p><p>git diff</p><p>git log –pretty&#x3D;oneline</p><p>git reset –hard head^</p><p>git reflog</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>远程仓库熟悉的有 <code>GitHub</code>，<code>Gitee</code>。我们可以把我们的本地仓库推送到远程仓库上去，接下来都以 GitHub 仓库举例，练习。</p><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><p>由于本地的 Git仓库和 GitHub 的传输是通过 SSH 加密的，我们需要做一些简单设置。在用户主目录下，先检查电脑是否有 <code>.ssh</code> 文件夹，如果有，在看下有没有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 这两个文件。如果有，就跳到第二步。</p><p>一， 打开 <code>Git Bash</code>，输入如下命令命令，创建 SSH Key，记得把邮箱换成自己的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<br></code></pre></td></tr></table></figure><p>过程中出现提示，一直回车即可。成功的话，就可以在用户主目录下看到 <code>.ssh</code> 文件夹，以及该文件夹下的 <code>id_rsa</code>，<code>id_rsa.pub</code> 两个文件。</p><p>二，在 GitHub 添加 SSH Key。把刚才的 id_rsa.pub 文件里的内容复制到 GitHub 要添加 SSH Key 的地方，完成添加即可。GitHub 添加 SSH Key 的位置自行搜索。</p><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>使用如下命令关联远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote add origin 仓库地址<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 前后端基础架构原理</title>
    <link href="/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/03/04/Web%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>当我们打开浏览器去访问一个网站时，发生了什么？在了解整个过程之前，我们应该先了解一些基本概念</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>首先我们需要明确一点的是，当我们访问一个网站的时候，实际上是在与一个主机进行交互。就像去商店购物一样，只要你不差钱，商店有的，它都能提供给你。</p><h3 id="主机（Host）"><a href="#主机（Host）" class="headerlink" title="主机（Host）"></a>主机（Host）</h3><p>主机简单来说就是一台电脑，只不过它的作用更多，可以响应浏览器发送的请求。我们平时所用的电脑也可以充当一台服务器，只不过需要一些专业的操作，才能把它变成主机。</p><p>那么问题来了，世界上有很多台主机，我们在浏览器输入 <a href="http://www.taobao.com/">www.taobao.com</a> 的时候，它是怎么帮我们找到淘宝的主机的？</p><h3 id="IP-与域名"><a href="#IP-与域名" class="headerlink" title="IP 与域名"></a>IP 与域名</h3><p>每个 IP 对应一个主机，因此只要我们知道 IP 地址就可以正确地找到对应的主机了。说到这里可能还有个疑问，我们明明输入的是一个网址，也没有看见 ip 地址啊，他怎么知道我访问的是那一台主机？这个就要说到 DNS 的功劳了。首先用 ip 去找对应的主机是没问题的，我们输入的网址本质上就对应一个 ip，只是我们没有察觉。DNS 就是把输入的网址，找到对应的 ip ，然后返回给我们。这样我们就本能的以为，只要输入网址就能找到对应的网站了，这是 DNS 给我们的错觉。</p><p>DNS 是个网络上的服务，他包含了域名和 ip 地址的映射关系。windows 本机上有个 hosts 文件，可以自己添加和修改网址和 ip 的对应关系，假如我们把 <a href="http://www.taobao.com/">www.taobao.com</a> 对应的 ip 改成 127.0.0.1，这样在浏览器再次输入<a href="http://www.taobao.com/">www.taobao.com</a> 就找不到原本的淘宝网站了，而是映射到本机。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>现在请假设一个场景：你有一台电脑，电脑连了一根网线，同时电脑上开了好几个程序，像 QQ、淘宝、微信。你有没想过，一根网线传的数据，他怎么知道哪个是 QQ 要的数据，哪个是淘宝返回的数据呢？</p><p>区分不同应用的数据，我们就用到了<strong>端口</strong>，不同应用他所对应的端口不一样的。网线中传输的数据，每个数据包都有对应的端口信息，就像一列火车一样，每个人的目的地不一样，有的在广州下车，有的在深圳下车，目的地不一样。数据也是这样，根据端口到达不同的应用中去。</p><p>我们可以经常看到网址前面有 http 或 https，他们都对应着不同的端口号。HTTPS 协议的默认端⼝是443，HTTP协议的默认端口是80。别看我们访问网站的时候没有看到端口号，其实浏览器已经在后面偷偷帮我们补上了。</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>当我们向远程的服务器发起请求时，TCP 协议就开辟了一条双车道的「高速公路」，不过在这条路上跑的是数据。同时数据也是一个一个的字节，所以也叫字节流，<strong>TCP是基于流的协议</strong>。由于是双车道，所以我们可以和服务器同时接受和发送数据，这叫做<strong>全双工协议，</strong>tcp就是全双工协议。半双工协议就是类似生活中的「对讲机」，只有对方说完，我们才能说话。</p><p><strong>TCP 协议本质上就是规定字节流如何发送和接收</strong></p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>Http 是在 TCP 协议之上的一层协议。Http 定义了文本之外的东西如何被传输。我们把发送给服务器的字节流叫做 <strong>HTTP Request</strong>，比如我们访问豆瓣首页。我们就会向服务器发送如下字节流。</p><p><strong><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/a46104e5-ab13-4c06-8d67-fc25533364f0.png" alt="image.png"></strong><br>服务器收到请求之后就会返回一个 <strong>HTTP Response <strong>字节流，除了 Headers 之外，还返回了</strong> HTTP Response Body（响应体）</strong>，response body 可以是文本，也可以是及二进制数据，包括图片、声音、下载的文件等。</p><p><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/d1b5fc66-e420-4974-a253-2d14fc46da93.png" alt="image.png"><br>刚才访问的豆瓣网站，就返回了一个 response body，一个 html 文件。我们得浏览器收到这个 html 文件，就会根据他的结构，标签去解析和展示他。我们看到的页面就是浏览器解析之后的样子。</p><p><img src="/../picture/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/b594a1c8-ea35-46ee-9093-5ff9fe6ae319.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 包冲突解决过程</title>
    <link href="/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/03/03/Maven%20%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>记录一次 maven 包冲突解决过程，项目地址<a href="https://github.com/hcsp/resolve-package-conflict">链接</a>。</p><h2 id="查看错误方法"><a href="#查看错误方法" class="headerlink" title="查看错误方法"></a>查看错误方法</h2><p>首先要将项目克隆到本地，然后运行，找到出错的位置，以及出错的信息。<br> <img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb20e3c-d218-44f4-a995-61be864a19e4.png" alt="image.png"><br>如图所示，错误的位置在 MainTest.java 文件第六行，错误信息 <code>NoSuchMethod</code> ，表示没有找到这个方法。根据位置提示，一层一层往下找，发现原来是 A.java 这个类中调用的 <code>getJsonpFunction</code> 方法找不到</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/1eb93ac6-bf86-4f27-8f3f-5b0e0f6978ce.png" alt="image.png"></p><h2 id="查看包冲突"><a href="#查看包冲突" class="headerlink" title="查看包冲突"></a>查看包冲突</h2><p>通过使用 maven helper 插件查看包的依赖树。如图所示，spring-web:5.1.8.RELEASE 版本和 spring-web:4.3.6.RELEASE 版本冲突了。图上的 4.3.6 版本为红色，可知，maven 使用的是 5.1.8 版本。我们根据 maven 解决包冲突的就近原则来看，5.1.8 离项目的距离为1，4.3.6 的距离为2，因此保留5.1.8版本，再次证实了这一点。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/bcd7d3b1-5625-4466-9bff-4d7fa1cf4a7c.png" alt="image.png"></p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>既然知道了是 spring-web 这个包的问题。我们就访问 maven 仓库，找到对应的版本，访问他的 github 主页。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/529dcfcc-07f4-4315-b0bc-e1fc3b11c480.png" alt="image.png"><br>找到了 github 仓库，进入报错的那个类，通过切换 tags 来切换不同版本对应的源代码，两者进行比较。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/cb13c43d-19fe-41db-9552-443f008f598a.png" alt="image.png"><br>对比发现在5.1.8版本 org.springframework.http.converter.json.MappingJacksonValue 中不存在 <code>getJsonpFunction</code>  这个方法。而 4.3.6 中却有。因此可以断定，我们项目本该使用 4.3.6 版本，而 maven 帮我们剔除了 4.3.6 版本，保留了 5.1.8 版本，导致找不到 <code>getJsonFunction</code> 而报错。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/a26925af-9758-4767-8e5a-107165edd81b.png" alt="image.png"></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>知道了冲突的原因，我们就只需要把 5.1.8 版本的依赖注释掉就行，这样 maven 就会帮我们加载 4.3.6 版本的包了。</p><p><img src="/../picture/Maven%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/4efcceb9-a459-4eb2-bda3-58ab8f6dda90.png" alt="image.png"><br>同时也可以将 5.1.8 版本的依赖改成 4.3.6 版本，解决冲突。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 与命令行</title>
    <link href="/2021/03/01/Java%20%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2021/03/01/Java%20%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>在日常写 Java 程序的工作中，运行，debug 等等操作，本质上都是在进行命令行操作。我们在 IDE 上点击运行，Java 程序就会运行，实际上 IDE 在背后帮我们进行了命令拼接。</p><p>我们可以在 IDEA 中编写一个简单的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> zzf;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zzf</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/2/28/028 21:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 zzf 包下面有个 Main.java 类，里面有个 main 方法输出了 “Hello World”。在 IDEA 中点击了运行按钮之后，控制台会有一串命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">D:\java\jdk\bin\java.exe -javaagent:D:\software\Idea\ideaIU-2019.2.3.win\lib\idea_rt.jar=56956:D:\software\Idea\ideaIU-2019.2.3.win\bin -Dfile.encoding=UTF-8 -classpath D:\Java\jdk\jre\lib\charsets.jar;D:\Java\jdk\jre\lib\deploy.jar;D:\Java\jdk\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk\jre\lib\ext\cldrdata.jar;D:\Java\jdk\jre\lib\ext\dnsns.jar;D:\Java\jdk\jre\lib\ext\jaccess.jar;D:\Java\jdk\jre\lib\ext\jfxrt.jar;D:\Java\jdk\jre\lib\ext\localedata.jar;D:\Java\jdk\jre\lib\ext\nashorn.jar;D:\Java\jdk\jre\lib\ext\sunec.jar;D:\Java\jdk\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk\jre\lib\ext\sunmscapi.jar;D:\Java\jdk\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk\jre\lib\ext\zipfs.jar;D:\Java\jdk\jre\lib\javaws.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\lib\jfxswt.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\management-agent.jar;D:\Java\jdk\jre\lib\plugin.jar;D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\idea-work\testDemo\out\production\testDemo zzf.Main<br></code></pre></td></tr></table></figure><p>当我们把该命令复制到 CMD 窗口运行的时候，同样控制台会打印 “Hello World”</p><h2 id="Java-执行过程"><a href="#Java-执行过程" class="headerlink" title="Java 执行过程"></a>Java 执行过程</h2><p>我们平时写的源代码（.java 文件），需要编译成字节码（.class 文件），然后再给到 jvm 去解释执行。jvm 只认识字节码，多个 class 文件可以打包成 jar 包来执行。</p><h3 id="args-参数"><a href="#args-参数" class="headerlink" title="args 参数"></a>args 参数</h3><p>我们写 Java 程序，main 方法里面都有一个 args 参数，实际上这个参数是可以从命令行获取的。编写以下程序获取打印 args 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>System.out.println(java.util.Arrays.toString(args));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令编辑和运行该程序</p><p><img src="/../picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/cb5a1ca0-47b2-4f27-adf4-23b88ff755c8.png" alt="image.png"><br>可以看到使用 <code>java Main</code> 运行时，打印为空字符串，而在后面添加 <code>1 2 3</code> 三个参数时，打印 <code>[1,2,3]</code> 。</p><p><code>java Main 1 2 3</code> 表示，调用 java 这个可执行程序，然后把 <code>Main 1 2 3</code> 这四个参数传递个 java。java 把 Main 这个类名拿出来，并且运行这个类，后面的参数 <code>1 2 3</code> 当做这个类的参数，传递给这个类的 main 方法。</p><h3 id="jvm-中的系统属性和环境变量"><a href="#jvm-中的系统属性和环境变量" class="headerlink" title="jvm 中的系统属性和环境变量"></a>jvm 中的系统属性和环境变量</h3><p>系统属性和环境变量是完全不同的东西，系统属性只在 jvm 中有效，不像环境变量可以继承属性。</p><p>我们可以在代码中使用 <strong>System.getenv()</strong> 来获取当前环境变量，使用 <strong>System.getProperty()</strong> 获取系统属性。我们可以编写如下代码（其中 java.version 是 jvm 自带的系统属性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>    <span class="hljs-comment">// 打印 args 参数</span><br>System.out.println(<span class="hljs-string">&quot;args: &quot;</span> +java.util.Arrays.toString(args));<br>    <span class="hljs-comment">// 打印名为 zzf 的环境变量</span><br>System.out.println(<span class="hljs-string">&quot;env: &quot;</span> +System.getenv(<span class="hljs-string">&quot;zzf&quot;</span>));<br>    <span class="hljs-comment">// 打印名为 zzf 的系统属性</span><br>System.out.println(<span class="hljs-string">&quot;System Property: &quot;</span> +System.getProperty(<span class="hljs-string">&quot;zzf&quot;</span>));<br>    <span class="hljs-comment">// 打印名为 java.version 的系统属性</span><br>System.out.println(<span class="hljs-string">&quot;Java version: &quot;</span> +System.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先使用 <code>export zzf=helo</code> 给当前环境添加环境变量 zzf，值为 hello，然后运行。</p><p><img src="/../picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/f9e53a89-e89f-4f30-ae14-bf89b7712e10.png" alt="image.png"><br>可以发现系统属性 zzf 并没有，打印为 null。而由于 jvm 存在系统属性 java.version，所以正确打印出版本号。要传入系统属性给 jvm 我们需要使用 <strong>-D</strong> 参数，如图所示。</p><p><img src="/../picture/Java%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C/38903da7-6c08-4b00-bbe3-39cc1fb23f9a.png" alt="image.png"></p><h3 id="java-代码中的包"><a href="#java-代码中的包" class="headerlink" title="java 代码中的包"></a>java 代码中的包</h3><p>假设有如下代码 zzf.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">zzf</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">0</span>]));<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">1</span>]));<br>System.out.println(StringUtils.isBlank(args[<span class="hljs-number">2</span>]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码引用了第三方的包 <code>org.apache.commons.lang3.StringUtils</code> ，当我们使用 javac 编译的时候会报错，找不到这个包。因此，就需要指定这个包的目录，假设 <code>commons-lang3-3.9.jar</code> 文件和 zzf.java 文件在同一目录下，我们就可以使用 -classpath（简写 -cp），指定文件的位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac -cp commons-lang3-3.9.jar zzf.java<br></code></pre></td></tr></table></figure><p>这样就可以编译通过。但是在运行 java 程序的时候，需要同时指定引用的包的位置，还需要指定 zzf.class 文件位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ./commons-lang3-3.9.jar:. zzf 1 2 3<br></code></pre></td></tr></table></figure><p> 该命令指定了第三方包的位置，以及 zzf.class 文件的位置。由于 zzf.class 文件是在当前目录，所以用 “.” 来表示。在 Linux 中多个目录用 “:” 隔开，Windows 使用 “;” 隔开。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到这个命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">D:\java\jdk\bin\java.exe -javaagent:D:\software\Idea\ideaIU-2019.2.3.win\lib\idea_rt.jar=56956:D:\software\Idea\ideaIU-2019.2.3.win\bin -Dfile.encoding=UTF-8 -classpath D:\Java\jdk\jre\lib\charsets.jar;D:\Java\jdk\jre\lib\deploy.jar;D:\Java\jdk\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk\jre\lib\ext\cldrdata.jar;D:\Java\jdk\jre\lib\ext\dnsns.jar;D:\Java\jdk\jre\lib\ext\jaccess.jar;D:\Java\jdk\jre\lib\ext\jfxrt.jar;D:\Java\jdk\jre\lib\ext\localedata.jar;D:\Java\jdk\jre\lib\ext\nashorn.jar;D:\Java\jdk\jre\lib\ext\sunec.jar;D:\Java\jdk\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk\jre\lib\ext\sunmscapi.jar;D:\Java\jdk\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk\jre\lib\ext\zipfs.jar;D:\Java\jdk\jre\lib\javaws.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\lib\jfxswt.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\management-agent.jar;D:\Java\jdk\jre\lib\plugin.jar;D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\idea-work\testDemo\out\production\testDemo zzf.Main<br></code></pre></td></tr></table></figure><p>先不管 <code>-javaagent</code> ，从 <code>-Dfile.encoding=UTF-8</code> 给 jvm 设置一个系统属性 file.encoding&#x3D;UTF-8，然后使用 <code>-classpath</code> 指定引用的包路径，要运行的文件的位置。最后只剩需要执行的文件名称 <code>zzf.Main</code> 。把上述这些都交给 <code>D:\java\jdk\bin\java.exe</code> 该可执行程序执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
