<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Jenkins 自动化部署</title>
    <link href="/2022/11/14/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/11/14/Jenkins%20%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>简介：Java 编写的最广泛使用的开源持续集成工具，非常易用，广泛的第三方插件支持，以及分布式构建。</p><p>文章所演示的项目地址：</p><p>GitHub: <a href="https://github.com/greek-zzf/oh-my-jenkins.git">https://github.com/greek-zzf/oh-my-jenkins.git</a><br>Gitee: <a href="https://gitee.com/geek-zzf/oh-my-jenkins.git">https://gitee.com/geek-zzf/oh-my-jenkins.git</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="War-包方式"><a href="#War-包方式" class="headerlink" title="War 包方式"></a>War 包方式</h3><p>优点：安装启动非常方便。</p><p>缺点：与环境强绑定，服务器要为 Jenkins 提供部署项目所需要的环境，例如：Node、Java 等。 部署成服务需要使用对应平台的命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到安装方式，下载 War 包。或者直接点击<a href="https://www.jenkins.io/download/">这里</a>下载。 </p></li><li><p>下载完成运行命令 <code>java -jar jenkins.war</code> ，等待几分钟。 </p></li><li><p>在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>优点：与宿主机环境隔离，不依赖宿主机环境。注册成服务非常方便，只需要启动时设置好参数 <code>--restart=always</code> 即可。</p><p>缺点：启动稍微复杂，需要配置好启动命令。</p><p>安装步骤：</p><ol><li><p>访问 Jenkins 官网，找到 Docker 安装方式。或者直接点击<a href="https://www.jenkins.io/doc/book/installing/docker/">这里</a>访问。 </p></li><li><p>运行 Docker 命令如下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">step1: docker network create jenkins<br><br>step2: docker run --name jenkins-docker --rm --detach \<br>  --privileged --network jenkins --network-alias docker \<br>  --env DOCKER_TLS_CERTDIR=/certs \<br>  --volume jenkins-docker-certs:/certs/client \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --publish 2376:2376 \ <br>  docker:dind --storage-driver overlay2   --insecure-registry 47.107.74.10:5000 <br> <br><br>step3: 创建 Dockerfile 文件，并把如下内容复制进去<br><br>    FROM jenkins/jenkins:2.332.2-jdk11<br>    USER root<br>    RUN apt-get update &amp;&amp; apt-get install -y lsb-release<br>    RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \<br>      https://download.docker.com/linux/debian/gpg<br>    RUN echo &quot;deb [arch=$(dpkg --print-architecture) \<br>      signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \<br>      https://download.docker.com/linux/debian \<br>      $(lsb_release -cs) stable&quot; &gt; /etc/apt/sources.list.d/docker.list<br>    RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli<br>    USER jenkins<br>    RUN jenkins-plugin-cli --plugins &quot;blueocean:1.25.3 docker-workflow:1.28&quot;<br><br>step4: docker build -t myjenkins-blueocean:2.332.2-1 .<br><br>step5: docker run --name jenkins-blueocean --rm --detach \<br>  --network jenkins --env DOCKER_HOST=tcp://docker:2376 \<br>  --env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \<br>  --publish 8080:8080 --publish 50000:50000 \<br>  --volume jenkins-data:/var/jenkins_home \<br>  --volume jenkins-docker-certs:/certs/client:ro \<br>  myjenkins-blueocean:2.332.2-1<br></code></pre></td></tr></table></figure></li><li><p>等待一会，在浏览器中访问 <a href="http://localhost:8080，完成后续配置。">http://localhost:8080，完成后续配置。</a></p></li></ol><p><strong>注意</strong>：步骤4构建失败，可能是由于 Docker 权限问题，解决方案可参考<a href="https://github.com/docker/buildx/issues/476">这里</a>。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>解锁 Jenkins：浏览器中提示输入管理员密码。War 在启动的控制台中会打印密码，或者页面提示的文件中。Docker 方式使用命令，查看容器日志信息即可看到 <code>docker logs jenkins-blueocean</code>。 </p></li><li><p>插件下载镜像设置：为了部署和运行项目，需要安装一些插件。首先需要给插件站点设置一个镜像，不然访问速度感人。配置路径 “Manager Jenkins -&gt; Manager Plugins -&gt; Advanced”，在底部的 <code>Update Site</code> 中把地址进行替换。这里提供一个国内可访问的镜像地址：<a href="https://updates.jenkins-zh.cn/update-center.json%E3%80%82">https://updates.jenkins-zh.cn/update-center.json。</a></p></li><li><p>设置好插件镜像源之后，去搜索对应的插件，下载安装即可。 </p></li><li><p>下载并安装插件：由于项目是用 Git 来管理的，并且使用的是 Maven，因此需要下载这两个插件。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建 Job 之前，需要先了解一个 Job 任务涉及到哪些流程。Jenkins 给我们提供了以下几个模块：</p><ul><li><p><code>General</code> Job 描述，可选。 </p></li><li><p><code>Source Code Management</code> 源代码管理，有多个版本工具选择：Git、Svn 等。 </p></li><li><p><code>Build Triggers</code> 构建触发器，选择构建代码的时机 </p><ul><li>Trigger builds remotely，手动去触发。</li><li>Build after other project are built，在其他项目构建完成后触发。</li><li>Build periodically，周期的进行构建</li><li>GitHub Hooks，当有代码更新到 GitHub，GitHub 会触发一个 Hooks，并通知 Jenkins 服务开始构建，这个需要在 GitHub 中配置推送地址信息。</li><li>Poll SCM 定时任务轮询，填写 Cron 表达式指定轮询的时机。例如：每 10 分钟去检查 GitHub 仓库是否有代码更新。</li></ul></li><li><p><code>Build Environment</code>构建环境，配置项目构建的环境，可以在构建的时候传递环境变量信息。 </p></li><li><p><code>Build</code> 可以选择构建所需步骤。 </p></li><li><p><code>Post-build Actions</code>可以指定项目完成构建之后的行为。</p></li></ul><h2 id="手动创建-Job"><a href="#手动创建-Job" class="headerlink" title="手动创建 Job"></a>手动创建 Job</h2><p>在 Jenkins 中添加两个任务，一个用于拉取代码运行测试、打包任务，另一个可以手动选择版本的部署任务。</p><h3 id="创建测试打包任务"><a href="#创建测试打包任务" class="headerlink" title="创建测试打包任务"></a>创建测试打包任务</h3><ol><li>填写创建的 Job 信息</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/24e982a6-9b83-4233-99f0-15c083663bb5.png" alt="image.png"></p><ol start="2"><li>选择 Git 作为代码管理工具，配置对应的仓库地址。如果是私密仓库，需要填写对应的账号密码。这里使用了 ssh 方式，并提前配置好了私钥信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/0c9f33b3-b50e-45dd-b984-8fdd5c4a1ea9.png" alt="image.png"></p><ol start="3"><li>选择一个构建方式，这里我们选择 SCM，填写一个每 10 分钟轮询一次的 corn 表达式。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/415593ca-72bb-4786-a3c5-14271c5d15ac.png" alt="image.png"></p><ol start="4"><li>构建的时候选择 <code>Execute shell</code> 并在文本框中填写要执行的脚本信息，这里我们填写 <code>mvn clean package</code>，该命令会执行清理、测试、打包操作，在 target 目录下生成 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3fea80cf-d62d-4d27-a028-4bae6b70c59a.png" alt="image.png"></p><ol start="5"><li>保存任务，回到页面。等待 10 分钟或者手动点击立即构建，即可开始构建。 控制台最终打印了文件夹下所有项目版本信息。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b452178d-9bdd-4873-98f7-663fd62ef8bf.png" alt="image.png"></p><h3 id="创建部署任务"><a href="#创建部署任务" class="headerlink" title="创建部署任务"></a>创建部署任务</h3><ol><li>创建 deploy 任务，在页面中填写描述，并勾选 <code>This project is parameterized</code>，选择 String 参数，这里定义一个变量 version。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f0e1221-1b21-4ac1-a991-19753f4085ca.png" alt="image.png"></p><ol start="2"><li>由于部署任务和打包任务是分开，此处无需在使用 Git 去拉取代码，也无需定义构建触发器，直接手动构建即可。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/8489f466-cf27-4f07-b07a-304f8b42769b.png" alt="image.png"></p><ol start="3"><li>build 环节还是去执行一个 shell，这里我们配置一个 java 程序启动命令 <code>java -Dserver.port=5000 -jar  /c/Users/Administrator/Desktop/jenkins/$&#123;version&#125;.jar</code>指定 5000 端口，并且根据输入的版本号，去执行对应的 jar 包。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/5f823c65-51d5-4936-b226-d635fc86e3c3.png" alt="image.png"></p><ol start="4"><li>根据上个任务构建的输出，我们执行部署任务的构建。Jenkins 会弹出提示，此时输入对应的项目版本号，点击开始构建，等待构建完成项目就启动成功了。</li></ol><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b651a7f8-0267-42c9-861b-4ea128b5f596.png" alt="image.png"></p><h2 id="使用-Jenkinsfile-创建-Job"><a href="#使用-Jenkinsfile-创建-Job" class="headerlink" title="使用 Jenkinsfile 创建 Job"></a>使用 Jenkinsfile 创建 Job</h2><p>图形化页面创建一个 Job 很方便，但是当 Jenkins 需要为多个项目创建 Job 时，一个一个手动创建就会很繁琐，并且 Job 信息也没办法进行版本管理。</p><p>Jenkinsfile 就是来解决这个问题的，他将 Job 的配置信息用脚本语言来表示，这样只需要维护这个脚本即可。Jenkinsfile 就像是一份说明书，指导 Jenkins 的工作，让他自动帮我们完成配置。编写 Jenkinsfile 的脚本语言是 Groovy，推荐学习。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>整个流程如图：<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/70124ec6-6334-457c-9f47-4341127d490c.png" alt="image.png"></p><p><strong>创建流程</strong>：</p><ul><li><p>为项目编写 Dockerfile。</p></li><li><p>创建 Jenkinsfile。</p></li><li><p>使用 pipleline 语法编写脚本：使用 Dockerfile 文件 build 一个镜像，并上传到 Docker 私服。</p></li><li><p>使用一个新的 Job，用来获取 Docker 私服所有项目版本信息，支持选择对应版本部署。</p></li></ul><h3 id="为项目编写-Dockerfile"><a href="#为项目编写-Dockerfile" class="headerlink" title="为项目编写 Dockerfile"></a>为项目编写 Dockerfile</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">FROM <span class="hljs-attr">java:</span>openjdk<span class="hljs-number">-8</span>u111-alpine<br><br>RUN mkdir /app<br><br>WORKDIR /app<br><br>COPY target<span class="hljs-regexp">/oh-my-jenkins-0.0.1-SNAPSHOT.jar /</span>app<br><br>EXPOSE <span class="hljs-number">8080</span><br><br>CMD [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;oh-my-jenkins-0.0.1-SNAPSHOT.jar&quot;</span> ]<br></code></pre></td></tr></table></figure><h3 id="在-master-分支创建-Jenkinsfile-并编写对应的脚本"><a href="#在-master-分支创建-Jenkinsfile-并编写对应的脚本" class="headerlink" title="在 master 分支创建 Jenkinsfile 并编写对应的脚本"></a>在 master 分支创建 Jenkinsfile 并编写对应的脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>     agent any<br>     triggers &#123;<br>          pollSCM(<span class="hljs-string">&#x27;* * * * *&#x27;</span>)<br>     &#125;<br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            agent &#123; docker &#123;<br>                image <span class="hljs-string">&quot;circleci/openjdk:8u212-jdk-stretch&quot;</span><br>                args <span class="hljs-string">&#x27;-v /usr/local/docker-cache:/root/.m2&#x27;</span><br>                            &#125;<br>                 &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&#x27;mvn clean package&#x27;</span><br>                stash <span class="hljs-attr">includes:</span> <span class="hljs-string">&#x27;**/target/*.jar&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;app&#x27;</span><br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Docker Build&#x27;</span>) &#123;<br>           steps &#123;<br>               echo <span class="hljs-string">&#x27;Starting to build docker image&#x27;</span><br><br>                unstash <span class="hljs-string">&#x27;app&#x27;</span><br>                script &#123;<br>                    <span class="hljs-keyword">def</span> customImage = docker.build(<span class="hljs-string">&quot;172.29.145.109:5000/on-my-jenkins:$&#123;new Date().format(&#x27;yyyy-MM-dd-HH-mm-ss&#x27;)&#125;&quot;</span>)<br>                    customImage.push()<br>                &#125;<br>           &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本定义了轮询任务，在 docker 中使用 java 环境运行 <code>mvn clean package</code>打包，并把它暂存。之后使用一个 docker build 构建镜像并推送到 docker 私服。由于私服地址和 Jenkins 都在同一个服务器，因此直接使用内网 ip。</p><h3 id="在-deploy-分支创建-Jenkinsfile-并编写部署脚本"><a href="#在-deploy-分支创建-Jenkinsfile-并编写部署脚本" class="headerlink" title="在 deploy 分支创建 Jenkinsfile  并编写部署脚本"></a>在 deploy 分支创建 Jenkinsfile  并编写部署脚本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> responseJson = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://172.29.145.109:5000/v2/oh-my-jenkins/tags/list&quot;</span>)<br>        .getText(<span class="hljs-attr">requestProperties:</span> [<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&quot;application/json&quot;</span>]);<br><br>println(responseJson)<br><br>Map response = <span class="hljs-keyword">new</span> groovy.json.JsonSlurperClassic().parseText(responseJson) <span class="hljs-keyword">as</span> Map;<br><br><span class="hljs-keyword">def</span> versionsStr = response.tags.join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>pipeline &#123;<br>     agent any<br><br>     stages &#123;<br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            input &#123;<br>                message <span class="hljs-string">&quot;Choose a version&quot;</span><br>                ok <span class="hljs-string">&quot;Deploy&quot;</span><br>                parameters &#123;<br>                    choice(<span class="hljs-attr">choices:</span> versionsStr, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;version&#x27;</span>)<br>                &#125;<br>            &#125;<br>            steps &#123;<br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker rm -f oh-my-jenkins&#x27; || true&quot;</span><br>                sh <span class="hljs-string">&quot;ssh root@172.29.145.109 &#x27;docker run --name oh-my-jenkins -p 8081:8080 -d 172.29.145.109:5000/oh-my-jenkins:$&#123;version&#125;&#x27;&quot;</span><br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该脚本获取 Docker 私服的<code>oh-my-jenkins</code>镜像，部署我们选择的版本。</p><h3 id="在-Jenkins-创建多分支流水线任务"><a href="#在-Jenkins-创建多分支流水线任务" class="headerlink" title="在 Jenkins 创建多分支流水线任务"></a>在 Jenkins 创建多分支流水线任务</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/b439354a-e1a4-47f4-9bf4-06975e7d8c98.png" alt="image.png"></p><p>然后只需要配置仓库地址就好了，由于 GitHub 抽风，所以使用 Gitee 仓库地址。<br><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/4047e5a2-911f-4a91-9380-55c45988a209.png" alt="image.png"><br>创建完流水线任务，他会自动扫描仓库上的所有分支，并读取 Jenkinsfile 文件，执行命令。</p><h3 id="选择版本部署"><a href="#选择版本部署" class="headerlink" title="选择版本部署"></a>选择版本部署</h3><p><img src="/../picture/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/3368c931-7653-4f8a-bc9e-df43d04ee7fc.png" alt="image.png"><br>当流水线分支创建完成之后，deploy 分支会等待我们选择版本，选择需要部署的版本，deploy 即可完成部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/"/>
    <url>/2022/07/14/Java%20%E4%B8%AD%E7%9A%84%20GC/</url>
    
    <content type="html"><![CDATA[<p>人在日常活动中不可避免会产生垃圾，程序也是如此。在方法中 new 一个对象，每次调用该方法都会进行 new 对象操作，如果没有人去管理这些对象，没有把这些对象占有内存及时释放掉，内存很快就会满。因此，在程序运行过程中，需要及时寻找和处理「 死去」的对象。这个「 死去」的对象就是<strong>垃圾</strong>，而寻找和处理垃圾的过程就叫做 <strong>GC</strong>。</p><p>GC 全称 “Garbage Collection” 即垃圾收集。不同的语言对于 GC 的处理都是不一样的，因此也产生了不同的「流派」。</p><p><strong>需要说明的是</strong>：本文介绍的 GC 都是基于 HotSpot。</p><h2 id="垃圾管理流派"><a href="#垃圾管理流派" class="headerlink" title="垃圾管理流派"></a>垃圾管理流派</h2><p>根据内存的管理方式，划分出两个流派：手动管理和自动管理。</p><p>手动管理的代表就是：C ++ 和 C。它们需要在编码过程中，手动去释放内存。</p><ul><li>优点：能明确垃圾的产生，以及提高回收的效率。 </li><li>缺点：垃圾太多，在代码中手动清理内存很「痛苦」，很容易忘记释放内存，导致内存泄露。由于需要明确垃圾的产生位置，因此也需要对该语言非常熟悉，这也无形中加大了语言的上手难度。</li></ul><p>自动管理的代表：Java (当然还有很多其他语言，篇幅有限，暂不阐述)。</p><ul><li>优点：使用者无需关心内存的使用，只需专注功能和业务的实现。内存的处理和回收有个智能的程序替我们完成。</li><li>缺点：屏蔽了底层细节，出现了内存问题，使用者无法着手解决。当然解决办法也很简单，就是去了解 GC 原理。</li></ul><h2 id="寻找垃圾"><a href="#寻找垃圾" class="headerlink" title="寻找垃圾"></a>寻找垃圾</h2><p>现在我们知道 Java 是自动 GC，那现在问题来了：它是怎么去找到垃圾？怎么保证找的对象就一定是垃圾呢？</p><p>在「 找垃圾」这块，也有两种方式：引用计数和可达性分析。虽然有两种方式，但主流的 Java 虚拟机里面都没有选用引用计数。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>如图所示，小圆圈代表对象，箭头代表引用关系，数字代表对象被引用的次数。可以看到蓝色的对象都是处于「 活跃」状态的，而灰色的对象要么没有被引用，要么引用它的对象没有被引用，这些对象就是程序需要回收的垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/2069ac04-c401-4330-bb40-6fda0dea5fcb.png" alt="GC-in-Java-01.PNG"></p><p>这一切看似完美无缺，实则存在一个巨大问题：对象间的循环引用。</p><p>仔细看上面这张图，红色的对象相互循环引用，程序并没有使用到，理应当作垃圾处理。但是，在引用计数方法看来这是个「 活跃」的对象，因此并不会进行处理。</p><p>在一些文章上有谈论到解决该问题的方法，例如：循环引用的对象使用 <code>弱引用</code>，使用单独的算法等，详情可以自行搜索。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>Java 就是通过<code>可达性分析</code>算法来进行内存管理的。</p><p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，即通过 GC Roots 访问不到该对象时，则证明此对象是垃圾。</p><p>用比较生活化的例子来解释：家是内存，家庭成员是 GC Roots，物品是对象，家庭大扫除就是可达性分析。家庭大扫除的结果就是把家庭成员都用不到的东西归为垃圾，并把它清除掉。</p><p>如图所示：灰色的对象就是 GC Roots 访问不到的对象，这些对象就是垃圾。图中也可以看到对象循环引用的问题的，在这里也已经不复存在，都会被当做垃圾。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/09db1a69-e11e-4a4b-9bdd-43946cb355a5.png" alt="GC-in-Java-02.PNG"></p><p>大扫除的例子，我们知道「 家庭成员」是 GC Roots，在 Java 技术体系中常见的 GC Roots 包括以下几种：</p><ul><li>线程</li><li>native 方法</li><li>栈帧中的局部变量表</li><li>Class 引用的 static field</li><li>所有被同步锁（synchronized关键字）持有的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过上面两种方法来看，似乎对象在内存中的状态只有「 被引用」和「 未被引用」两种状态，GC 把「 未被引用」 的对象收集。</p><p>在在内存空间充足时，可能并不希望「 未被引用」的对象被清除，只有当内存紧张时，才把那些对象抛弃。</p><p>在 Java 中对引用的概念进行扩充，将引用分为：</p><ul><li>强引用（Strongly Re-ference） <ul><li>在 Java 程序代码中普遍存在的就是<code>强引用</code>，比如你 new 一个对象。</li></ul></li><li>软引用（Soft Reference） <ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li></ul></li><li>弱引用（Weak Reference） <ul><li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li></ul></li><li>虚引用（Phantom Reference） <ul><li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。类似于 Linux 中的 <a href="https://zh.wikipedia.org/wiki/%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">退出状态</a>。</li></ul></li></ul><p>这4种引用强度依次逐渐减弱。</p><h2 id="垃圾自我救赎"><a href="#垃圾自我救赎" class="headerlink" title="垃圾自我救赎"></a>垃圾自我救赎</h2><p>使用可达性分析找到「未被引用」的对象并不会立即将内存释放，而是给这些对象进行<code>标记</code> ，当对象被<strong>标记两次</strong>后才会进行回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/8939c679-8d1a-4d66-8bd4-910e8e25d6bd.png" alt="image.png"></p><p>当对象第一次标记之后，随后会进行一次筛选，筛选的依据是：<strong>对象是否有必要执行 finalize() 方法？</strong></p><p>假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>「没有必要执行」</strong>。</p><p>对象被判定为「没有必要执行」，则直接进行回收。否则，会把对象放入到一个名为 <code>F-Queue</code> 的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。流程如下：</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/f74a1943-9e8f-440b-b097-b3eb7995cd64.png" alt="image.png"></p><p>对象的 finalize() 方法执行，GC 对 <code>F-Queue</code> 中的对象进行第二次标记。如果 finalize() 方法执行之后，对象重新回到了 GC Roots 的引用链上，则把它移出队列。否则，被 GC 回收。</p><p><img src="/../picture/Java%E4%B8%AD%E7%9A%84GC/41e3ebdc-ac30-40a3-9783-9bdd08b958f7.png" alt="image.png"></p><p>这个时候你可能就有问题了：那我在对象的 finalize() 方法中，编写代码使得当前对象重新回到 GC Roots 引用链上，这个对象岂不是永远不会被 GC 回收？</p><p>答案是会被回收。可以看到「没有必要执行」的条件中有一条是： <strong>finalize() 方法已经被虚拟机调用过</strong>。因此对象虽然能回到引用链上，但是下一次 GC 它一定会被回收。<strong>总结就是：一个对象只能被救赎一次。</strong></p><p>其实关于  finalize() 方法，很多人也不了解，只需要知道它会于 GC 过程产生联系即可。在 《Effective Java》第三版 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/dev/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md">Item 8</a> ，以及《深入理解 Java 虚拟机》第三版中，作者都不建议在代码中使用 finalize，甚至让我们忘记这个 API。</p><p>因此，使用  finalize() 方法的最佳实践就是：从不使用它。</p><blockquote><p>文章参考《深入理解 Java 虚拟机》第三版、《Effective Java》第三版、《Plumbr Handbook Java Garbage Collcetion》。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2022/02/26/JVM%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>谈起 JVM 第一印象就是「八股」，毕竟正经人谁学 JVM 啊。当我深入学习，了解了相关原理后，真令人大呼过瘾。</p><p>了解 JVM 并不会让你更快的 CRUD，对大部分工作没有实质性的帮助，但这是成为高级程序员的第一步。</p><h2 id="JVM-初识"><a href="#JVM-初识" class="headerlink" title="JVM 初识"></a>JVM 初识</h2><p>JVM 全称是 <strong>Java virtual machine</strong> 即 Java 虚拟机。JVM 是抽象（虚拟）计算机，它定义了一系列规范，因此他有很多实现，如：HotSpot，Eclipse OpenJ9 等等，最常使用的应该就是 Oracle 的 HotSpot。</p><p>JVM 存在的意义就是抹平所有平台和操作系统的鸿沟。它就像是一个在不同平台提供的翻译官，当用英语和它对话时，他翻译成自己「国家」的语言并执行。这就是为什么在 Windows 下编写好的代码能够在 Linux 等其他系统运行的原因。</p><p>代码编译执行过程如图<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/4ff19c89-d87f-4273-bfe4-3c47e3a8f1ad.png" alt="jvm_1.png"><br>程序员使用像 Java，Kotlin，Scala ，Groovy 等高级语言进行编码，编译成 JVM 能识别的语言。JVM 识别并进行「二次编译操作」，将它翻译成对应的平台语言。</p><p>日常编码所做的仅仅只是用高级语言编写一份「说明书」，说明书如何编译成中间语言，这就是高级语言编译器做的事了，当然也可以自己去实现一个编译器，嗯。。至少我目前没有这个能力。</p><p><strong>JLS</strong></p><p>Java 语言规范 Java Language Specification， 定义了 Java 编程的语法。比如 Java 中的关键字信息 class、public 等等，都是在 JLS 规范下，完成 Java 代码的开发。</p><p><strong>JVMS</strong></p><p>Java 虚拟机规范 Java Virtual Machine Specifiction，定义了字节码如何在 JVM 中执行，仅此而已。</p><h2 id="JVM-堆-Heap"><a href="#JVM-堆-Heap" class="headerlink" title="JVM 堆 (Heap)"></a>JVM 堆 (Heap)</h2><p>堆是 JVM 中非常重要的区域，所有的「对象」都在堆上分配，它是个无情的对象生产机器，只负责生产，不负责销毁。</p><p>堆为我们创建了对象，但是在代码中操作与访问对象实际上都是在操作对象的地址或者引用。</p><p>来看个非常简单的代码，以此来演示堆中发生了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/1540f816-9a4c-4b1f-af66-0a4c6b917b3c.png" alt="jvm_heap.png"><br>首先堆内存中创建了一个对象（假设对象地址为 100），然后将该对象的地址赋值给 obj 变量，可以想象有一条线将 obj 和 对象 100 连接起来。</p><p>接着，堆内存中又创建了一个变量 101，然后将该对象地址赋值给 obj，此时 obj 和对象 101 连接起来了。这就是堆所做的一切。</p><p>很显然，上面的例子对象 100 还是存在堆中，他并没有消失，他还在等有缘人「联系」它。</p><p>这样就会存在一个问题，「无人问津」的对象越来越多怎么办？这就涉及到 GC 了，GC 会根据相应的算法来判断对象是否需要回收销毁，因此暂时不需要操心，后续提供 GC 的讲解。</p><p>当然堆中产生的对象太多，大量占用堆内存，导致内存溢出，常见表现为 OOM (Out Of Memory) 异常。当代码出现该异常时，就应该关心，代码是否产生了大量不必要的对象，谨慎的检查代码。</p><h2 id="JVM-栈（Stack）"><a href="#JVM-栈（Stack）" class="headerlink" title="JVM 栈（Stack）"></a>JVM 栈（Stack）</h2><p>当我们用 IDEA Debug 如下代码，可以看到在 IDEA 界面底部，多了一些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    a();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am a&quot;</span>);<br>    b();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我的调试器中表现形式如下：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/9c51eaa9-3ce2-4d47-9a40-b38be9fba7aa.png" alt="method_stack.PNG"></p><p>从 main 方法到 b 方法，中间一系列调用都称作<strong>「栈」</strong>或<strong>「方法栈」</strong>，其中每一次方法调用称作<strong>「栈帧」</strong>，如图中的 main，a，b。</p><p>不知你是否思考过，为什么代码的调用形式会是这样？无论你是否好奇过，现在我来分析下代码执行的过程。</p><p>我们都知道，Java  程序的入口都是 main 方法开始的，因此当代码被执行时，会先调用 <strong>main</strong> 方法。不过，在调用 main 方法之前，JVM 创建一个方法栈，用来保存「当前线程」方法调用过程（因此方法栈是线程私有的）。于是方法栈中会放入第一个栈帧 main，由于栈结构的特性，main 自然而然的就会在栈底。</p><p>接着执行 main 方法，执行到最后需要调用 <strong>a</strong> 方法，因此将栈帧 a 放入方法栈中。接着 a 中又调用 b 方法，以此类推。现在，方法栈中已经有 3 个栈帧了，方法调用已经结束了。于是从栈顶开始，将方法的执行结果依次返回，b 方法中无返回值，因此执行完打印语句，b 栈帧就销毁了。以此类推到 a 方法，最后到 main，这就是上述代码玩完整的执行过程，流程如图：</p><p><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/41370100-58dc-4f78-bdde-b88dd7483c77.png" alt="method_stack_invoke.png"></p><p>了解了方法调用的基本流程，这里有几个疑问：</p><p><strong>Q：当方法栈满了会发生什么？</strong></p><p>A：当栈深度过⼤时抛出 StackOverflowError，著名的程序员交流网站就是以此命名的 <a href="https://stackoverflow.com/">stackoverflow</a></p><p><strong>Q：栈帧销毁什么时候被销毁？</strong></p><p><strong>A</strong>：这些情况栈帧会被销毁：当方法执行抛出异常或者错误；方法正常返回结果或者无返回。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>来看一段简单的代码， a 方法定义了一个变量，并且调用了 b 方法使得该变量自增，然后打印该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    b(i);<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    i++;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中打印的结果为 0，按照正常的思维去理解的话，i 的值因该为 1 才对，这是为什么？</p><p>这是因为这些变量在方法中都是<strong>「值传递」</strong>的，当把 i 传递给 b 方法时，发生了一次拷贝，因此 b 方法中操作的 i，实际上只存在 b 方法中，并不会影响到 a 方法中的 i 变量。</p><p>上面说的是基本类型变量传递，接下来用引用数据类型来进行参数传递，看看发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    b(obj);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(Object obj)</span>&#123;<br>    obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>a 方法中初始化了一个变量 obj，并把它当作参数传递给 b 方法，b 方法中创建一个新的对象，并把该对象地址赋值给参数 obj。整个过程就是这样，此时 a 中的 obj 对象和 b 中的 obj 是什么关系？他们是同一个对象吗？b 中的对象改变了，会影响到 a 吗？</p><p>有过编程经验的应该都知道，答案是否定的。<br><img src="/../picture/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/42e48b45-6083-49b6-ae87-95fe66c76114.png" alt="stack_argument.png"><br>如图所示，a 中 obj 变量指向 Object 10087，把 obj 当作参数给 b 方法时，他会直接复制 obj 所指向的对象地址，即 b 方法刚开始也指向 10087 对象。之后创建了一个新对象地址为 10086，并把地址重新赋值给了 obj，因此 b 中的 obj 指向的是 10086，而 a 指向的是 10087，两者操作的都不是同一个对象，因此也不会相互影响。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>现在已经对 JVM 中的堆和栈有所了解，但是对于方法栈中的每个栈帧还不了解，目前只是知道方法调用就入栈，结束就出栈。因此，现在将栈帧放大来看，看看代码执行过程中，栈帧发生了什么。</p><p>每个栈帧中都有一个「操作数栈」和「局部变量表」。</p><p>每当方法调用开始的时候，局部变量表会被初始化成当前方法的参数。操作数栈上会根据代码实际情况，加载局部变量表中的数据，或者直接加载常量，根据<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">字节码指令集</a>，完成相应的数据操作。</p><p>这就像是人在吃饭一样，用筷子在碟子（局部变量表）中夹菜，夹到碗中（操作数栈），然后根据自己喜好（代码）吃自己的菜。</p><h2 id="JVM-方法区"><a href="#JVM-方法区" class="headerlink" title="JVM 方法区"></a>JVM 方法区</h2><p>方法区中包含了整个虚拟机所共享的 Class 信息，JVM 就是根据方法区中 Class 这份说明书，来帮我们生成对象的。</p><p>方法区中存的所有信息都是共享，基本都是只读的，但这并不是一定的。<strong>「运行时常量池」</strong>就是个例外，在程序运行时往往会往常量池中放入常量信息。</p><p>运行时常量池会保存经常使用的常量，例如 String 字符串常量，当重复 new 一个相同字符串对象时，新的对象就会指向字符串常量池中的字符串常量，这样就节省了内存开销。同时在 String api 中，由于常量的重复使用，可以使得它的 equals 方法可以更快速地进行判断。</p><p><strong>永久代和元空间</strong></p><p>JVM 方法区是一块所有的线程共享的区域，是 JVM 所定义的规范。</p><p>Java 7 之前发方法区的实现称作<strong>「永久代」</strong>，即 <strong>PermGen</strong>。Java 8 之后的称作<strong>「元空间」</strong>，即 <strong>Metaspace</strong>。</p><p>在 Java 7 中，方法区和堆是使用一块连续的物理内存，仅仅是在逻辑上分开的。如果没有设置方法区的大小的话，使用默认大小很容易遇到 OOM 错误。</p><p>在 Java 8 之后，把方法区和堆区分开来，使用了本地内存（Native memory），大小取决于本地内存大小。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2021-年终总结（技术向）</title>
    <link href="/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/"/>
    <url>/2022/01/01/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单的聊一聊一年下来自己学到了哪些技术，做了那些改变。</p><h3 id="学习技术与成果："><a href="#学习技术与成果：" class="headerlink" title="学习技术与成果："></a>学习技术与成果：</h3><ul><li>Maven，啃了半本《Maven 实战》，经典永不过时。能够解决 Maven 冲突，并写了一个简单的 Maven 插件。</li><li>学习使用 Docker，熟悉 Docker 基本命令，会编写简单的 Dockerfile，以及发布自己的 Docker 镜像。</li><li>了解 Jenkis 自动化部署的流程，能够进行简单的构建。</li><li>学习 Liunx，了解基本命令，熟悉管道，Shell，线程机制。</li><li>编写了自己的自动化脚本，自动拉取代码打包，运行项目。</li><li>会编写单元测试和集成测试，熟悉使用 Junit5 和 Mockito。</li><li>学会使用了 Maven 插件：SpotBugs (代码缺陷检查工具)、Checkstyle (代码规范检查工具)、jaCoCo (测试覆盖率报告插件)、Flyway（数据库迁移工具）</li><li>深度学习 Java 集合常用的集合类，并手自己写了 ArrayList、LinkedList 实现。</li><li>了解了开源项目运作和管理流程、学会使用了 CircleCi 管理自己的代码。</li><li>熟练使用 Java8 的语法、Stream、Optional、CompleteFuture（后悔学的太晚）。</li><li>写了一个简单的新浪新闻爬虫。</li><li>GitHub 也开始有绿点了，尽管不多，但也是个很好的开始。</li></ul><p><img src="/../picture/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%8A%80%E6%9C%AF%E5%90%91%EF%BC%89/a2f75394-0052-49aa-8e37-a56774bf8a47.png" alt="image.png"></p><ul><li>帮助开源项目 <a href="https://github.com/ByteLegend/ByteLegend">https://github.com/ByteLegend/ByteLegend</a>，修复了一个 bug，这个是我参与开源修的第一个 bug。帮助修复了 ByteBuddy 中文文档错字 bug，尽管很小的 bug，但是能接触到 ByteBuddy 我感到很荣幸。</li><li>了解 log4j 的漏洞的基本原理，并自己用代码开启 ldap 服务，复现了 bug。</li></ul><h3 id="知识获取渠道推荐："><a href="#知识获取渠道推荐：" class="headerlink" title="知识获取渠道推荐："></a>知识获取渠道推荐：</h3><ul><li>正式抛弃百度搜索、全面拥抱 Google，如果无法用 Google、你也不应该用百度。必应搜索也可以、以及 V 站大佬做的搜索引擎 <a href="https://fsou.cc/">https://fsou.cc/</a>，搜索结果来源取自 Google、必应等。访问 GitHub 和 Stack Overflow 有速度加成。</li><li>取关了一系列公众号大 V，虽然他们技术很牛，但广告的投放技术也是牛上天。而且大部分文章抄袭国外的技术博客，程序员不应该等待别人给你投喂，应该自己去获取一手资源。</li><li>论坛：<ul><li><a href="https://v2ex.com/">V站</a> 国内程序员论坛、 程序员的一切里面都有、牛人遍地跑。虽然是国内程序员论坛、但也是需要科学上网。</li><li>HackNews，给程序员看的新闻。国内许多公众号大 V抄袭翻译的地方。</li><li>GitHub 全球最大的同性交友平台（手动滑稽）</li><li>CoolShell 博客技术论坛，作者是个乐于分享技术的大牛，文章质量非常高。</li><li>[<a href="https://nipafx.dev/]">https://nipafx.dev/]</a>(You. Me. Java)，国外开源大牛的技术博客，你想知道的 java 的一切（java 8 ~ java18）里面基本都有。</li></ul></li><li>许多经典书籍，主要就看了这几本：《Java8 实战》、《Maven 实战》、《Effective Java》第三版、《重构改善现有代码设计》第一版。</li><li>了解了一些非常优秀的程序员：方应杭（前端大牛，现在是全栈大牛、非常喜欢看他的直播）、ZhangBo(Gradle 公司员工，开源世界大牛，我的评价是<strong>无所不知</strong>)、陈皓（Collshell 作者）</li></ul><h3 id="2022-的一些目标"><a href="#2022-的一些目标" class="headerlink" title="2022 的一些目标"></a>2022 的一些目标</h3><ul><li>工作顺利、生活愉快。</li><li>去年看书还是看的很少，许多经典书籍都还没开始看。2022 年，我要把 《重构，改善现有代码设计》第二版看完，读完《Effective Java》、《Java 并发编程实战》、《程序员的自我修养—链接、装载与库》、《编码：隐匿在计算机软硬件背后的语言》</li><li>参与到更多开源项目中去、GitHub 绿点也可以多一些。</li><li>保持自己的好奇心、做自己想做的事。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2021/12/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题场景：给定一组文章 id 列表，如何判断文章 a 的 id 在给定的列表中？</p></blockquote><p>我们很容易使用列表、数组、哈希表等将文章 id 先保存起来，判断重复时，直接遍历数组、列表、根据哈希值判断等。</p><p>上面的解决方式，最好的无疑是哈希表。哈希表检索时间复杂度为 O(1)，但是这只限于没有发生哈希冲突的情况下，而且数据量一旦比较大，存储占用也会大大增加，会导致检索性能大大下降。</p><p>对于数据量较大的场景，如何快速检索元素是否包含在另一个集合中，这就引出今天的主角了「布隆过滤器」。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></blockquote><p>简介引用自维基百科，里面有两个概念「二进制向量」，「映射函数」。</p><p><strong>二进制向量</strong>就是一堆 bit(位) 的集合，bit 我们都知道就是只能表示 0 和 1。其实我们常使用的 int 有 32 位，因此他也可以看做一个二进制向量。</p><p>下面是一个简单的示例，每一个空格就代表一个 bit，下面的数字表示它的索引：</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/54a416e0-66c1-4893-aade-ede8e001bd04.png" alt="1.png"></p><p><strong>映射函数</strong>我们其实很并不陌生。使用过 HashMap 就应该知道，对 key 使用 hashCode 方法，计算哈希值，这个 hashCode 方法就是一个映射函数，一个 key 只能对应一个哈希值。</p><p>布隆过滤器对一个 key 使用多个映射函数，得到多个值。</p><p>哈希函数映射</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/63b9a80b-0cd5-48ea-ac54-a93256a7caf7.png" alt="hash.png"></p><p>布隆过滤器中映射函数</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/51445b83-d4a0-497f-8ebb-5f0fb9ddcc76.png" alt="bloomfilter.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解一些基本概念之后，布隆过滤器的原理就很明了了。</p><p>布隆过滤器对于要保存的值使用一系列随机的映射函数，得到二进制向量下标，然后把对应的 bit 置为 1，就是这么简单。</p><p>例如，字符串 “zzh”，经过三个随机的映射函数，对应的下标为 2，7，11 因此对应的 bit 为 1。</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/ccf230bf-6de4-49ab-8238-c9387cad586d.png" alt="insert.png"></p><p>我们可以对要插入到的字符串应用同样的哈希函数，然后看二进制向量里对应的bit 是否全为 1 来判断一个元素是否在集合里。</p><p>如果是，则该元素<strong>可能</strong>在里面，注意是可能。 因为这些位置有可能是由其他元素或者其他元素的组合所引起的，这也就导致了布隆过滤器的误识别率。</p><p>如果不是，则表示该元素一定不在集合中。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>我更习惯在介绍一个功能的时候，先把他的缺点说出来，知道缺点的话，后续就可以大胆的应用。</p><h3 id="误识别率"><a href="#误识别率" class="headerlink" title="误识别率"></a>误识别率</h3><p>插入字符串 “zzh” 得到下标 2、7、11</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8b034b8d-b422-4dfc-a270-10c65db5d255.png" alt="insert.png"></p><p>插入字符串 “greek” 得到下标 5、8、9</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4bc4c95c-abee-4c20-9d5e-cf66a4b02cd5.png" alt="insert_greek.png"></p><p>插入字符串 “gem” 得到下标 2、5、8</p><p><img src="/../picture/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/66253d9d-d8ac-4783-9ba3-a3f954bfb9fa.png" alt="insert_gem.png"></p><p>可以看到 “gem” 得到的下标对应的 bit 都已经为 1，但是该字符串并不在集合中，这就是布隆过滤器的误识别率。</p><h3 id="删除困难"><a href="#删除困难" class="headerlink" title="删除困难"></a>删除困难</h3><p>删除困难的原因和误识别率是如出一辙。例如我们只想把 “gem” 字符串删除，于是把下标为 2、5、8 的 bit 都置为 0，这样的话 “greek” 和 “zzh” 部分数据就被删除了。无法保证删除的下标影响到其他元素，这就是布隆过滤器删除困难的原因。</p><p>我们也很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。但是这样根本不可行，因为连一个元素是否在集合中都无法百分百保证，又何来的把这个元素删除呢？就好比你想能为开源世界大牛，现在却连 GitHub 都无法保证访问一样。</p><h3 id="规避手段"><a href="#规避手段" class="headerlink" title="规避手段"></a>规避手段</h3><p>识别率和删除困难虽然都是缺点，但都是可以通过一些手段去规避。</p><p>假设在布隆过滤器里面有 <em>k</em> 个映射函数, <em>m</em> 个比特, 以及 <em>n</em> 个已插入元素，那么该过滤器误判率近似于：_(1-e-kn&#x2F;m)k_ 。因此我们可以通过调整映射函数数量和布隆过滤器的大小来降低误判率。</p><p>对于应该使用多少个映射函数，国外的一篇博客给了较好的答案，引用部分为原文内容，详情<a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/#footnote2">点击</a></p><blockquote><p>对于给定的 <em>m</em> 和 <em>n</em> ，有一个函数可以帮我们确定最优的 <em>k</em> 值: <em>(m&#x2F;n)ln(2)</em></p><p>所以可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的_n_, <em>m</em>, and _k_计算错误率。如果这个错误率不能接收，那么回到第二步，否则结束</li></ol></blockquote><p>事实上，已经存在许多布隆过滤器变种，他们使用更好的映射函数、支持删除元素、更低的误判率等等。维基百科上记录了 60 多种布隆过滤器的变体。例如：布谷鸟过滤器、布卢姆过滤器、等等，他们相比原始的布隆过滤器往往有更强的特性，详情访问<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">wiki</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>查询效率和插入效率高</strong>，时间复杂度为 O(k) ，k 为映射函数的数量。因为你每次查询或者插入一个元素时，都是通过 k 个函数计算对于的 bit 下标，然后检查对应的 bit 位是否为 1 或者将 bit 位置位 1。</p><p><strong>空间效率</strong>。布隆过滤器的空间效率取决于你期望的误判率，期望的误判率越小，所需的空间就要更大，因此无法具体量化。我们可以简单的和 HashMap 做个对比。</p><p>假设 HashMap 和布隆过滤器都保存字符串 “zzh”，且布隆过滤器使用 3 个映射函数。HashMap 仅保存这个字符串需要 6 个字节，即 48 bit，而布隆过滤器只需要 3 个 bit。</p><p>一些应用场景：URL 黑名单判断、垃圾邮箱判断、弱密码检测、比特币钱包同步等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
